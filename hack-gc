#!/usr/bin/env python
import sys, os, re, time
from subprocess import check_output, call

if len(sys.argv) > 1:
  print "usage: " + sys.argv[0] + " [--dry-run|--commence]"
  sys.exit(1)

proto_full_branch = check_output(["hack-prototype"]).strip()
proto_short_branch = proto_full_branch[len("scalamacros:"):]
proto = check_output(["hack-home", proto_full_branch]).strip()
print "Step 1: Updating " + proto + " to find out what branches have already been merged"
call(["git", "remote", "update"], cwd = proto)
def postprocess(branch):
  branch = branch.strip()
  if "*" in branch: return None
  if "->" in branch: return None
  if "2.10.x" in branch: return None
  if "master" in branch: return None
  if "paradise/macros" in branch: return None
  if "paradise/macros210" in branch: return None
  if "paradise/macros211" in branch: return None
  if branch.startswith("remotes/origin/"): return branch[len("remotes/origin/"):]
  if branch.startswith("remotes/"): return None
  return branch
merged = check_output(["git", "branch", "-a", "--merged"], cwd = proto).strip().split("\n")
merged = map(postprocess, merged)
merged = filter(lambda branch: branch != None, merged)
print "Already merged branches: " + str(merged)

print ""
print "Step 2: Iterating through hack homes to detect garbage"
dirs = check_output(["hack-homes", "--dirs"]).strip().split("\n")
branches = check_output(["hack-homes", "--full-branches"]).strip().split("\n")
results = []
processed = 0
start_time = time.time()
for dir, branch in zip(dirs, branches):
  def verdict(status):
    global processed
    processed += 1
    verdict_time = time.time()
    estimated_time = int((verdict_time - start_time) * (len(dirs) - processed) / processed)
    results.append((dir, branch, status))
    print dir.ljust(60, " ") + " " + status.ljust(20, " ") + " " + "ETA = " + str(estimated_time)
  if branch.startswith("scalamacros:topic/snippet") or branch.startswith("scalamacros:topic/macrosnippet"):
    verdict("* snippet")
  elif branch == "scalamacros:master" or branch =="scalamacros:paradise/macros" or branch =="scalamacros:paradise/macros210" or branch =="scalamacros:paradise/macros211":
    verdict("special")
  else:
    call(["git", "remote", "update"])
    _, _, _, status = check_output(["hub-introspect"], cwd = dir).strip().split("\n")
    if not status.startswith("no changes"):
      verdict(re.match(r"^repository .* is dirty \((.*)\).*$", status).group(1))
    else:
      if branch[len("scalamacros:"):] in merged: verdict("* merged")
      elif "*" in check_output(["git", "branch", "--merged", "upstream/" + proto_short_branch], cwd = dir): verdict("* merged")
      else: verdict("not merged")

print ""
print "Step 3: Generating garbage collection script"
target_path = "/usr/local/bin/zzz-commence-hack-gc"
if not os.path.exists(target_path):
  print target_path + " not found"
else:
  with open(target_path, "w") as target:
    def write(line): target.write(line.strip() + "\n")
    write("#!/usr/bin/env bash")
    write("set -o verbose")
    write("cd " + proto)
    for branch in merged:
      write("git branch -D " + branch)
      write("git push origin :" + branch)
    write("git remote update")
    write("git remote prune origin")
    write("cd -")
    for dir, branch, status in results:
      if status.startswith("*"): write("hack -" + branch + " --batch --force # " + status[1:].strip())
  print "Successfully wrote the cleanup script to " + target_path

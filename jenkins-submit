#!/usr/bin/env python
import subprocess, sys, re, urllib2, traceback, time, json
from subprocess import Popen, call, PIPE

if len(sys.argv) > 1:
  print "usage: " + sys.argv[0]
  sys.exit(1)

# a lot of stuff here is copy/pasted from git-pull-request
# todo. fix the duplication
origin = Popen(["git", "config", "--get", "remote.origin.url"], stdout=PIPE).communicate()[0]
if not origin:
  print "not a git repo"
  sys.exit(2)

def match1(): return re.match("^git://github.com/(?P<user>.*?)/(?P<repo>.*).git$", origin)
def match2(): return re.match("^git@github.com:(?P<user>.*?)/(?P<repo>.*).git$", origin)
m = match1() or match2()
if not m:
  print "origin (" + origin + ") doesn't point to a github repo"
  sys.exit(3)

changed = Popen(['git','diff','--name-status'], stdout=PIPE, stderr=PIPE).communicate()[0].splitlines()
staged = Popen(['git','diff', '--staged','--name-status'], stdout=PIPE).communicate()[0].splitlines()
untracked = Popen(['git','ls-files','--others','--exclude-standard'],stdout=PIPE).communicate()[0].splitlines()
if changed or staged or untracked:
  if changed: print "repository is dirty (has modified files)"
  elif staged: print "repository is dirty (has staged files)"
  elif untracked: print "repository is dirty (has untracked files)"
  sys.exit(4)

branch = Popen(["git", "rev-parse", "--abbrev-ref", "HEAD"], stdout=PIPE).communicate()[0][:-1]
ahead = None
behind = None
if not branch: # not on any branch
  branch = Popen(['git','rev-parse','--short','HEAD'], stdout=PIPE).communicate()[0][:-1]
else:
  remote_name = Popen(['git','config','branch.%s.remote' % branch], stdout=PIPE).communicate()[0].strip()
  if remote_name:
    merge_name = Popen(['git','config','branch.%s.merge' % branch], stdout=PIPE).communicate()[0].strip()
    if remote_name == '.': # local
      remote_ref = merge_name
    else:
      remote_ref = 'refs/remotes/%s/%s' % (remote_name, merge_name[11:])
    revgit = Popen(['git', 'rev-list', '--left-right', '%s...HEAD' % remote_ref],stdout=PIPE, stderr=PIPE)
    revlist = revgit.communicate()[0]
    if revgit.poll(): # fallback to local
      revlist = Popen(['git', 'rev-list', '--left-right', '%s...HEAD' % merge_name],stdout=PIPE, stderr=PIPE).communicate()[0]
    behead = revlist.splitlines()
    ahead = len([x for x in behead if x[0]=='>'])
    behind = len(behead) - ahead
if ahead or behind:
  print "repository is dirty (head is different from remote)"
  sys.exit(5)

# copy/paste ends here
jenkins_url = m.expand("https://scala-webapps.epfl.ch/jenkins/job/scala-checkin-manual/buildWithParameters?githubUsername=\g<user>&repository=\g<repo>")
jenkins_url += ("&branch=" + branch)
jenkins_url += "&storeArtifacts=true"
import webbrowser
webbrowser.open(jenkins_url)

time.sleep(2)

try:
  data = urllib2.urlopen("https://scala-webapps.epfl.ch/jenkins/job/scala-checkin-manual/api/json").read()
  data = json.loads(data)
  result = data["lastBuild"]["url"]
  if result:
    status = Popen(["jenkins-track", result], stdout=PIPE).communicate()[0]
    status = status.replace("nothing new", "").strip()
    call(["growlnotify", "-n", "Jenkins Submit", "-m", str(status)])
  else:
    call(["growlnotify", "-n", "Jenkins Submit", "-m", "Failed to communicate with the Jenkins API"])
except:
  _, value, _ = sys.exc_info()
  call(["growlnotify", "-n", "Jenkins Submit", "-m", str(value)])

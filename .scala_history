class C extends { type T = Int } with A
class B[T]
class C extends { type T = Int } with B[T]
class B(x: Int)
class C extends { val x = 2 } with B(2)
class B[T]
class C extends { type T = Int } with B[T]
impl2
class C extends { type T = macro impl2 } with AnyRef
exit
class C extends { val x = 2 } with B(x)
exit
type T = macro impl2
typeOf[T]
def foo = macro impl1
reify(foo)
res1.eval
class C(x: Int)(y: Int) extends scala.annotation.StaticAnnotation
class X @C(2)(3) ()
class X @C(2) ()
class ann1(x: Int) extends scala.annotation.StaticAnnotation
class C @ann1(2) ()
class ann2(x: Int)(y: Int) extends scala.annotation.StaticAnnotation
class C @ann2(2)(3) ()
exit
def foo( = macro impl
def foo( = macro impl)
def foo() = (macro impl
)
val macro = 1
def foo() = (macro impl
)
def foo = macro impl1
implicit class IntExt(i: Int) { def impl = 2 }
def foo() = (macro impl)
def foo() = (macro impl()
exit
Ident(newTermName("x")).attachmetns
Ident(newTermName("x")).attachments
exit
class C; object C { implicit val list = List[C](new C) }
exit
new B().toString
exit
reify{ object C }
showRaw(res0.tree)
exit
class C; object C extends C
class C { println(C); }; object C
new C
exit
typeOf[_ => _]
typeOf[_ => _].typeSymbol.typeSignature
exit
class C extends Any
class C extends AnyRef
def foo = { println("foo"); 1 }
foo #:: foo #:: Stream.Empty
def foo: Int = { println("foo"); 1 }
1 :: 2 :: Nil
foo #:: foo #:: Stream.Empty
1 #:: 2 #:: Stream.Empty
1 #:: Stream.Empty
1 #:: Stream.empty
foo #:: foo #:: Stream.Empty
foo #:: foo #:: Stream.empty
def foo1: Int = { println("foo1"); 1 }
def foo2: Int = { println("foo2"); 2 }
foo1 #:: foo2 #:: Stream.empty
Stream.iterate(1)(_)
Stream.iterate(1)(x => x)
List(1, 2) flatMap { case 1 => Some(1) }
List(1, 2) collect { case 1 => Some(1) }
List(1, 2) collect { case 1 => 1 }
foo1 #:: foo2 #:: Stream.empty
def foo1: Int = { println("foo1"); 1 }
def foo2: Int = { println("foo2"); 2 }
foo1 #:: foo2 #:: Stream.empty
res4 match { case hd #:: tl => }
Lisr(1, 2, 3) match { case hd #:: tl => }
List(1, 2, 3) match { case hd #:: tl => }
List(1, 2) collect { case 1 => println("x") }
exit
List(1, 2) match { case List(x, xs: _*) => }
List(1, 2) match { case xs :+ x => println(xs, x) }
List(1, 2) match { case xs ++ ys => xs }
trait Fooable[T]
class C; object C { implicit val x = new Fooable[C]{} }
implicitly[Fooable[C]]
trait Fooable[T]
class C; object C { implicit val x = new Fooable[C]{} }
implicitly[Fooable[C]]
exit
import scala.reflect.runtime.universe.{typeOf, TypeRef}
typeOf[Int] match { case TypeRef(_, sym, _) => println(sym) }
import scala.reflect.runtime.universe.TypeRefTag
typeOf[Int] match { case TypeRef(_, sym, _) => println(sym) }
exit
NoSymbol.associatedFile
staticClass("Int")
getClass("Int")
getDefinedClass("Int")
getClassByName("Int")
definitions.getClassByName("Int")
rootMirror.getClassByName("Int")
rootMirror.getClassByName(newTypeName("Int"))
rootMirror.getClassByName(newTypeName("scala.Int"))
res8.associatedFile
rootMirror.getClassByName(newTypeName("scala.collection.immutable.List"))
res10.associatedFile
res10.associatedFile.getFile
res10.associatedFile.path
case class C(x: Int)
new C().productIterator
new C(2).productIterator
new C(2).asInstanceOf[Product]
new C(2).asInstanceOf[Product].productIterator.toList
for (i <- 0 to 2) println(i)
import scala.collection.mutable.ListMap
ListMap(1 -> 2)
(2 -> 3) +: ListMap(1 -> 2)
(2 -> 3) + ListMap(1 -> 2)
(2 -> 3) ++: ListMap(1 -> 2)
(2 -> 3) +: ListMap(1 -> 2).toList
sys.props("foo")
Some(2) collect { case x == 3 => x }
Some(2) collect { case x if x == 3 => x }
q""
exit
q""
val x = ValDef(NoMods, TermName("x"), Ident(TypeName("Int")), EmptyTree)
q"def foo($x)"
exit
q"def foo($x)"
q"{ $x }"
exit
Block(Literal(Constant(2))
)
exit
object 
)
object X { { val x = 2 } }
object X { { val x = 2 } println(x) }
object X { { val x = 2 }; println(x) }
object X { { val x = 2 } }
X.x
val _1 = 2
_1
s"${_}"
_
List("x") map (s"${_}")
exit
reify{List[String]()}
reify{List[String]("a")}
type X = Int
reify{List[X](2)}
exit
List(1) ++ List(2)
def foo e
class foo extends scala.annotation.StaticAnnotation
class C @foo (x: Int)
class foo extends scala.annotation.StaticAnnotation
def impl(c: Context) = c.universe.Ident(c.universe.TypeName("Int"))
@foo({def fooInAnn = macro Impls.foo; fooInAnn})
  def foo = println("it works")
class foo(val bar: Int) extends annotation.StaticAnnotation
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.TypeName("Int"))
@foo({ type Foo(x: Int) = macro Impls.foo; class D extends Foo(2); val x: Foo(2) = new D; x.x })
  def foo = println("it works")
@foo({ type Foo(x: Int) = macro impl; class D extends Foo(2); val x: Foo(2) = new D; x.x }) def foo = ???
class
C
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.TypeName("C"))
@foo({ type Foo(x: Int) = macro impl; class D extends Foo(2); val x: Foo(2) = new D; x.x }) def foo = println("it works")
{ class C; @foo({ type Foo(x: Int) = macro impl; class D extends Foo(2); val x: Foo(2) = new D; x.x }) def foo = println("it works") }
exit
q"class Foo extends ${tq"Bar"}"
q"class Foo extends ..${List(tq"Bar", tq"Baz")}"
val q"class Foo extends ..$parents" = res1
q"package foo"
val v = q"val x: Int"
q"def foo($v)"
val v: ValDef = q"val x: Int"
val v: Tree = q"val x: Int"
q"def foo($v)"
q"def foo(${TermName("x")})"
def impl(c: Contex
def impl(c: Context) = c.abort(c.enclosingPosition, "macro has reported an error")
def test = macro impl
test
val q"foo(...$argss)" = q"foo(2)(3)"
val name = newTermName("foo")
val name = TermName("foo")
val name = TypeName("C")
val q"class $name1" = q"class $name"
val args = List(Literal(Constant(2)))
val q"foo(..$args)" = q"foo(..$args)"
val q"foo(..$args1)" = q"foo(..$args)"
val q"foo(..$args1)" = q"foo($args)"
val argss = List(List(Literal(Constant(2))), List(Literal(Constant(3)))))
val argss = List(List(Literal(Constant(2))), List(Literal(Constant(3))))
val q"foo(..$argss1)" = q"foo(..$argss)"
val q"foo(...$argss1)" = q"foo(...$argss)"
q"foo(...$argss)
q"foo(...$argss)"
val argss = List(List(Literal(Constant(2))), List(Literal(Constant(3)))))
val argss = List(List(Literal(Constant(2))), List(Literal(Constant(3))))
q"foo(...$argss)"
val foo = TermName("foo")
q"$foo(...$argss)"
q"$foo()(...$argss)"
case class Foo[A <: TypeTag]
case class Foo[A: TypeTag]
case class Foo[A: TypeTag](xs: List[A])
"foo.bar".split(".")
"foo.bar".split("b")
"foo.bar".split(".")
"foo.bar".split(Pattern.quote("."))
"foo.bar".split(java.util.regex.Pattern.quote("."))
"foo".split(java.util.regex.Pattern.quote("."))
"".split(java.util.regex.Pattern.quote("."))
typeOf[List].typeSymbol.fullName
typeOf[List[_]].typeSymbol.name
typeOf[List[_]].typeSymbol.fullName
Select(Ident(TermName("foo")), TermName("bar"))
def 
))
def impl(c: Context)(x: c.Expr[String]) = x
def foo = macro impl
def foo(x: String) = macro impl
foo("""z""")
def impl(c: Context)(x: c.Expr[String]) = { println(showRaw(x)); x }
def foo(x: String) = macro impl
foo("""zzz""")
def impl(c: Context)(x: c.Expr[String]) = { println(showRaw(x.tree)); x }
def foo(x: String) = macro impl
foo("""zzz""")
foo(s"zzz")
def impl(c: Context)(x: c.Expr[String]) = { println(showRaw(x.tree)); println(c.eval(x)); x }
def foo(x: String) = macro impl
foo(s"zzz")
val ct = classTag[List[_]]
ct.unapply(List(2))
ct.unapply(Map(1 -> 2))
def impl(c: Conte
def impl(c: Context) = c.universe.Ident(c.universe.TypeName("C"))
type foo = macro impl
def impl(c: Context) = c.universe.Ident(c.universe.TypeName("C"))
type foo = macro impl
type X = foo
type Foo = impl2
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
def foo = 2
foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
q"x"
exit
q"x"
exit
typeTag[String]
showRaw(typeTag[String], printIds = true)
typeOf[ClassManifest].typeSymbol.annotations
typeOf[ClassManifest[_]].typeSymbol.annotations
cm.staticPackage("scala")
cm.staticPackage("scala").typeSignature.member(newTermName("package"))
res3.typeSignature.getMember(newTypeName("cloneable"))
res3.typeSignature.member(newTypeName("cloneable"))
res5.annotations
class C { def x = 2 }
cm.reflect(new C)
val cm = scala.reflect.runtime.currentMirror
cm.reflect(new C)
res1.reflectMethod(typeOf[C].member(newTermName("x")).asMethod)
res1.reflectMethod(scala.reflect.runtime.universe.typeOf[C].member(newTermName("x")).asMethod)
import scala.reflect.runtime.universe._
res1.reflectMethod(typeOf[C].member(newTermName("x")).asMethod)
res4.bind(new C)
res4()
res5()
class C { class D }
val c = new C
c.D
typeOf[c.D]
showRaw(typeOf[c.D])
{ val c = new C; showRaw(typeOf[c.D]) }
{ var c = new C; showRaw(typeOf[c.D]) }
trait TypezSig {
  case class Num(i:Int,f:Float)
  case class Mat(rows:Num,cols:Num)
  type Alphabet = Mat
  type Answer = (Num,Mat)
}
typeOf[TypezSig#Num]
trait TypezSig {
  case class Num(i:Int,f:Float)
  case class Mat(rows:Num,cols:Num)
  type Alphabet = Mat
  type Answer = (Num,Mat)
}
object Typez extends TypezSig {
  import scala.reflect.runtime.universe._
  import scala.reflect._
  def foo[Alphabet,Answer]()(implicit t1:TypeTag[Alphabet],t2:TypeTag[Answer],c1:ClassTag[Alphabet],c2:ClassTag[Answer],m1:Manifest[Alphabet],m2:Manifest[Answer]) {
  println(t1.tpe.toString+" --- "+c1.toString+" --- "+m1.toString)
  println(t2.tpe.toString+" --- "+c2.toString+" --- "+m2.toString)
  }
  foo[Alphabet,Answer]();
}
Typez
exit
val x = classTag[List[Int]]
val y: ClassTag[List[_]] = x
exit
{ def foo(x: Int) = x; def foo(x: Int*) = x }
class C{ def foo(x: Int) = x; def foo(x: Int*) = x }
new C().foo(1)
new C().foo(1, 2)
new C().foo()
typeOf[List[_]].typeSymbol.fullName
trait Foo[T]; object Foo { implicit object FooString extends Foo[String] }
def foo[T: Foo](x: T)
= ???
def foo[T: Foo](x: T) = x
foo(1)
foo("1")
class Qwe { trait Foo[T]; object Foo { implicit object FooString extends Foo[String] } }
class Qwe { trait Foo[T]; object Foo { implicit object FooString extends Foo[String] }; def foo[T: Foo](x: T) = x }
new Qwe().foo(1)
new Qwe().foo("1")
val qwe = new Qwe()
qwe.foo(1)
qwe.foo("1")
exit
{ class C; weakTypeOf[C] }
cm.runtimeClass(res0)
showRaw(res0)
showRaw(res0, printIds = true, printKinds = true)
classOf[List[_]].getName
typeOf[List[_]].typeSymbol.typeSignature
typeOf[List[_]].typeSymbol.typeParams
typeOf[List[_]].typeSymbol.asClass.typeParams
exit
locally { class E; manifest[E] }
exit
  def _seq = _op(";")_
def _op (opSymbol: String)(children: Int*)  = {}
  def _seq = _op(";")_
null eq null
exit
val q"x" = Ident(TermName("x"))
val q"$x" = Ident(TermName("x"))
1 to 5
1 to 5 map (_)
1 to 5 map (x => x)
q"x"
def impl(c: Context) = { import c.universe._; println(showRaw(c.macroApplication, printPositions = true); c.literalUnit
def impl(c: Context) = { import c.universe._; println(showRaw(c.macroApplication, printPositions = true); c.literalUnit }
def impl(c: Context) = { import c.universe._; println(showRaw(c.macroApplication, printPositions = true)); c.literalUnit }
import scala.reflect.macros.Context
def impl(c: Context) = { import c.universe._; println(showRaw(c.macroApplication, printPositions = true)); c.literalUnit }
def foo = macro impl
foo
case class C(x: Int)
typeOf[X].fields
typeOf[X].declarations
typeOf[C].declarations
typeOf[C].declarations.filter(_.isCaseAccessor)
typeOf[C].declarations.collect{ case x: TermSymbol if x.isCaseAccessor => x }
typeOf[C].declarations.collect{ case x: TermSymbol if x.isParamAccessor => x }
typeOf[C].declarations.collect{ case x: TermSymbol if x.isValue && x.isCaseAccessor => x }
typeOf[C].declarations.collect{ case x: TermSymbol if x.isVal && x.isCaseAccessor => x }
exit
cl
class C { def foo[T]: T = ??? }
val sym = typeOf[C].declaration(TermName("foo")).asMethod
sym.typeSignature
def impl[A](c: reflect.makro.Context) = c.reify(())
def impl[A](c: reflect.macros.Context) = c.reify(())
def impl[A](c: reflect.macros.Context) = c.universe.reify(())
def decl[A] = macro impl[A]
decl
def impl[A](c: reflect.macros.Context) = c.universe.reify(())
def decl[A] = macro impl[A]
decl
object impl { def apply = "" }
impl
impl()
object M { def apply[T, U](x: Int) = ??? }
M[Int, Int]
object M { def apply[T, U] = ??? }
M[Int, Int]
def impl(c: Context): Unit = c.enclosingMethod match {
case DefDef(_, name, _, _, _, _) => c.universe.reify(println(c.literal(name.toString).splice))
case _ => c.abort(c.enclosingPosition, "no enclosing method")
}
def impl(c: Context): Unit = {
import c.universe._
c.enclosingMethod match {
case DefDef(_, name, _, _, _, _) => c.universe.reify(println(c.literal(name.toString).splice))
case _ => c.abort(c.enclosingPosition, "no enclosing method")
}
def printEnclosingMethod = macro impl
def impl(c: Context) = {
import c.universe._
c.enclosingMethod match {
case DefDef(_, name, _, _, _, _) => c.universe.reify(println(c.literal(name.toString).splice))
case _ => c.abort(c.enclosingPosition, "no enclosing method")
}
def printEnclosingMethod = macro impl
def foo = printEnclosingMethod
foo
printEnclosingMethod
exit
import scala.reflect.runtime.{universe => ru}
trait X { def foo: String }
ru.typeOf[X]
res0.members
res0.members.sorted
def foo[T](x: T) = x.getClass
foo(List(1, 2, 3))
def foo[T: ru.TypeTag](x: T) = ru.typeOf[T]
foo(List(1, 2, 3))
ru.showRaw(res4)
import scala.reflect.runtime.universe._
import scala.tools.reflect.ToolBox
val tree = Apply(Select(Literal(Constant(40)),
    newTermName("$plus")), List(Literal(Constant(2))))
val cm = ru.runtimeMirror(getClass.getClassLoader)
println(cm.mkToolBox().eval(tree))
def impl(c: Context) = { c.error(c.enclosingPosition, "foo"); c.error(c.enclosingPosition, "bar"); c.literalUnit }
def foo = macro impl
foo
def impl(c: Context) = { c.warning(c.enclosingPosition, "foo"); c.warning(c.enclosingPosition, "bar"); c.literalUnit }
def foo = macro impl
foo
def impl(c: Context) = { c.error(c.enclosingPosition, "foo"); c.warning(c.enclosingPosition, "bar"); c.literalUnit }
def foo = macro impl
foo
if (false) Array("qwe") else Array[Nothing]()
class C(val x: Int) extends AnyVal
class D { val c = new C(2) }
reify(Nil: _*)
exit
List(1) match { case _ :: Nil => }
List(1, 2) match { case _ :: Nil => }
List() match { case _ :: Nil => }
List(1, 2) match { case _ +: Nil => }
List(1, 2) match { case _ ::: Nil => }
List(1, 2) match { case _ :+ Nil => }
List(1, 2) match { case _ :+ _ => }
List(1) match { case _ :+ _ => }
List() match { case _ :+ _ => }
List() match { case _ :: _ => }
List(1) match { case _ :: _ => }
List(1, 2) match { case _ :: _ => }
List(1, 2) match { case _ :+ superCall => }
List(1) match { case _ :+ superCall => }
List() match { case _ :+ superCall => }
class C @ann (x: Int)
class C @ann() (x: Int)
class C { class I }
def foo(c: C) = new c.I()
def foo(c: => C) = new c.I()
class A
(ru: scala.reflect.api.Universe).typeOf[A]
ru.typeOf[A]
(ru: scala.reflect.api.Universe).typeTag[A]
(ru: scala.reflect.api.Universe).weakTypeTag[A]
Some(null)
Option(null)
Option(2)
Option(null)
Some(null)
Option(None)
xit
exit
val list = (1 to 10000).toList
    list.par.map(_ + 42)
exit
0 until 5
exit
-1 % 8
1 to 5
1.5.asInstanceOf[Int]
List.range(0, 10)
1.5.asInstanceOf[Int]
0.9.toInt
0 to 1
0 to 15
-(-1 % 8)
class C { def foo(x: Int)(y: Int) = 2 }
typeOf[C].member(TermName("foo")).typeSignature
res0.paramss
typeOf[C].member(TermName("foo")).asMethodSymbol
typeOf[C].member(TermName("foo")).asMethod
res3.paramss
res3.returnType
res3.paramss.tail.foldLeft(MethodType(res3.paramss.head, res3.returnType), (MethodType(_, _)))
res3.paramss.tail.foldLeft(MethodType(res3.paramss.head, res3.returnType))((MethodType(_, _)))
res3.paramss.tail.foldLeft(MethodType(res3.paramss.head, res3.returnType))((acc, params) => MethodType(params, acc))
class C { def foo(x: Int)(y: Int) = 2 }
class C { def foo(x: Int)(y: Int)(z: Int) = 2 }
typeOf[C].member(TermName("foo")).asMethod
val paramss = res9.paramss
val implReturnType = res9.returnType
paramss.tail.foldLeft(MethodType(paramss.head, implReturnType))((acc, params) => MethodType(params, acc))
paramss.init.foldLeft(MethodType(paramss.last, implReturnType))((acc, params) => MethodType(params, acc))
paramss.init.foldRight(MethodType(paramss.last, implReturnType))((acc, params) => MethodType(params, acc))
paramss.init.foldRight(MethodType(paramss.last, implReturnType))((acc, params) => MethodType(acc, params))
paramss.init.foldRight(MethodType(paramss.head, implReturnType))(MethodType(_, _))
res14.asInstanceOf[scala.reflect.internal.Types#Type]
res15.paramss
res15.finalResultType
res15.typeParams
exit
def StringContext(parts: String*) = ???
s"a"
def impl(c: scala..macros.Context) = ???
def impl(c: scala.reflect.macros.Context) = ???
def foo(x: Int) = 2
def foo(x: _) = 2
def impl(c: scala.reflect.macros.Context)(x: c.Tree) = ???
class C { def m(x: _): _ = macro impl }
def impl(c: Context)(x: c.Expr[Int]) = ???
def foo(x: Int = 2) = macro impl
1 match { case 1 | 2 => }
1 match { case 3 | 2 => }
List(1) match { case List(1 | 2) => }
zip(List(1, 2), List(1, 2, 3))
List(1, 2).zip(List(1, 2, 3))
List(1, 2) exists { case 1 => true }
List(1, 2) collect { case 1 => -1; case 3 => -2 }
List(1, 2, 3).init
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = x
def foo(x: Int)(y: Int) = macro impl
foo(2)(3)
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = x
def foo(x: Int)(y: Int) = macro impl
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = x
def foo(x: Int)(y: Int) = macro impl
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = x
def foo(x: Int)(y: Int) = macro impl
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = x
def foo(x: Int)(y: Int) = macro impl
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = x
def foo(x: Int)(y: Int) = macro impl
def impl(c: Context): c.Tree = ???
def foo: Int = macro impl
def impl(c: Context): c.Tree = ???
def foo: Int = macro impl
def foo(x: => Any) = ???
def foo[M[_]] = ()
foo[List]
foo[List[T] forSome { type T }]
val x: List[T] forSome { type T } = List(1, 2)
x ++ 3
x :+ 3
List(1, 2) splitAt -1
List() :+ List(1, 2)
if true Nil else List(1) ++ List(2)
if (true) Nil else List(1) ++ List(2)
2 min 3
min(2, 3)
import Math.min
min(2, 3)
java.lang.Math
scala.Math
java.lang.Math
import java.lang.Math.min
def foo(x: Int*) = x
foo(2, 3, 4)
"(Found in|and)".r.replaceAllIn("Found in", m => m.group(1))
"(Found in|and)".r.replaceAllIn("Foundn", m => m.group(1))
"(Found in|and)".r.replaceAllIn("Foundn", m => m.group(0))
"(Found in|and)".r.replaceAllIn("Foundn", m => m.group(2))
"(Found in|and)".r.replaceAllIn("Foundn", m => m.group)
"(Found in|and)".r.replaceAllIn("Foundn", m => m.groupCount)
"(Found in|and)".r.replaceAllIn("Foundn", m => m.groupCount.toString)
"(Found in|and)".r.replaceAllIn("and", m => m.groupCount.toString)
"(Found in|and)".r.replaceAllIn("and", m => m.group(0))
"(Found in|and)".r.replaceAllIn("and", m => m.group(1))
"(Found in|and)".r.replaceAllIn("and", m => m.group(3))
class C { def foo(x: Int*) = ??? }
typeOf[C].member(TermName("foo")).typeSignature
showRaw(res0)
class C { def m(x: _): _ = macro impl }
import scala.reflect.runtime.universe._
val m = typeOf[C].member(newTermName("m")).asMethod
m.params(0)(0).typeSignature
m.paramss(0)(0).typeSignature
showRaw(m.paramss(0)(0).typeSignature)
def impl(c: Context)(x: c.Tree): c.Tree = ???
def foo(x: _) = macro impl
foo(2)(3)
foo
def impl(c: Context)(x: c.Tree): c.Tree = ???
def foo(x: _) = macro impl
foo(2)(3)
foo
def impl(c: Context)(x: c.Tree): c.Tree = ???
def foo(x: _) = macro impl
foo(2)(3)
foo(2)
foo
def impl(c: Context)(x: c.Tree): c.Tree = ???
def foo(x: Int) = macro impl
foo
foo(2)(3)
def impl(c: Context)(x: c.Tree): c.Tree = c.literal(2)
def impl(c: Context)(x: c.Tree): c.Tree = c.literal(2).tree
def foo(x: Int) = macro impl
foo(2) + foo(3)
def foo(x: Int): Int = macro impl
foo(2)(3)
def impl(c: Context)(x: c.Tree): c.Tree = c.literal(2).tree
def foo(x: Int) = macro impl
foo(2)(3)
def impl(c: Context)(x: c.Tree): c.Tree = c.literal(2).tree
def foo(x: Int) = macro impl
foo(2)(3)
def impl(c: Context)(x: c.Tree): c.Tree = c.literal(2).tree; def foo(x: Int) = macro impl; foo(2)(3)
val cm = universe.runtimeMirror(getClass.getClassLoader)
import scala.tools.reflect.ToolBox
val tb = cm.mkToolBox()
tb.eval(tb.parse("class C; new D"))
tb.frontEnd.infos
case class Country(id: String, name: String) extends Domain
case class Country(id: String, name: String)
typeOf[Country].declarations
typeOf[Country].declarations.collect{ case sym if sym.isVal => sym.asTerm }
typeOf[Country].declarations.collect{ case sym if sym.Term => sym.asTerm }.filter(_.isVal)
typeOf[Country].declarations.collect{ case sym if sym.isTerm => sym.asTerm }.filter(_.isVal)
typeOf[Country].declarations.toList.collect{ case sym if sym.isTerm => sym.asTerm }.filter(_.isVal)
typeOf[Country].declarations.toList.collect{ case sym if sym.isTerm => sym.asTerm }.filter(_.isParamAccessor)
typeOf[Country].declarations.toList.collect{ case sym if sym.isTerm => sym.asTerm }.filter(sym => sym.isVal && sym.ParamAccessor)
typeOf[Country].declarations.toList.collect{ case sym if sym.isTerm => sym.asTerm }.filter(sym => sym.isVal && sym.isParamAccessor)
def impl(c: Context)(x: c.universe.Ident) = ???
def foo(x: _) = macro impl
def foo = macro impl
exit
def foo = macro impl
impl
impl2
def foo = macro impl1
def foo(x) = x
def impl[A](c: reflect.makro.Context) = c.reify(())
def impl[A](c: Context) = c.reify(())
def impl[A](c: Context) = c.literalUnit
def decl[A] = macro impl[A
]
decl[Any]
decl
exit
def foo = macro impl1
foo
exit
lazy List(x, y) = List(1, 2)
lazy val List(x, y) = List(1, 2)
:power
ScalaPackage
ScalaPackageClass
ScalaPackageClass.isModuleClass
ScalaPackageClass.isModule
ScalaPackage.isModule
ScalaPackage.sourceModule
ScalaPackageClass.sourceModule
class C {
lazy val list = List(1, 2)
lazy val List(x, y) = list
}
class C {
private lazy val list = List(1, 2)
lazy val List(x, y) = list
}
def foo = macro impl1
{ class anon { def x = 2 }; new anon }
{ final class anon { def x = 2 }; new anon }
scala.reflect.runtime.universe
res0.asInstanceOf[scala.reflect.internal.SymbolTable]
res1.phase
:power
typer
typer.typedType(EmptyTree)
def foo = macro impl
def foo = macro impl1
foo
class C { def foo(x) = 2 }
class C { def foo(x: Int) = 2 }
new C().foo
def foo = macro impl
def foo = macro impl1
foo
:power
PredefModule.moduleClass
PredefModule.moduleClass.moduleClass
exit
typeOf[java.io.File].declarations.foreach(sym => println(s"$sym, ${sym.privateWithin}"))
class C
classOf[C].getName
typeOf[Int]
class C { def foo: List[Tuple2[Set[Int],Int]] = ??? }
typeOf[C].member(TermName("foo")).typeSignature
Map(1, 2).get(3)
Map(1 -> 2).get(3)
Map(1 -> 2)(3)
List(1, 2) - 1
reify(2)
def foo(x: Int) = x
foo _
def foo(x: Int = 2) = x
foo _
res1
res1()
null.isInstanceOf[Int]
trait Monoid { def neutral: this.type }
class Nat extends Monoid { def neutral = new Nat() }
trait Printable { def print: String }
trait Showable[T] { def show: String }
def show[T: Showable](x: T) = implicitly[Showable[T]].show(x)
trait Showable[T] { def show(x: T): String }
def show[T: Showable](x: T) = implicitly[Showable[T]].show(x)
object IntShowable { def show(x: Int) = x.toString }
show(2)
trait Showable[T] { def show(x: T): String }
def show[T: Showable](x: T) = implicitly[Showable[T]].show(x)
implicit object IntShowable { def show(x: Int) = x.toString }
show("2")
show(2)
trait Showable[T] { def show(x: T): String }
def show[T: Showable](x: T) = implicitly[Showable[T]].show(x)
implicit object IntShowable extends Showable[Int] { def show(x: Int) = x.toString }
show("2")
show(2)
String.concat
String.+
"".concat
class Foo { lazy val x = 2 }
class Bar extends Foo { override lazy val x = 3 }
new Bar().x
class Foo { lazy val x = 2 }
class Bar extends Foo { override lazy val x = 3 }
new Bar().x
class Bar extends Foo { override lazy val x = super.x + 1 }
System.currentTimeMillis
Map(1, 2) map { case (k, v) => (k, v) }
Map(1 -> 2) map { case (k, v) => (k, v) }
exit
clojure.lang.RT.T
import reflect.macros.Context
def foo_impl(c :Context): c.Expr[Any] = { import c.universe._; println(clojure.lang.RT.T); reify("foo") }
def foo = macro foo_impl
import language.experimental.macros
def foo = macro foo_impl
foo
exit
import language.experimental.macros
def foo_impl(c :Context): c.Expr[Any] = { import c.universe._; println(clojure.lang.RT.T); reify("foo") }
import reflect.macros.Context
def foo_impl(c :Context): c.Expr[Any] = { import c.universe._; println(clojure.lang.RT.T); reify("foo") }
def foo = macro foo_impl
foo
def foo_impl(c :Context): c.Expr[Any] = { import c.universe._; c.literalUnit }
Macros.foo
class C[T, M[_]]
val c = typeOf[C].typeSymbol
val c = typeOf[C[_]].typeSymbol
val c = typeOf[C[_, _]].typeSymbol
val c = typeOf[C[_, _[_]]].typeSymbol
val c = typeOf[C[_, List]].typeSymbol
c.info
c.tpe
c.tpe_*
c.tpeHK
{ import List._; }
(1 to 5).product
exit
class C { class D }
1 to 4
class C { object X }
class D extends C { override object X }
class C { object X { def x = 2 } }
class D extends C { override object X { override def x = 3 } }
class D extends C { override object X { def x = 3 } }
new C().X.x
new D().X.x
val x: C = new D()
x.X.x
typeOf[String]
:power
JavaLangPackage
JavaLangPackage.fullName
tb.eval(reify(2))
tb.eval(reify(2).tree)
reify(2).eval
new Any
new Any{}
new Any(){}
new AnyVal
new AnyVal{}
new Any
new Any{}
new AnyVal
new AnyVal{}
typeOf[String]
grh0
2
scala.reflect.runtime.universe
2
{ type T; }
List(1, 2) match { case _ :+ x => println(x) }
ScalaPackageClass.info.decls
ScalaPackageClass.typeSignature.declarations
ScalaPackageClass.typeSignature.declarations foreach println
mirror.reflect("hello").symbol
cm.reflect("hello").symbol
typeOf[String]
class C { def foo(x: Int) = println(2) }
trait X { def foo(x: Int) = println(3) }
class D extends C with X
trait X { override def foo(x: Int) = println(3) }
trait X extends C { override def foo(x: Int) = println(3) }
class D extends C with X
new D().foo
new D().foo(2)
class C { def foo = println(2) }
class D extends C { override def foo = println(3) }
trait X extends C { override def foo = println(100500) }
class C1 extends C with X
new C1().foo
class D1 extends D with X
new D1().foo
cm.staticClass("scala.reflect.runtime.JavaMirrors")
res0.isInitialized
res0.asInstanceOf[scala.reflect.internal.Symbols#Symbol]
res0.asInstanceOf[scala.reflect.internal.Symbols#Symbol].isInitialized
res0.associatedFIle
res0.associatedFile
exit 
false && 22 
false && 2 == 2
trait Foo extends Macro
trait Foo extends scala.reflect.Macros.Macro 
trait Foo extends scala.reflect.macros.Macro 
trait Foo extends scala.reflect.macros.Macro { 
class C
class D { self: C => }
List(2, 1).sorted
class C(val x: Int) extends AnyVal
typeOf[C].declarations
typeOf[C].declarations.collect{ case ts: TermSymbol if ts.isParamAccessor => ts }
typeOf[C].declarations.collect{ case ts: TermSymbol if ts.isParamAccessor && ts.isVal => ts }
typeOf[C].declarations.collect{ case ts: TermSymbol if ts.isParamAccessor && ts.isMethod => ts }
res4.toList(0)
res5.name
res5.name.length
res5.name.toString.length
class C { def foo(xs: Int*) = println(xs) }
cm.reflect(new C)
res0.reflectMethod(typeOf[C].declaration(newTermName("foo")))
res0.reflectMethod(typeOf[C].declaration(newTermName("foo")).asMethod)
res2(1)
class C { def foo(xs: String*) = println(xs) }
cm.reflect(new C)
res0.reflectMethod(typeOf[C].declaration(newTermName("foo")).asMethod)
res4.reflectMethod(typeOf[C].declaration(newTermName("foo")).asMethod)
res4("a")
res6("a")
class C { def fooi1(x: Int, xs: Int*) = (x, xs) }
classOf[C].getDeclaredMethod("fooi1")
classOf[C].getMethods()
classOf[C].getMethods().first
classOf[C].getMethods().toList.head
res3.invoke(new C, 1, 2)
res3.invoke(new C, 1.asInstanceOf[Any], 2.asInstanceOf[Any])
res3.invoke(new C, 1.asInstanceOf[AnyRef], 2.asInstanceOf[AnyRef])
class C { def fooi1(x: String, xs: String*) = (x, xs) }
classOf[C].getMethods().toList.head
res3.invoke(new C, "x", "y")
res7.invoke(new C, "x", "y")
res7.invoke(new C, "x", "y", "z")
class C { def foo(x: String, xs: String*) = (x, xs) }
val foo = classOf[C].getMethods().toList.head
foo.invoke(new C, "1", "2")
typeOf[java.lang.reflect.Method]
typeOf[java.lang.reflect.Method].declaration(newTermName("invoke"))
cm.reflect(foo)
res14.reflectMethod(res13.asMethod)
res15(new C, "1")
class C { def foo(x: String) = (x) }
val foo = classOf[C].getMethods().toList.head
foo.invoke(new C, "1"))
foo.invoke(new C, "1")
val invoke = typeOf[java.lang.reflect.Method].declaration(newTermName("invoke"))
cm.reflect(foo).reflectMethod(invoke.asMethod)(new C, "1")
classOf[java.lang.Method].getMethods
classOf[java.lang.reflect.Method].getMethods
classOf[java.lang.reflect.Method].getMethods.toList.head
val invoke = classOf[java.lang.reflect.Method].getMethods.toList.head
invoke.invoke(foo, new C, "1")
class C { def foo = 1 }
classOf[C].getMethods.head
res0.invoke(new C, 1)
res0.invoke(new C, "1")
List.fill(0)(1)
typeOf[List[Int]]
exit
typeOf[List[Int]]
{ class C { def x = 2 }; typeOf[C] }
{ class C { def x = 2 }; weakTypeOf[C] }
typeOf[String]
List(1, 2, 3, 4).permutations
List(1, 2, 3, 4).permutations.toList
typeOf[String]
typeOf[scala.reflect.api.TypeTags].typeSymbol
res0.thisSym
res0.thisPrefix
res0.asClass.selfType
typeOf[List[T] forSome { type T }]
typeOf[List[Any]]
res0 <:< res1
res0 <:< res0
res1 <:< res0
typeOf[List[Any]] <:< typeOf[List[T] forSome { type T }]
val lany = typeOf[List[Any]]
val lt = typeOf[List[T] forSome { type T }]
lany <:< lt
val lany = typeOf[List[Any]]
val lt = typeOf[List[T] forSome { type T }]
lany <:< lt
val lany = typeOf[List[Any]]
val lt = typeOf[List[T] forSome { type T }]
lany <:< lt
typeOf[Types].declarations.sorted foreach println
typeOf[scala.reflect.internal.Types].declarations.sorted foreach println
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(_.isValue).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(_.isVal).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(_.isVal).filter(!_.name.toString.contains("TypeTag")).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(_.isVal).filter(!_.name.toString.endsWith("Tag")).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(_.isVal).filter(!_.name.toString.strip.endsWith("Tag")).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(_.isVal).filter(!_.name.toString.trim.endsWith("Tag")).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(sym => sym.isVal || sym.isVar).filter(!_.name.toString.trim.endsWith("Tag")).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(sym => sym.isVal || sym.isVar || sym.isLazy).filter(!_.name.toString.trim.endsWith("Tag")).foreach(println)
new ThreadLocal[Int]()
new ThreadLocal(1)
class C { def foo(x: Int) = x }
classOf[C].getDeclaredMethod("foo", classOf[Int])
res0.invoke(new C, null)
class C { def foo[T](x: T, y: T) = () }
cm.reflect(new C).reflectMethod(typeOf[C].declaration(newTermName("foo")).asMethod)
res0(1, "1")
class C { def foo[T](x: T, y: T) = () }
class C { def foo[T <: U](x: T, y: U) = () }
class C { def foo[T, U <: T](x: T, y: U) = () }
cm.reflect(new C).reflectMethod(typeOf[C].declaration(newTermName("foo")).asMethod)
class C { def foo[T <: Int, U <: T](x: T, y: U) = () }
cm.reflect(new C).reflectMethod(typeOf[C].declaration(newTermName("foo")).asMethod)
res3(1, "1")
scala.collection.mutable.ArrayBuffer[Int](1, 2)
typeOf[Int]
typeOf[String]
case class Shop(store: String, item: String, cost: Int) { def this() = this(null, null, 0) }
val t = typeOf[Shop]
val m = runtimeMirror(getClass.getClassLoader)
val cls = t.typeSymbol.asClass
val cm = m.reflectClass(cls)
val alts = t.declaration(nme.CONSTRUCTOR).asTerm.alternatives
val noargCtor = alts.collect{ case ms: MethodSymbol if ms.paramss => ms }.head
val noargCtor = alts.collect{ case ms: MethodSymbol if ms.paramss == List() => ms }.head
val noargCtor = alts.collect{ case ms: MethodSymbol if ms.paramss == List(List()) => ms }.head
cm.reflectConstructor(noargCtor)()
import scala.reflect.runtime.universe._
trait Foo
object Bar {
  def apply[A]()(implicit tpe: TypeTag[A]): Bar[A] = ???
}
trait Bar[A]
class test {
  type A = Foo
  implicit val foo = typeOf[A]
  def test = Bar[A]()                                                 
}
newTermName("Test") eq newTermName("Test")
newTermName("Test") == newTermName("Test")
case class Foo(a: Int, b: Int); object Foo { def apply(a: Int) = Foo(a, 0) }
case class Foo(a: Int, b: Int); object Foo { def apply(a: Int): Foo = Foo(a, 0) }
abstract class Applyable[T] { def apply(a: Int): T = apply(a, 0); def apply(a: Int, b: Int): T }
case class Foo(a: Int, b: Int); object Foo extends Applyable[Foo]
def foo(implicit i: Int) = i
foo
object M { def foo = 2 }
typeOf[M].declaration(newTermName("foo"))
typeOf[M.type].declaration(newTermName("foo"))
res1.owner
res1.owner.asModule
object C
:javap -v C
class C1 { object D }
:javap C1
:javap -v -p C1
class Foo(x: => Int)
import scala.reflect.runtime.{universe => ru}
reify(ru).eval
typeOf[String]
class C
typeOf[C]
class C { def c: C = this }
typeOf[C]
abstract class PrimitiveTC[X:TypeTag]
{ def is[T:TypeTag]: Boolean = typeOf[X] <:< typeOf[T] } 
abstract class PrimitiveTC[X:TypeTag] {
   def is[T:TypeTag]: Boolean = typeOf[X] <:< typeOf[T]
}
object StringTypeTag extends PrimitiveTC[String]
StringTypeTag
class A[X](implicit val tt: TypeTag[X]) {println(tt)}
object Obj { val x = { object InVal extends A[String]; InVal; 5 } }
Obj
exit
scala.reflect.runtime.universe.forInteractive
"1\n2".split("\n")
"1\n2".split("\n").map("  " + _)
"1\n2".split("\n").map("  " + _).mkString
"1\n2".split("\n").map("  " + _).mkString("\n")
"1".split("\n")
" ".strip
" ".trim
" ".trimLeft
def impl(c: Context)(x: c.Expr[Int]) = c.Ident(TypeName("C"))
def impl(c: Context)(x: c.Expr[Int]) = { import c.universe._; Ident(TypeName("C")) }
class C
type TM(x: Int) = macro impl
class C extends AnyRef with TM(2)
class D extends AnyRef with TM(2)
trait C
def tm(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = c.universe.Ident(c.universe.TypeName("C"))
def tm(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = c.universe.Ident(c.weakTypeOf[C].typeSymbol)
type TM(x: Int)(y: Int) = macro Impls.tm
type TM(x: Int)(y: Int) = macro tm
trait X extends TM(2)(3)
reify{ new Object().getClass }
reify(manifest[Some[_]])
reify{ new Object().getClass }
reify(manifest[Some[_]])
Thread.currentThread().getContextClassLoader
res0.getClass.getFields
res1.length
val outerField = res0.getClass.getFields.head
outerField.setAccessible(true)
outerField.get(res0)
res4.asInstanceOf[IMain].definedSymbolList
res4.asInstanceOf[scala.tools.nsc.interpreter.IMain].definedSymbolList
res4.asInstanceOf[scala.tools.nsc.interpreter.IMain].importHandlers
val x = res4.asInstanceOf[scala.tools.nsc.interpreter.IMain]
x.definedSymbolList
val replClassloader = Thread.currentThread().getContextClassLoader
val outerField = replClassloader.getClass.getFields.head
val interpreter = outerField.get(replClassloader).asInstanceOf[scala.tools.nsc.interpreter.IMain]
interpreter.definedSymbols
interpreter.definedSymbolList
trait Foo[A] { def m[B >: A](x: B): B }
val t = weakTypeOf[Foo[Int]]
val m = t.member(newTermName("m")).asMethod
val mt = m.typeSignatureIn(t)
val TypeBounds(lo, hi) = m.typeParams.head.typeSignatureIn(t)
showRaw(mt)
case class Foo(x: Int)
trait X
new { val x = 2 } with X
trait X extends { val x = 2 } with AnyRef
trait X extends { val x = 2 }
exit
def foo: List[T] = Nil
def foo[T]: List[T] = Nil
foo
def foo[T]: Comparator[T] = Nil
def foo[T]: Comparable[T] = Nil
def foo[T]: Comparable[T] = ???
foo
def foo[T]: Comparable[T] = null
foo
def foo[T]: List[T] = null
foo
def bar[T]: Comparable[T] = null
bar
class C[+T]
def foo[T]: C[T] = null
class D[-T]
def bar[T]: D[T] = null
bar
typeOf[List[Int]]
typeOf[Int]
typeOf[String]
typeOf[T forSome { type T <: Int }]
typeOf[{def x: Int; type T <: Int}]
val x = 5
val replClassloader = Thread.currentThread().getContextClassLoader
val outerField = replClassloader.getClass.getFields.head
val interpreter = outerField.get(replClassloader).asInstanceOf[scala.tools.nsc.interpreter.IMain]
interpreter.definedSymbolList
res0(0)
res0(0).fullName
res0(0).fullNameString
res0.owner
res2.owner
res1.owner
res1.owner.owner
res1.owner.owner.owner
.owner
val x = 2
x
val x = 2
val y = x
interpreter.originalPath
interpreter.fullPath
interpreter.global
interpreter.global.exitingTyper
interpreter.global.exitingPhase
interpreter.global.afterPhase
interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)
interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)(res1.fullName)
interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)(res1.fullNameString)
res1.javaClassName
interpreter.handlers
interpreter.prevRequests
interpreter.prevRequestList
interpreter.prevRequestList.takeRight(5)
interpreter.allHandlers
interpreter.allHandlers.takeRight(10)
interpreter.allHandlers foreach println
interpreter.allHandlers.reverse(10)
res27.definesTerm
interpreter.prevRequestList.takeRight(5)
val replClassloader = Thread.currentThread().getContextClassLoader
val outerField = replClassloader.getClass.getFields.head
val interpreter = outerField.get(replClassloader).asInstanceOf[scala.tools.nsc.interpreter.IMain]
val handlers = interpreter.prevRequestList
val reqs = interpreter.prevRequestList
reqs.flatMap(_.definedNames)
val replClassloader = Thread.currentThread().getContextClassLoader
val outerField = replClassloader.getClass.getFields.head
val replClassloader = Thread.currentThread().getContextClassLoader
val interpreter = outerField.get(replClassloader).asInstanceOf[scala.tools.nsc.interpreter.IMain]
val reqs = interpreter.prevRequestList
reqs.flatMap(_.definedNames.asInstanceOf[List[Any]])
val replClassloader = Thread.currentThread().getContextClassLoader
val outerField = replClassloader.getClass.getFields.head
val interpreter = outerField.get(replClassloader).asInstanceOf[scala.tools.nsc.interpreter.IMain]
val reqs = interpreter.prevRequestList
val fullPaths = reqs.flatMap(req => req.definedNames.map(name => req.fullPath(name)))
reqs(0)
res2.definedNames
res1.definedNames.asInstanceOf[Any]
res1.definedNames.asInstanceOf[List[_]]
res1.definedNames.map(_.toString)
res1.fullPath(res4(0))
res1.line
res1.lineRep
res1.lineRep.readPath
res1.accessPath
val fullPaths = reqs.flatMap(req => req.definedNames.map(name => s"${req.lineRep.readPath}${req.accessPath}.`$name`"))
reqs(0).lineRep
reqs(0).lineRep.readPath
reqs(0).definedName
reqs(0).definedNames
reqs(0).definedNames.asInstanceOf[Any]
interpreter
val fullPaths = reqs.map(req => req.lineRep.readPath)
val fullPaths = reqs.flatMap(req => req.definedNames.map(name => s"${req.lineRep.readPath}${req.accessPath}.`$name`"))
val fullPaths = reqs.flatMap(req => req.definedNames.map(name => req.lineRep.readPath))
val fullPaths = reqs.flatMap(req => req.definedNames.map(name => req.lineRep.readPath + req.accessPath))
val readPaths = reqs.flatMap(req => req.definedNames.map(_ => req.lineRep.readPath))
val accessPaths = reqs.flatMap(req => req.definedNames.map(_ => req.accessPath))
val names = reqs.flatMap(req => req.definedNames.map(name => "." + name.toString))
def mineInfoFromReqs(fn: (interpreter.Request, String) => String): List[String] = ???
def mineInfoFromReqs(fn: (interpreter.Request, String) => String): List[String] = reqs.flatMap(req => req.definedNames.map(name => fn(req, name)))
def mineInfoFromReqs(fn: (interpreter.Request, String) => String): List[String] = reqs.flatMap(req => req.definedNames.map(name => fn(req, name.toString)))
def getInfoFromReqs(fn: (interpreter.Request, String) => String): List[String] = reqs.flatMap(req => req.definedNames.map(name => fn(req, name.toString)))
def mapDefinedNames[T](fn: (interpreter.Request, String) => T): List[T] = reqs.flatMap(req => req.definedNames.map(name => fn(req, name.toString)))
val fullPaths = mapDefinedNames((_, _) => "")
val fullPaths = ListBuffer(mapDefinedNames((_, _) => ""))
val fullPaths = scala.collection.mutable.ListBuffer(mapDefinedNames((_, _) => ""))
val fullPaths = scala.collection.mutable.ListBuffer[String]() ++ mapDefinedNames((_, _) => "")
def mapDefinedNames[T](fn: (interpreter.Request, String) => T): List[T] = reqs.flatMap(req => req.definedNames.map(name => fn(req, name.toString)))
val parts = List(mapDefinedNames((req, _) => req.lineRep.readPath), mapDefinedNames((req, _) => req.accessPath), mapDefinedNames((_, name) => "." + name))
parts.transpose.map(_.mkString)
parts.transpose
List("1", "2").mkString
parts.transpose(0).mkString
res7(0).mkString
res7(0)
res7(1)
res7(2)
res7(0)(0)
res7(0)(1)
res7(0)(2)
res7(0)(0) + res7(0)(1) + res7(0)(2)
(res7(0)(0) + res7(0)(1) + res7(0)(2)).length
println(res7(0)(0) + res7(0)(1) + res7(0)(2))
val replClassloader = Thread.currentThread().getContextClassLoader
val outerField = replClassloader.getClass.getFields.head
val interpreter = outerField.get(replClassloader).asInstanceOf[scala.tools.nsc.interpreter.IMain]
interpreter.definedSymbolList
interpreter.definedSymbolList foreach (sym => println(sym.fullNameString))
interpreter.definedSymbolList foreach (sym => println(interpreter.global.afterPhase(interpreter.global.typerPhase)(sym.fullNameString))
)
interpreter.definedSymbolList foreach (sym => println(interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)(sym.fullNameString)))
interpreter.definedSymbolList foreach (sym => println(interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)(sym.fullName)))
interpreter.definedSymbolList foreach (sym => interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)(sym.fullName))
"$line2.$read"
"$line2.$read" + ".$iw"
"$line2.$read" + ".$iw.$iw"
"$line2.$read" + ".$iw.$iw.cm"
interpreter.definedSymbolList map (sym => interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)(sym.fullName))
def impl(c: Context): c.Expr[Int] = c.universe.Ident(c.universe.TermName("$qmark$qmark$qmark"))
def impl(c: Context): c.Expr[Int] = c.Expr(c.universe.Ident(c.universe.TermName("$qmark$qmark$qmark")))
def foo = macro impl
def x: String = foo
val x: String = foo
typeTag[List[Int]] <:< typeTag[List[Any]]
typeTag[List[Int]].tpe <:< typeTag[List[Any]].tpe
abstract class AbsIterator extends AnyRef 
trait RichIterator extends AbsIterator
class StringIterator extends AbsIterator
class Iter extends StringIterator with RichIterator
typeOf[Iter].baseClasses
typeOf[Iter].typeSymbol.baseClasses
typeOf[Iter].typeSymbol.asClass.baseClasses
new { def x = 2 }
trait Foo[T] { implicit def contextBound: Bar[T] }
class Bar[T]
trait Foo[T] { implicit def contextBound: Bar[T] }
class C[T: Bar] extends Foo[T]
class C[T: Bar] extends Foo[T] { override def contextBound = implicitly[Bar[T]] }
implicit object BarInt extends Bar[Int]
new C[Int]
new C[Int]().contextBound
{ def foo
class C { def foo(x: Int) = x; def foo(y: String = "") = y }
class C { def foo(x: Int) = x; def foo(y: String = "") = y; def foo(z: Double = 0) = z }
class C { def foo(x: Int, y: String) = 1; def foo(x: Int, y: Int) = 2 }
new C().foo(x = 2)
class C { def foo(x: Int, y: String) = 1; def foo(x: Int) = 2 }
class C { def foo(x: Int, y: String = "") = 1; def foo(x: Int) = 2 }
new C().foo(x = 2)
class C { def foo(x: Int, y: String = "") = x; def foo(x: Int) = x }
new C().foo(x = 2)
class C { def foo(x: Int, y: String = "") = x; def foo(x: Int) = x }
new C().foo(x = 2)
class C { def foo(x: Int, y: Int)(z: Int, w: Int) = x }
new C().foo(y = 2, x = 3)(w = 4, z = 5)
class D { def foo(x: Int = 2) = x }
new D().foo()
List(1, 2).toMap
List((1, 2)).toMap
List(1, 2, 3).init
List().collectNot
???
val a = 1; val s =f"$a%s%n$a%s"
f"%n"
class Foo { def this(x: Int, y: Int) = macro impl }
class C
class D
type X = C with D
new X
class C
def impl(c: Context) = {
import c.universe._
Ident(c.typeOf[C].typeSymbol)
}
type X = macro impl
class D
type Y = D with X
new Y
List(1, 2).view
List(1, 2).view match { case x :: _ => x }
List(1, 2).view match { case x #:: _ => x }
List(1, 2).view match { case x :+ _ => x }
List(1, 2).view match { case x :+ _ => x.toList }
List(1, 2).view match { case x +: _ => x }
List(1, 2).view.flatMap{ case x if x == 1 => x; case _ => ??? } match { case x +: _ => x }
List(1, 2).view.flatMap{ case x if x == 1 => Some(x); case _ => ??? } match { case x +: _ => x }
class C(x: Int)
def foo(x: Int) = { println("ho ho ho"); new C(x) }
def tryFoo(x: Int) = { println("ho ho ho"); Some(new C(x)) }
List(1, 2, 3).view.flatMap(tryFoo) match { case C(x) => println("boo!") }
case class C(x: Int)
def tryFoo(x: Int) = { println("ho ho ho"); Some(C(x)) }
List(1, 2, 3).view.flatMap(tryFoo) match { case C(x) => println("boo!") }
List(1, 2, 3).view.flatMap(tryFoo) match { case C(x) +: _ => println("boo!") }
case class C(x: Int)
def tryFoo(x: Int) = { println("ho ho ho"); Some(C(x)) }
List(1, 2, 3).view.flatMap(tryFoo) match { case C(x) +: _ => println("boo!") }
exit
typeOf[Int].baseClasses
implicit class HasWhere(val exp : _) {}
    implicit class HasWhere(val exp : _) {
    def where(block : Unit) = macro whereInfix
    }
implicit class HasWhere(val exp : _) {
def where(block : Unit) = macro whereInfix
}
def impl(c: Context)(block: c.Tree) = c.literalUnit
implicit class HasWhere(val exp : _) {
def where(block : Unit) = macro impl
}
c where {}
typeOf[List[Int] { type X = Int }]
exit
typeOf[scala.reflect.pickling.Pickler[String] { type PickleType = scala.reflect.pickling.json.JSONPickle }]
typeOf[scala.pickling.Pickler[String] { type PickleType = scala.pickling.json.JSONPickle }]
null.asInstanceOf[String]
null.asInstanceOf[2]
null.asInstanceOf[Int]
def foo[T] = null.asInstanceOf[T]
foo[Int]
foo[String]
showRaw(typeOf[List[Int]{}])
showRaw(null.asInstanceOf[List[Int]{}])
showRaw(reify(null.asInstanceOf[List[Int]{}]))
reify{ val x: List[Int]{} = ??? }
showRaw(reify{ val x: List[Int]{} = ??? })
ListMap(Map(1 -> 2))
scala.collection.immutable.ListMap(Map(1 -> 2))
scala.collection.immutable.ListMap() ++ Map(1 -> 2)
2.asInstanceOf[Short]
100000.asInstanceOf[Byte]
val tpe = typeOf[Int]
tpe match { case tpe if tpe =:= typeOf[Int] => tpe }
import scala.collection.immutable.ListMap
sealed class UnpickleIR
case class ValueIR(value: Any) extends UnpickleIR
case class ObjectIR(tpe: Type, fields: ListMap[String, UnpickleIR]) extends UnpickleIR
import scala.collection.immutable.ListMap
sealed class UnpickleIR;case class ValueIR(value: Any) extends UnpickleIR;case class ObjectIR(tpe: Type, fields: ListMap[String, UnpickleIR]) extends UnpickleIR
val x: UnpickleIR = null
x match {
case ir @ ObjectIR(tpe, _) => null
case ir @ ValueIR(_) => null
}
x match {
case ir @ ObjectIR(tpe, _) => null
case ir @ ValueIR(_) => null
case _ => null
}
import scala.reflect.runtime.universe._ // underscore import is important in order not to get erasure warnings
reify((x: Int, y: Int) => x + 2)
showRaw(res0)
val Function(params, body) = res0.tree
val paramNames = params map (_.name)
new Traverser { override def traverse(tree: Tree) = tree match {
case Ident(name) if paramNames contains name => println(s"got $name")
case _ => super.traverse(tree)
} }.traverse(body)
// this was unreliable, because in a body of a function one could well define another variable named x or y, so you might get wrong results
// scalac binds definitions and their usages using symbols
// to get the reified tree attributed (i.e. have its symbols and types assigned), use a toolbox
import scala.tools.reflect.ToolBox
val cm = scala.reflect.runtime.currentMirror
val tb = cm.mkToolBox()
tb.typeCheck(res0.tree)
showRaw(res3)
showRaw(res3, printIds = true)
// note the #(\d)+ things in the last printout - they denote symbols
val Function(params, body) = res3.tree
val Function(params, body) = res3
val paramSymbols = params map (_.symbol)
new Traverser { override def traverse(tree: Tree) = tree match {
case ident: Ident if paramSymbols contains ident.symbol => println(s"got ${ident.symbol.name}")
case _ => super.traverse(tree)
} }.traverse(body)
def foo[T](x: T) = tb.eval(reify(x))
def foo[T](x: T) = tb.eval(reify(x).tree)
foo(2)
def foo[T](y: T) = tb.eval(reify({ val y: T = x; y }).tree)
def foo[T](x: T) = tb.eval(reify({ val y: T = x; y }).tree)
foo(2)
def foo[T: TypeTag](x: T) = tb.eval(reify({ val y: T = x; y }).tree)
foo(2)
val x = reify(2)
q"$x"
val x = reify(2)
q"$x"
val x = reify(2)
q"$x"
val it
=
staticClass("scala.collection.Iterable")
val iterableClass = cm.staticClass("scala.collection.Iterable")
iterableClass.toType
existentialAbstraction(iterableClass.toType)
showRaw(res0)
iterableClass.toType.asInstanceOf[TypeRef]
res3.args
existentialAbstraction(res3.args, res3)
existentialAbstraction(res3.args map (_.typeSymbol), res3)
q"case foo => bar"
val cdef = CaseDef(Ident(nme.WILDCARD), EmptyTree, q"???")
q"x match { $cdef }"
class X
object D extends X
typeOf[D.type]
typeOf[D.type].sourceModule
typeOf[D.type].typeSymbol
res2.sourceModule
res2.companion
res2.companionSymbol
res2 eq res5
res5.typeSignature.baseClasses
res2.typeSignature.baseClasses
Predef.Triple
object Foo
typeOf[Foo.type].typeSymbol
res0.isModule
res0.isClass
object Foo { object Bar }
typeOf[Foo.type].typeSignature
typeOf[Foo.type].members
typeOf[Foo.type].members.toList.head
res5.isModule
res5.asModule.moduleClass
res5.asModule.moduleClass.asClass.baseClasses
Predef$Triple$
IntClass.isSealed
IntClass.isFinal
cm.reflect[Boolean](true)(ClassTag.Boolean).symbol.asType.toType
showRaw(res0)
typeof[::[_]]
typeoOf[::[_]]
typeOf[::[_]]
res2.typeSymbol
res2.name
res3.name
res3.name.decoded
typeOf[List[Int]]
typeOf[::[_]].typeSymbol.typeSignature
typeOf[::[_]].typeSymbol.asType.toType
typeOf[List[Int]]
typeOf[::[_]].typeSymbol.asType.toType
res5.typeSignatureIn(res4)
res5.typeSymbol.typeSignatureIn(res4)
res5.asSeenFrom(NoPrefix, res4)
res5.asSeenFrom(NoPrefix, res4.typeSymbol)
res5.asSeenFrom(res4, res4.typeSymbol)
def qwe[T: TypeTag]: ::[T] = { println(typeOf[T]); Nil }
def qwe[T: TypeTag]: ::[T] = { println(typeOf[T]); ::(1, Nil).asInstanceOf[::[T]] }
val qqq: List[Int] = qwe
def foo(xx: List[Int]) = ()
foo(qwe)
l3.CL3ToCPSTranslator
CL3ToCPSTranslator
l3.CL3ToCPSTranslator
Some[_](1)
q"{case x => }"
q"case x =>"
def impl(c: Context)(x: c.Tree) = {
import c.universe._
x match {
case Bind(name, tree) => Bind(TermName(name.toString + name.toString), tree_
object Macros { def apply(x: Int) = x }
Macros(2)
null.asInstanceOf[Null]
val cc: List[CaseDef] = Nil
q"2 match { ..$cc }"
"a.b".split(".")
"a.b".split('.')
"a".split('.')
"a".split('.').map(_.capitalize)
class C(val x: Int)
typeOf[C].declarations
val ctor = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten
typeOf[C].declarations.toList
res1(0) == ctor(0)
res1(0) == ctor(1)
res1(0) == ctor(0)
res1(1) == ctor(0)
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten(0)
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten().apply(0)
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten.apply(0)
val x1 = typeOf[C].declarations.toList().apply(0)
val x1 = typeOf[C].declarations.toList(0)
val x2 = typeOf[C].declarations.toList(1)
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten.apply(0)
x1.isMethod
x2.isMethod
ctorx.isMethod
val x1 = typeOf[C].declarations.toList(0).asTerm
val x2 = typeOf[C].declarations.toList(1).asTerm
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten.apply(0).asTerm
x1.accessed
x2.accessed
x2.accessor
val x1 = typeOf[C].declarations.toList(0).asTerm
val x2 = typeOf[C].declarations.toList(1).asTerm
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten.apply(0).asTerm
x1.isParamAccessor
x2.isParamAccessor
ctorx.isParamAccessor
ctorx.isParameter
x1.isParameter
x2.isParameter
ctorx.isPublic
x1.isPublic
x2.isPublic
class C(x: Int)
val x1 = typeOf[C].declarations.toList(0).asTerm
val x2 = typeOf[C].declarations.toList(1).asTerm
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten.apply(0).asTerm
ctorx.isPublic
x1.isPublic
x1.isParamAccessor
x1.isAccessor
new String("X")
q""
val x = Nil
q"1; ..$x; 1"
class C(x: Int)(y: Int)
object D
val mc = typeOf[D.type].typeSymbol
mc.isModuleClass
mc.isFinal
def foo[T <: Singleton] = 1
class C
object C
classC; object C
class C; object C 
foo[C]
foo[C.type]
val x = 1
foo[x.type]
val x = "1"
foo[x.type]

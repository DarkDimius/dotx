typed(Literal(Constant(1))
)
typed(Literal(Constant(1)))
typed(Literal(Constant(1))).tpe
typed(Literal(Constant(1))).tpe.underlying
typed(Literal(Constant(IntTpe))
)
typed(Literal(Constant(IntTpe))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe))))
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe
typed(Apply(Ident(ListModule), List(Literal(Constant(1))))).tpe
afterPhase(currentRun.erasurePhase)(typed(Apply(Ident(ListModule), List(Literal(Constant(1))))).tpe)
New(ConsClass, Literal(Constant(1)), Ident(NilModule))
typed(New(ConsClass, Literal(Constant(1)), Ident(NilModule)))
New(appliedType(ConsClass, List(Ident(IntTpe))), Literal(Constant(1)), Ident(NilModule))
New(appliedType(ConsClass, List(Ident(IntClass))), Literal(Constant(1)), Ident(NilModule))
New(appliedType(ConsClass, Ident(IntClass)), Literal(Constant(1)), Ident(NilModule))
New(appliedType(ConsClass, IntTpe), Literal(Constant(1)), Ident(NilModule))
typed(New(appliedType(ConsClass, IntTpe), Literal(Constant(1)), Ident(NilModule)))
typed(New(appliedType(ConsClass, IntTpe), Literal(Constant(1)), Ident(NilModule))).tpe
afterPhase(currentRun.erasurePhase)(typed(Apply(Ident(ListModule), List(Literal(Constant(1))))).tpe)
afterPhase(currentRun.erasurePhase)(typed(New(appliedType(ConsClass, IntTpe), Literal(Constant(1)), Ident(NilModule))).tpe)
typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(1)), Ident(NilModule))).tpe
typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe
afterPhase(currentRun.erasurePhase)(typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe)
:power
typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe
afterPhase(currentRun.erasurePhase)(typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe)
typed(Literal(Constant(IntTpe))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe
:power
typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe
afterPhase(currentRun.erasurePhase)(typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe)
typed(Literal(Constant(IntTpe))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.underlying
typed(Literal(Constant(IntTpe))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.underlying
:power
typed(Literal(Constant(IntTpe))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.underlying
:power
typed(Literal(Constant(IntTpe))).tpe.underlying
typed(Literal(Constant(IntClass.asTypeConstructor))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntClass.asTypeConstructor)))).tpe.underlying
macro def foo = ???
exit
:power
typed(Literal(Constant(IntTpe))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntClass.asTypeConstructor)))).tpe.underlying
exit
val head = typeOf[List[Int]].member(newTermName("head")).asMethod
head.returnType
println(showRaw(head.returnType))
val head = typeOf[List[Int]].member(newTermName("head")).asMethod
val head_a = head.returnType.typeSymbol
val TypeRef(_,_,List(a)) = typeOf[List[_]].typeSymbol.asType.toType
val list_a = a.typeSymbol
head_a eq list_a\
head_a eq list_a
val list = typeOf[List[_]].typeSymbol.asType.toType
val head = typeOf[List[Int]].member(newTermName("head")).asMethod
showRaw(list)
showRaw(head.typeSignature)
showRaw(list.returnType, printIds = true, printKinds = true)
showRaw(list, printIds = true, printKinds = true)
showRaw(head.returnType, printIds = true, printKinds = true)
showRaw(typeOf[List[_]].member(newTermName("head")).typeSignature)
showRaw(typeOf[List[_]].member(newTermName("head")).typeSignature, printIds = true, printKinds = true)
showRaw(typeOf[List[_]].member(newTermName("tail")).typeSignature, printIds = true, printKinds = true)
showRaw(typeOf[List[_]].declaration(newTermName("tail")).typeSignature, printIds = true, printKinds = true)
showRaw(typeOf[List[_]].declaration(newTermName("head")).typeSignature, printIds = true, printKinds = true)
val TypeRef(_, _, List(a)) = typeOf[List[_]].dealias.typeSymbol.asType.toType
val TypeRef(_, _, List(a)) = typeOf[List[_]].normalize.typeSymbol.asType.toType
showRaw(a, printIds = true, printKinds = true)
val TypeRef(_, _, List(type_parameter_of_list)) = typeOf[List[_]].dealias.typeSymbol.asType.toType
val TypeRef(_, _, List(type_parameter_of_list)) = typeOf[List[_]].normalize.typeSymbol.asType.toType
val NullaryMethodType(type_parameter_of_head) = typeOf[List[_]].declaration(newTermName("head")).typeSignature
:power
typed(Literal(Constant(IntTpe))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.underlying
ConstantType(Constant(IntTpe))
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(IntTpe)))
typed(Literal(Constant(StringTpe))).tpe.underlying
typed(Literal(Constant(StringTpe))).tpe.getClass
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(StringTpe)))
afterPhase(currentRun.erasurePhase)(Literal(Constant(IntTpe)))
afterPhase(currentRun.erasurePhase)(Literal(Constant(IntTpe))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe
Constant(IntTpe).tpe
Constant(IntTpe).typeValue
afterPhase(currentRun.erasurePhase)(Constant(IntTpe).typeValue)
afterPhase(currentRun.erasurePhase)(Constant(IntTpe))
afterPhase(currentRun.erasurePhase)(Constant(IntTpe).tpe)
:power
RootClass
RootClass.id
JavaPackage
JavaLangPackageClass.id
JavaLangPackage.id
JavaLangPackageClass.owner
JavaLangPackageClass.owner.id
showRaw(StringTpe, printIds = true)
:power
transformedType
transformedType(IntTpe)
showRaw(res1, printIds = true)
ConstantType(Constant(res1))
ConstantType(Constant(res1)).underlying
typed(Literal(Constant(res2)))
typed(Literal(Constant(res2))).tpe
typed(Literal(Constant(res1))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(res1))))
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(res1)))).tpe
ConstantType(Constant(res1)).getClass
transformedType(StringClass.toType)
showRaw(res11, printIds = true)
ConstantType(Constant(res11))
ConstantType(Constant(res11)).underlying
res11
ConstantType(Constant(res11)).underlying
ConstantType(Constant(res11))
exit
val s = transformedType(StringClass.toType)
:power
val s = transformedType(StringClass.toType)
showRaw(s)
ConstantType(Constant(s))
exit
val s = transformedType(StringClass.toType)
ConstantType(Constant(s))
Constant(s).##
new UniqueConstantType(Constant(s)).##
unique
new UniqueConstantType(Constant(s)) == new UniqueConstantType(Constant(s))
ConstantType(Constant(s)) == ConstantType(Constant(s))
ConstantType(Constant(s)) eq ConstantType(Constant(s))
ConstantType(Constant(s))
ConstantType(Constant(s)).##
:power
val s = transformedType(StringClass.toType)
val s = transformedType(StringClass.asTypeConstructor)
showRaw(s)
ConstantType(Constant(s))
System.identityHashCode(ConstantType(Constant(s)))
uniques
unique
exit
:power
val s = transformedType(StringClass.asTypeConstructor)
val s = transformedType(StringClass.toType)
Constant(StringClass.toType)
Constant(s)
res0.##
res1.##
Constant(s)
Constant(s).##
Constant(StringClass.toType).##
ConstantType(res0).##
ConstantType(res1).##
exit
val s = transformedType(StringClass.toType)
ConstantType(Constant(s))
{ ConstantType(Constant(s)); ConstantType(Constant(s)) }
{ println(ConstantType(Constant(s))); afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); }
exit
:power
val s = transformedType(StringClass.toType)
{ val t1 = ConstantType(Constant(s))); println(t1.underlying); val t2 = afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); println(t2.underlying); }
{ val t1 = ConstantType(Constant(s)); println(t1.underlying); val t2 = afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); println(t2.underlying); }
{ val t1 = ConstantType(Constant(s)); println(t1.underlying); val t2 = afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); println(t2.underlying); println(t2) }
{ val t1 = ConstantType(Constant(s)); println(t1.underlying); println(afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))); }
{ val t1 = ConstantType(Constant(s)); println(afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))); }
{ println(afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))); }
Seq(1, 2).toString
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
{ afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); ConstantType(Constant(s)) }
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
cm.staticModule("scala.math.package")
cm.reflectModule(res0)
res1.runtimeClass
res1.instance
NoSymbol.baseClasses
EnumType(NoSymbol)
EnumType(IntClass)
q""
typeOf[List[_]].typeSymbol.asClass.isSealed
trait A { type T <: A }
trait B { type T <: B }
glb(typeOf[A], typeOf[B])
glb(List(typeOf[A], typeOf[B]))
ru.asInstanceOf[scala.reflect.internal.Types].uniques
ru.asInstanceOf[scala.reflect.internal.Types].uniques.asInstanceOf[scala.reflect.internal.util.HashSet[_]]
trait A { type T <: A }
trait B { type T <: B }
uniques
glb(List(typeOf[A], typeOf[B]))
uniques
glb(List(typeOf[A], typeOf[B]))
uniques
trait A1 { type T <: A1 }
trait B1 { type T <: B1 }
uniques
glb(List(typeOf[A1], typeOf[B1]))
uniques
glb(List(typeOf[A1], typeOf[B1]))
uniques
Runtime.freeMemort
Runtime.freeMemory
Runtime.freeMemory()
java.lang.Runtime.freeMemory()
Runtime.getRuntime().freeMemory()
Array(1, 2).sum
val arr = Array(1, 2)
arr.toArray[Any]
trait A { type T <: A }
trait B { type T <: B }
typeOf[A with B]
typeOf[List[List[A with B]]]
scala.math.`package`
def impl(c: Context) = c.literal(c.compilerSettings)
def impl(c: Context) = c.literal(c.compilerSettings.toString)
def foo = macro impl
foo
def impl(c: Context) = c.literal(show(c.libraryClassLoader))
def foo = macro impl
foo
val cache = scala.collection.mutable.HashMap[scala.reflect.macros.Context#Run, Int]()
def impl(c: Context) = c.literal(cache(c.currentRun) = cache.getOrElseUpdate(c.currentRun, 0) + 1)
def impl(c: Context) = c.literal({cache(c.currentRun) = cache.getOrElseUpdate(c.currentRun, 0) + 1; cache(c.currentRun)})
def foo = macro impl
foo
{ foo; foo }
def foo[T] = println(showRaw(weakTypeOf[List[T]]))
foo
typeOf[scala.math.type]
typeOf[scala.math.`package`.type]
res1.typeSymbol
showRaw(res1.typeSymbol.flags)
res1.typeSymbol.isPackageClass
res1.typeSymbol.isModuleClass
List() forall (_ % 2 == 1)
List[Int]() forall (_ % 2 == 1)
shiowRaw(res0.staticCpe)
showRaw(res0.staticTpe)
showRaw(res0.)
showRaw(res0.ac
showRaw(res0.ac))
showRaw(res0.actualTpe)
res0.
))
showRaw(res0.staticType)
List().toHashSet
exit
1 to 10 foreach (_ => Thread.sleep(1000))
exit
class S(x: Int, y: Int) extends scala.annotation.StaticAnnotation
@S(1 + 1, 2) class C
import scala.reflect.runtime._
import scala.reflect.runtime.universe._
import scala.reflect.runtime.currentMirror
import scala.reflect.runtime.{currentMirror => cm}
val c = typeOf[C].typeSymbol
val c = cm.staticClass("C")
val c = typeOf[C].typeSymbol
c.annotations
showRaw(c.annotations)
showRaw(c.annotations(0))
c.annotations(0).scalaArgs
c.annotations(0).javaArgs
val x = 2
@S(x, 2) class C
val c = typeOf[C].typeSymbol
c.annotations(0).scalaArgs
import scala.reflect.runtime.universe._
class C(x: Int, y: Int) extends scala.annotation.StaticAnnotation
class S(x: Int, y: Int) extends scala.annotation.StaticAnnotation
val x = 2
@S(x, 2) class C
val c = typeOf[C].typeSymbol
c.annotations
showRaw(c.annotations(0).scalaArgs(0))
showRaw(c.annotations(0).scalaArgs(1))
class J(x: Int, y: Int) extends scala.annotation.ClassfileAnnotation
import scala.reflect.runtime.universe._
showRaw(reify{ class C { def x = 2 } }.tree)
showRaw(typeOf[{ def x: Int; val y: List[Int] }])
showRaw(typeOf[{ def x: Int; val y: List[Int] }], printIds = true, printKinds = true)
show(cm.classLoader)
import scala.reflect.runtime.universe._
val tree = reify{ class C { def x = 2 } }
val tree = reify{ class C { def x = 2 } }.tree
import scala.reflect.runtime.universe._
show(reify{ class C { def x = 2 } }.tree)
import scala.reflect.runtime.universe._
show(reify{ class C { def x = 2 } }.tree)
showRaw(reify{ class C { def x = 2 } }.tree)
show(typeOf[{ def x: Int; val y: List[Int] }])
showRaw(typeOf[{ def x: Int; val y: List[Int] }])
showRaw(typeOf[{ def x: Int; val y: List[Int] }], printIds = true, printKinds = true)
import scala.tools.reflect.ToolBox._ // requires scala-compiler.jar
import scala.tools.reflect.ToolBox // requires scala-compiler.jar
import scala.reflect.runtime.{currentMirror => cm}
cm.mkToolBox().typeCheck(reify{ class C { def x = 2 } })
cm.mkToolBox().typeCheck(reify{ class C { def x = 2 } }.tree)
showRaw(cm.mkToolBox().typeCheck(reify{ class C { def x = 2 } }.tree), printTypes = true)
show(reify{ final class C { def x = 2 } }.tree)
def tree = reify{ final class C { def x = 2 } }.tree
showRaw(tree)
showRaw(cm.mkToolBox().typeCheck(tree), printTypes = true)
def tree = reify{ final class C { def x = 2 } }.tree
showRaw(cm.mkToolBox().typeCheck(tree), printTypes = true)
def tree = reify{ final class C { def x = 2 } }.tree
showRaw(cm.mkToolBox().typeCheck(tree), printTypes = true)
def tree = reify{ final class C { def x = 2 } }.tree
showRaw(cm.mkToolBox().typeCheck(tree), printTypes = true)
def m(x: Int*) = ???
class C { def m(x: Int*) = ??? }
val m = typeOf[C].member(newTermName("m")).asMethod
m.params
m.params(0)(0).typeSignature
showRaw(m.params(0)(0).typeSignature)
import scala.reflect.runtime.universe._
class C { def m(x: => Int) = ??? }
val m = typeOf[C].member(newTermName("m")).asMethod
m.params(0)(0).typeSignature
showRaw(m.params(0)(0).typeSignature)
import scala.reflect.runtime.universe._
reify(x + 2)
val x = 2
reify(x + 2)
reify(x + 2).tree
res2.getClass
res2.getClass.toString
import scala.reflect.runtime.universe._
import scala.reflect.runtime.{currentMirror => cm}
import scala.reflect.runtime.ToolBox
import scala.tools.reflect.ToolBox
val tb = cm.mkToolBox()
tb.parse("x + 2")
val mirror = runtimeMirror(getClass.getClassLoader)
tb.eval(tb.parse("2 + 2"))
showRaw(reify{ trait X { def x: Int } })
showRaw(reify{ trait X { def x: Int } }.tree)
showRaw(reify{ trait X { def x = 2 } }.tree)
showRaw(reify{ 2 match { case x @ List(_) => } }.tree)
showRaw(reify(2 match { case x @ List(_) => }).tree)
showRaw(reify(2).tree)
showRaw(2 match { case x => x })
showRaw(2 match { case x => x }.tree)
showRaw(reify(2 match { case x => x }))
showRaw(reify(2 match { case x => x }).tree)
showRaw(reify(2 match { case x @ List(_) => x }).tree)
showRaw(reify(2 match { case _ => x }).tree)
showRaw(reify(2 match { case _ => }).tree)
showRaw(reify(2 match { case List(_) => }).tree)
showRaw(reify(2 match { case List(x) => }).tree)
showRaw(reify(2 match { case List(_) => }).tree)
showRaw(reify(List(2) match { case List(_) => }).tree)
showRaw(reify(List(2) match { case List(x) => }).tree)
exit
trait Foo { self: scala.reflect.api.Universe =>
def foo(x: Any) = x match { case expr: Expr[_] => }
}
showRaw(reify(this))
showRaw{ def foo[T <: Int] = ??? }
showRaw(reify{ def foo[T <: Int] = ??? })
showRaw(reify{ def foo[T] = ??? })
object i
reify{val x = i; x}
res0.eval
val x: i.type = i; x
reify{val x: i.type = i; x}
res3.eval
import scala.reflect.runtime.universe._
val cm = runtimeMirror(getClass.getClassLoader)
val list = cm.staticClass("scala.List")
val list = typeOf[List].typeSymbol
val list = typeOf[List[_]].typeSymbol
list.typeSignature.member("map": TermName)
val map = list.typeSignature.member("map": TermName).asMethod
map.params
map.params(0)(0)
val f = map.params(0)(0)
val filter = map.params(0)(0)
filter.name
filter.typeSignature
map.typeParams
val list = typeOf[List[_]].typeSymbol
list.member("mkString": TermName)
list.typeSignature.member("mkString": TermName)
val mkString = list.typeSignature.member("mkString": TermName)
val mkString = list.typeSignature.member("mkString": TermName).asTerm
mkString.isMethod
mkString.alternatives
mkString.alternatives foreach println
mkString.alternatives foreach (alt => println(alt.typeSignature))
def foo(x: Int*) = ???
def foo(xs: Int*) = ???
def foo(xs: Int*) = xs.sum
def add(xs: Int*) = xs.sum
def impl(c: Context)(xs: c.Expr[Int]*): c.Expr[Int] = {
import c.universe._
val map = list.typeSignature.member("map": TermName).asMethod
val filter = map.params(0)(0)
filter.typeSignatureIn(typeOf[List[Int]])
map.typeSignatureIn(typeOf[List[Int]])
filter.typeSignatureIn(res1)
map.typeSignature
map.typeSignatureIn(typeOf[List[Int]])
typeOf[List[Int]]
showRaw(res0)
res0.typeSignature
res0.members
typeOf[scala.List[_]] =:= typeOf[scala.collection.immutable.List[_]]
typeOf[scala.List[_]] == typeOf[scala.collection.immutable.List[_]]
import scala.reflect.runtime.universe._
typeOf[List[_]].members take 5 foreach println
typeOf[List[_]].members.sorted take 5 foreach println
def test[T: TypeTag](x: T) = s"I've been called for x with the type ${typeOf[T]}"
test(2)
test(List(2, "x"))
import scala.reflect.runtime.universe._
val cm = runtimeMirror(getClass.getClassLoader)
cm.classSymbol(List(1, 2).getClass)
typeOf[List[Int]]
cm.classSymbol(List(1, 2).getClass).typeSignature
cm.classSymbol(List(1, 2).getClass).toType
typeOf[List[Int]]
def invokeHead(x: Any): Any = ???
def invokeHead[T: TypeTag](x: T): Any = ???
def invokeHead(x: Any): Any = {
// type of x is unknown, the best we can do is
// cm.classSymbol(x.getClass).toType
???
}
def invokeHead[T: TypeTag](x: T): Any = {
// type of x is preserved by the compiler
println(typeOf[T])
}
invokeHead(List(1, 2))
invokeHead(List("x"))
def invokeHead(x: Any): Any = {
// type of x is unknown, the best we can do is
println(cm.classSymbol(x.getClass).toType)
}
invokeHead(List(1, 2))
invokeHead(List("x"))
typeOf[List[Int]].member("head": TermName).asMethod
val head = typeOf[List[Int]].member("head": TermName).asMethod
val im = cm.reflect(List(1, 2))
val mm = im.reflectMethod(head)
mm()
def foo(x: Int = 2) = ???
class C { def foo(x: Int = 2) = ??? }
typeOf[C].declarations
class Coll[T] {
def filter(p: T => Boolean): Coll[T] = macro filter_impl[T]
}
class Coll[T] {
def filter(p: T => Boolean): Coll[T] = macro filter_impl[T]
} object Coll
class Coll[T] {
def filter(p: T => Boolean): Coll[T] = macro Macros.filter[T]
}
class Coll[T] {
def filter(p: T => Boolean): Coll[T] = macro Macros.filter[T]
} object Macros {
class Coll[T] {
def filter(p: T => Boolean): Coll[T] = macro Macros.filter[T]
}; object Macros {
def filter[T](c: Context { type PrefixType = Coll[T] })(p: c.Expr[T => Boolean]): c.Expr[Coll[T]] = { println(c.prefix); c.prefix }
}
new Coll[Int]().filter(_ % 2 == 0)
val x = new Coll[String]()
x.filter(_ != "")
def impl(c: Context)(x: c.Expr[Int]) = {
println(s"compile-time value is: ${c.eval(x)}")
x
}
def test(x: Int) = macro impl
test(2)
def impl(c: Context)(x: c.Expr[Int]) = {
val x1 = c.Expr[Int](c.resetAllAttrs(x.tree.duplicate))
println(s"compile-time value is: ${c.eval(x1)}")
x
}
def test(x: Int) = macros impl
def test(x: Int) = macro impl
test(2)
test(2 + 2)
def impl(c: Context)(x: c.Expr[String]) = {
val x1 = c.Expr[String](c.resetAllAttrs(x.tree.duplicate))
println(s"compile-time value is: ${c.eval(x1)}")
x
}
def test(x: String) = macro impl
test("x")
test("x" + "y")
val x = "x"
test(x + "y")
{ val x = "x"; test(x + "y") }
trait Foo { implicit def manifest = implicitly[Manifest[Element]] }
trait Foo { implicit def manifest = implicitly[Manifest[Int]] }
trait Foo { implicit def manifest = implicitly[Manifest[Foo]] }
class C
trait Foo { implicit def manifest = implicitly[Manifest[C]] }
new Foo{}
new Foo{}.manifest
typeOf[String].typeSymbol.asType.isAliasType
showRaw(typeOf[String])
typeOf[String].typeSymbol.typeSignature
typeOf[String].typeSymbol.asType.isAliasType
typeOf[String].typeSymbol
typeOf[String].flags
typeOf[List].flags
typeOf[List[_]].flags
showRaw(typeOf[List[_]])
typeOf[String].typeSymbol.asType.isAliasType
val TypeRef(_, sym, _) = typeOf[String]
sym.typeSymbol.asType.isAliasType
sym.asType.isAliasType
showRaw(typeOf[String])
typeOf[String].typeSymbol
def foo(c: Context): c.Tree = ???
def bar(c: Context): c.Tree = foo(c)
def bar(c: Context): c.Tree = c.literalUnit.tree
class Helper(c: Context) {
def generate: c.Tree = ???
}
class Helper(val c: Context) {
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper(c)
c.Expr(helper.generate)
}
class Helper(val c: Context) {
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper
}
abstract class Helper {
val c: Context
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val c1: c.type
}
def impl(c1: Context): c1.Expr[Unit] = {
val helper = new { val c: c1.type = c1 } with Helper
c.Expr(helper.generate)
}
def impl(c1: Context): c1.Expr[Unit] = {
val helper = new { val c: c1.type = c1 } with Helper
c1.Expr(helper.generate)
}
class Helper[C <: Singleton]
class Helper[C <: Singleton](val c: Context) {
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper(c)
c.Expr(helper.generate)
}
class Helper[C <: Singleton](val c: C) {
def generate: c.Tree = ???
}
class Helper[C <: Context with Singleton](val c: C) {
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper(c)
c.Expr(helper.generate)
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper[c.type](c)
c.Expr(helper.generate)
}
class C(val x: Any) { def cast[T]: T = x.asInstanceOf[T] }
new C("xxx").cast[Int]
class C(val x: Any) { def cast[T]: Any = x.asInstanceOf[T] }
new C("xxx").cast[Int]
class C(val x: Any) { def cast[T <: Int]: Any = x.asInstanceOf[T] }
new C("xxx").cast[Int]
def foo[T: TypeTag] = println(typeOf[T])
foo[Int]
foo[String]
foo[List[Int]]
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typetag = c.inferImplicitValue(weakTypeOf[T])
if (typeTag == EmptyTree) c.abort(
}
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typeTags= c.mirror.staticClass("scala.reflect.api.TypeTags)
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typeTags= c.mirror.staticClass("scala.reflect.api.TypeTags"
)
}
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typeTags= c.mirror.staticClass("scala.reflect.api.TypeTags")
val typeTag = typeTags.typeSignature.member(newTypeName("TypeTag")).asClass.toType
val typeTagOfT = appliedType(typeTag, List(weakTypeOf[T])
val inferred = c.inferImplicitValue(typeTagOfT)
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typeTags = c.mirror.staticClass("scala.reflect.api.TypeTags")
val typeTag = typeTags.typeSignature.member(newTypeName("TypeTag")).asClass.toType
val typeTagOfT = appliedType(typeTag, List(weakTypeOf[T]))
val inferred = c.inferImplicitValue(typeTagOfT)
if (inferred == EmptyTree) c.abort("can't provide a weak type here")
c.literalUnit
}
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typeTags = c.mirror.staticClass("scala.reflect.api.TypeTags")
val typeTag = typeTags.typeSignature.member(newTypeName("TypeTag")).asClass.toType
val typeTagOfT = appliedType(typeTag, List(weakTypeOf[T]))
val inferred = c.inferImplicitValue(typeTagOfT)
if (inferred == EmptyTree) c.abort("can't provide a weak type here")
}
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typeTags = c.mirror.staticClass("scala.reflect.api.TypeTags")
val typeTag = typeTags.typeSignature.member(newTypeName("TypeTag")).asClass.toType
val typeTagOfT = appliedType(typeTag, List(weakTypeOf[T]))
val inferred = c.inferImplicitValue(typeTagOfT)
if (inferred == EmptyTree) c.abort(c.enclosingPosition, "can't provide a weak type here")
c.literalUnit
}
def foo[T] = macro impl[T]
foo[List[Int]]
def bar[T] = foo[T]
new Exception().getStackTraceString
new Exception().printStackTrace
scala.tools.nsc.util.stackTraceString(new Exception)
def impl[T: c.WeakTypeTag](c: Context) = c.universe.reify { val x: T = null.asInstanceOf[T] }
def foo[T] = macro impl[T]
foo[Int]
def foo[T] = println("1")
def foo[T](x: T) = println("2")
foo[Int]
foo[Int]()
def foo[T] = println("1"); def foo[T](x: T) = println("2")
foo[Int]
foo(1)
class C { def foo[T <: Int]: T = ??? }
typeOf[C].member(newTermName("foo"))
vak foo = typeOf[C].member(newTermName("foo")).asMethod
val foo = typeOf[C].member(newTermName("foo")).asMethod
foo.typeParams(0)
foo.typeParams(0).typeSignature
foo.typeParams(0).typeSignature.erasure
def foo[T] = weakTypeOf[Map[Int, T]]
foo[Int]
def foo[T] = weakTypeOf[Map[Int, T]].erasure
foo[Int]
def foo[T] = weakTypeOf[Map[String, T]].erasure
foo[Int]
(params: Seq[Any]) => params(0).asInstanceOf[math.Numeric[_]].mkNumericOps (params(1).asInstanceOf[Object]))
(params: Seq[Any]) => params(0).asInstanceOf[math.Numeric[_]].mkNumericOps (params(1).asInstanceOf[Object])
type T1 = T forSome { type T }
type T = T1 forSome { type T1 }
(params: Seq[Any]) => params(0).asInstanceOf[math.Numeric[T]].mkNumericOps (params(1).asInstanceOf[T])
type T = T forSome { type T }
(params: Seq[Any]) => params(0).asInstanceOf[math.Numeric[T]].mkNumericOps (params(1).asInstanceOf[T])
case class C(val x: Int, val y: Int)
typeOf[C].declarations.collect{case x: MethodSymbol if x.isCaseAccessor}
typeOf[C].declarations.collect{case x: MethodSymbol if x.isCaseAccessor => x}
case class C(val x: Int, val y: Int)
typeOf[C].declarations.collect{case x: MethodSymbol if x.isCaseAccessor => x}
class C { def x = 2 }
val m = ru.runtimeMirror(getClass.getClassLoader)
val im = m.reflect(new C)
val mm = m.reflectMethod(typeOf[C].declaration(newTermName("x")).asMethod)
val mm = im.reflectMethod(typeOf[C].declaration(newTermName("x")).asMethod)
mm()
val methodX = typeOf[C].declaration(newTermName("x")).asMethod
val mm = im.reflectMethod(methodX)
class C { var x = 2 }
class C { val x = 2; var y = 3 }
val fieldX = typeOf[C].declaration(newTermName("x")).asTerm.accessed
val fieldY = typeOf[C].declaration(newTermName("y")).asTerm.accessed
val im = m.reflect(new C)
val fmX = im.reflectField(fieldX)
val fieldX = typeOf[C].declaration(newTermName("x")).asTerm.accessed.asTerm
val fieldY = typeOf[C].declaration(newTermName("y")).asTerm.accessed.asTerm
val fmX = im.reflectField(fieldX)
val fmY = im.reflectField(fieldY)
fmX.get
fmX.set(3)
fmY.get(3)
fmY.get
fmY.set(4)
fmY.get
case class C(val x: Int)
val classC = typeOf[C].typeSymbol
val cm = im.reflectClass(classC)
val classC = typeOf[C].typeSymbol.asClass
val cm = im.reflectClass(classC)
val cm = m.reflectClass(classC)
val ctorC = typeOf[C].declaration(ru.nme.CONSTRUCTOR).asMethod
val ctorm = cm.reflectConstructor(ctorC)
ctorm(2)
object C { def x = 2 }
val objectC = typeOf[C.type].termSymbol.asModule
val modm = m.reflectModule(objectC)
modm.instance
val mod = modm.instance
val mm = m.reflectModule(objectC)
val obj = mm.instance
import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;
ManagementFactory.getRuntimeMXBean().getInputArguments()
ManagementFactory.getRuntimeMXBean().getInputArguments().toString
exit
import scala.reflect.macros.Context
def impl(c: Context): c.Expr[Int] = {
import c.universe._
val lm = DefDef(NoMod, newTermName("foo"), Nil, List(Nil), TypeTree(), Literal(Constant(2)))
Block(List(lm), Ident(newTermName("foo")))
}
def impl(c: Context): c.Expr[Int] = {
import c.universe._
val lm = DefDef(NoMods, newTermName("foo"), Nil, List(Nil), TypeTree(), Literal(Constant(2)))
c.Expr(Block(List(lm), Ident(newTermName("foo"))))
}
def test = macro impl
import language.experimental.macros
def test = macro impl
test
typeOf[List[Int]].member(newTermName("head"))
import scala.reflect.runtime.universe._
typeOf[List[Int]].member(newTermName("head"))
res2.asMethod.paramss
res2.asMethod.params
res2.asMethod.returnType
typeOf[Range].member(newTermName("inclusive")).asMethod.returnType
typeOf[Range].member(newTermName("inclusive")).asMethod
res7.owner
exit
      case m if m.isMethod => m.asMethod 
    }
import scala.reflect.runtime.universe._
typeOf[String].members.collect { 
      case m if m.isMethod => m.asMethod 
    }
import scala.reflect.runtime.universe._
def invoke[Target : TypeTag](obj: Any): Seq[Target] = {
  val mirror = runtimeMirror(obj.getClass.getClassLoader)
  val insMirror = mirror reflect obj
  val originType = insMirror.symbol.typeSignature
  val targetType = typeTag[Target].tpe
  val members = originType.nonPrivateMembers.filter(_.isValue)
  val result = members collect (member => member.typeSignature match {
    case tpe if tpe <:< typeOf[ThirdParty] =>
      if (member.isModule)
        (insMirror reflectModule member.asModuleSymbol).instance
      else
        (insMirror reflectField member.asTermSymbol).get
    case NullaryMethodType(tpe) if tpe <:< typeOf[ThirdParty] =>
      (insMirror reflectMethod member.asMethodSymbol).apply()
    case MethodType(Nil, tpe) if tpe <:< typeOf[ThirdParty] =>
      (insMirror reflectMethod member.asMethodSymbol).apply()
  })
  result.map(_.asInstanceOf[Target]).toSeq
}
exit
import scala.reflect.runtime.universe._
trait ThirdParty { def invoke = println("right") }
trait WeatherIcon { def invoke = println("wrong") }
class MyClass {
    object objA extends ThirdParty
    object objB extends WeatherIcon
}
val members = typeOf[MyClass].members.filter(_.isValue).filter(_.typeSignature match {
  case tpe if tpe <:< typeOf[ThirdParty] => true
  case NullaryMethodType(tpe) if tpe <:< typeOf[ThirdParty] => true
  case MethodType(Nil, tpe) if tpe <:< typeOf[ThirdParty] => true
  case _ => false
})
val members = typeOf[MyClass].members.filter(_.typeSignature match {
  case tpe if tpe <:< typeOf[ThirdParty] => true
  case NullaryMethodType(tpe) if tpe <:< typeOf[ThirdParty] => true
  case MethodType(Nil, tpe) if tpe <:< typeOf[ThirdParty] => true
  case _ => false
}
)
import scala.reflect.runtime.universe._
def invoke[Target : TypeTag](obj: Any): Seq[Target] = {
  val mirror = runtimeMirror(obj.getClass.getClassLoader)
  val insMirror = mirror reflect obj
  val originType = insMirror.symbol.typeSignature
  val targetType = typeTag[Target].tpe
  val members = originType.members
  val result = members collect (member => member.typeSignature match {
    case tpe if tpe <:< typeOf[ThirdParty] =>
      if (member.isModule)
        (insMirror reflectModule member.asModuleSymbol).instance
      else
        (insMirror reflectField member.asTermSymbol).get
    case NullaryMethodType(tpe) if tpe <:< typeOf[ThirdParty] =>
      (insMirror reflectMethod member.asMethodSymbol).apply()
    case MethodType(Nil, tpe) if tpe <:< typeOf[ThirdParty] =>
      (insMirror reflectMethod member.asMethodSymbol).apply()
  })
  result.map(_.asInstanceOf[Target]).toSeq
}
    import scala.reflect.runtime.universe._
    def invoke[Target : TypeTag](obj: Any): Seq[Target] = {
      val mirror = runtimeMirror(obj.getClass.getClassLoader)
      val insMirror = mirror reflect obj
      val originType = insMirror.symbol.typeSignature
      val targetType = typeTag[Target].tpe
      val members = originType.members
      val result = members collect (member => member.typeSignature match {
        case tpe if tpe <:< typeOf[ThirdParty] =>
          if (member.isModule)
            (insMirror reflectModule member.asModule).instance
          else
            (insMirror reflectField member.asTerm).get
        case NullaryMethodType(tpe) if tpe <:< typeOf[ThirdParty] =>
          (insMirror reflectMethod member.asMethod).apply()
        case MethodType(Nil, tpe) if tpe <:< typeOf[ThirdParty] =>
          (insMirror reflectMethod member.asMethod).apply()
      })
      result.map(_.asInstanceOf[Target]).toSeq
    }
class MyClass {
        object objA extends ThirdParty
        object objB extends WeatherIcon
        val aVal = new ThirdParty {}
        val bVal = new WeatherIcon {}
        def aDef = new ThirdParty {}
        def bDef = new WeatherIcon {}
        def anotherDef() = new ThirdParty {}
        def yetAnotherDef() = new WeatherIcon {}
      }
nvoke[ThirdParty](new MyClass)
invoke[ThirdParty](new MyClass)
import scala.reflect.runtime.universe._
trait A { type T <: A }
import scala.reflect.runtime.universe._
trait A { type T <: A }
trait B { type T <: B }
glb(typeOf[A], typeOf[B])
glb(List(typeOf[A], typeOf[B]))
res1.member(newTypeName("T"))
val p = new A with B {}
class C extends A with B
class C { def x = 2 }
class D extends C { def y = 3 }
typeOf[D].members
import scala.reflect.runtime.universe._
class C { def x = 2 }
case class D(y: Int, z: Int)
typeOf[D].members
case class C(x: Int, y: Int)
typeOf[C].members
typeOf[C].declarations
class C { def x = 2; def y = 2 }
import scala.reflect.runtime.universe._
class C { def x = 2; def y = 3 }
typeOf[C].members
typeOf[C].declarations
typeOf[C].members.sorted
typeOf[List[_]].member(newTermName("head")).asMethod
import scala.reflect.runtime.universe._
typeOf[List[_]].member(newTermName("head")).asMethod
val head = typeOf[List[_]].member(newTermName("head")).asMethod
head.paramss
import scala.reflect.runtime.universe._
class C[T] { def test[U](x: T)(y: U): Int = ??? }
val test = typeOf[C[Int]].member(newTermName("test")).asMethod
test.paramss
test.typeParams
test.returnType
test.paramss.flatten(0).typeSignature
test.paramss.flatten
test.paramss.flatten(0)
test.paramss.flatten.apply(0)
test.paramss(0)(0)
val x = test.paramss(0)(0)
x.typeSignature
test.typeSignature
x.typeSignatureIn(typeOf[C[Int]])
test.typeSignatureIn(typeOf[C[Int]])
val mt = test.typeSignatureIn(typeOf[C[Int]])
mt match { 
case MethodType(List(x), _) => x
}
val x = mt match { 
case PolyType(List(u), MethodType(List(x), MethodType(List(y), ret))) => (u, x, y, ret)
}
x.typeSignature
PolyType(List(u), MethodType(List(x), MethodType(List(y), ret))) = mt
val PolyType(List(u), MethodType(List(x), MethodType(List(y), ret))) = mt
x.typeSignature
List(1) match { case _: List[Int] => 2 }
val x: Any = List(1)
x match { case _: List[Int] => 2 }
showRaw(mt)
import scala.reflect.runtime.universe.
_
class C { def x: Int = 2 }
class D extends C { override def y: Any = "a" }
class D extends C { override def x: Any = "a" }
class D extends C { override def x: Long = 1 }
class C { def x: Any = 2 }
class D extends C { override def x: AnyRef = "x" }
typeOf[C].member(newTermName("x"))
res0.typeSignatuer
res0.typeSignature
res0.typeSignatureIn(typeOf[C])
res0.typeSignatureIn(typeOf[D])
class C[T] { def x: T = ??? }
class D extends C[Int]
typeOf[C].member(newTermName("x"))
typeOf[C[_]].member(newTermName("x"))
res6.typeSignature
res6.typeSignatureIn(typeOf[D])
res6.typeSignatureIn(typeOf[C[_]])
class C[T] { def test[U](x: T)(y: U): Int = ??? }
val test = typeOf[C[Int]].member(newTermName("test")).asMethod
showRaw(test)
showRaw(test.typeSignature)
showRaw(test.typeSignature, printIds = true)
import scala.reflect.runtime.universe._
ru.reify{ object Test { println("Hello World!") } }
reify{ object Test { println("Hello World!") } }
showRaw(res1.tree)
exit
reify(1 != 1)
val x = 0
reify(x != 0)
reify(x != 0).tree
show(reify(x != 0).tree)
trait Persisted {
  def id: Long
}
reify case class Person(first: String, last: String)
case class Person(first: String, last: String)
reify({ class C(val x: Int, val y: Int) })
case class Person(first: String, last: String)
reify { class Person$Persisted1(first: String, last: String) extends Person(first, last) with Persisted }
scala.reflect.runtime.universe.reify { class Person$Persisted1(first: String, last: String) extends Person(first, last) with Persisted }
trait Persisted { def id: Long }
scala.reflect.runtime.universe.reify { class Person$Persisted1(first: String, last: String) extends Person(first, last) with Persisted }
showRaw(res2)
scala.reflect.runtime.universe.showRaw(res2)
val x: List[_] = List(1)
T forSome { type T }
type U = T forSome { type T }
import scala.reflect.runtime.universe._
val x = 2
val tree = Apply(Select(Ident(newTermName("x")), newTermName("$plus")), List(Literal(Constant(2))))
show(tree)
showRaw(tree)
import scala.reflect.runtime.universe._
val tree = Apply(Select(Ident(newTermName("x")), newTermName("$plus")), List(Literal(Constant(2))))
show(tree)
showRaw(tree)
import scala.tools.reflect.ToolBox
val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
tb.typecheck(tree)
tb.typeCheck(tree)
"foo".length
import scala.reflect.runtime.universe._
val tree = Select(Literal(Constant("test")), newTermName("length"))
show(tree)
import scala.tools.reflect.ToolBox 
val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
tb.typeCheck(tree)
showRaw(tree)
showRaw(tree, printIds = true)
showRaw(res1, printIds = true)
showRaw(res1, printIds = true, printTypes = true)
val x = 2
def tree = reify(x + 2)
val Apply(fun, arg :: Nil) = tree
def tree = reify(x + 2).tree
val Apply(fun, arg :: Nil) = tree
object traverser extends Traverser {
def traverse(tree: Tree): Unit = {
}
object traverser extends Traverser {
  override def traverse(tree: Tree): Unit = {
    }
}
object traverser extends Traverser {
  override def traverse(tree: Tree): Unit = tree match {
    case Apply(_, _) => println("found an Apply")}}
object traverser extends Traverser {
  override def traverse(tree: Tree): Unit = {
    tree match {
      case Apply(_, _) => println("found an Apply")
      case _ => 
    }
    super.traverse(tree)
  }
}
traverse(tree)
traverser(tree)
ttree.type
ttree.tpe
val tree = Select(Literal(Constant("test")), newTermName("length"))
val ttree = tb.typeCheck(tree)
ttree.tpe
ttree.symbol
object Foo
typeOf[Foo.type].name
import scala.reflect.runtime.universe._
typeOf[Foo.type].name
typeOf[Foo.type].termSymbol.name
Apply(Select(Ident(newTermName("x")), newTermName("+").encoded), List(Literal(Constant(2))))
import scala.reflect.runtime.universe._
Apply(Select(Ident(newTermName("x")), newTermName("+").encoded), List(Literal(Constant(2))))
val x = 2
reify(x + 2)
reify(x + 2).tree
val x = 2
val tree = reify(x + 2).tree
showRaw(tree)
{ val x = 2; val tree = reify(x + 2).tree; showRaw(tree) }
{ val tree = reify(println(2)).tree; showRaw(tree) }
val x = reify(2)
val y = reify(2)
reify(x.splice + y.splice)
val prefix = reify("Scala ")
val suffix = reify("reflection")
val prefix = reify("Scala")
val suffix = reify("reflection")
reify(prefix.splice + " " + suffix.splice)
val x = reify(2)
reify(println(x.splice))
val fn = reify(println)
reify(fn.splice(2))
reify(fn.splice()(2))
val fn = reify(println _)
reify(fn.splice(2))
import scala.tools.reflect.ToolBox
val tb = runtimeMirror(getClass.getClassLoader)
tb.parse("println(2)")
val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
tb.parse("println(2)")
showRaw(tb.parse("println(2)"))
Apply(Ident(newTermName("println")), List(Literal(Constant(2))))
import scala.reflect.macros.Context
def impl(c: scala.reflect.macros.Context) = c.Expr(c.parse("println(2)"))
def impl(c: scala.reflect.macros.Context) = c.Expr[Unit](c.parse("println(2)"))
def test = macro impl
import language.experimental.macros
def test = macro impl
test
List(1, 2, 3) sliding 2
List(1, 2, 3) sliding 2 toList
List(1, 2, 3) tails
List(1, 2, 3) tails toList
List(1, 2, 3).tails.toList
import scala.reflect.runtime.universe._
class Foo { def x = 2 }
val foo = new Foo
import foo._
x
typeOf[List[Int]]
val cm = runtimeMirror(getClass.getClassLoader)
cm.staticClass("Foo")
typeOf[Foo].typeSymbol
typeOf[Foo].typeSymbol.fullName
val x = 2
typeOf[Foo].typeSymbol.typeSignature
res5.member(newTermName("x"))
foo
cm
cm.reflect(foo)
val im = cm.reflect(foo)
val mm = im.reflectMethod(x.asMethod)
val x = res5.member(newTermName("x"))
val mm = im.reflectMethod(x.asMethod)
mm()
class Foo { var x = 2 }
val foo = typeOf[Foo].typeSymbol
val x = foo.typeSignature.member(newTermName("x"))
val foo = new Foo
val im = cm.reflect(foo)
val fm = im.reflectField(x)
val fm = im.reflectField(x.asTerm)
fm.get
fm.set(3)
fm.get
foo.x
x.typeSignature
cm
exit
import scala.reflect.runtime.universe._
// scala-reflect.jar
// scala-library.jar => core jar
// scala-compiler.jar
import scala.tools.reflect.ToolBox
val cm = runtimeMirror(getClass.getClassLoader)
cm.mkToolBox
val tb = cm.mkToolBox()
tb.eval(tb.parse("2 + 2"))
Apply(Select(Literal(Constant(2)), newTermName("$plus")), List(Literal(Constant(2))))
import scala.reflect.runtime.universe._
val t = tb.parse("2 + 2")
tb.typeCheck(t)
res3.tpe
import scala.reflect.runtime.universe._
val x = 2
reify(x + 2)
showRaw(res0.tree)
class Foo
reify{ class C { def x = 2 } }
showRaw(res2.tree)
reify(x + 2)
reify(x)
reify(2)
reify(res5.splice + res6.splice)
res5.splice
reify(x + 2)
reify(res5.splice + res6.splice)
reify(List(2))
showRaw(res11.tree)
showRaw(res11.tree, printIds = true)
import scala.tools.reflect.ToolBox
val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
tb.typeCheck(res11.tree)
showRaw(res14, printIds = true)
reify(res5.splice + res6.splice)
reify(+)
reify(2)
showRaw(res17.tree)
tb
tb.parse("+")
tb.parse("2 + 2")
tb.typeCheck(res21)
val cm = runtimeMirror(getClass.getClassLoader)
val tb = cm.mkToolBox()
reify(2 + 2)
reify(if (false) 0 else 1)
reify(" hello " + "world")
abstract class Tree
case class Number(n: Int) extends Tree
case class Apply(fun: String, args: List[Tree]) extends Tree
val n5 = Number(5)
val p55 = Apply("plus", List(n5, n5))
val p55div0 = Apply("div", List(p55, Number(0)))
val zerodivp55 = Apply("div", List(Number(0), p55))
val zerodivp55div0 = Apply("div", List(Apply("div", List(Number(0), p55)), Number(0)))
def prettyprint(tree: Tree): String = tree match {
case Number(n) => n.toString
case Apply(fun, args) => fun + args.mkString("(", ", ", ")")
}
def prettyprint(tree: Tree): String = tree match {
case Number(n) => n.toString
case Apply(fun, args) => fun + args.map(prettyprint).mkString("(", ", ", ")")
}
prettyprint(n5)
prettyprint(p55)
prettyprint(p55div0)
prettyprint(zerodivp55)
prettyprint(zerodivp55div0)
def divsByZero(tree: Tree): List[Tree] = tree match {
case Number(_) => Nil
case Apply("div", List(x, Number(0))) => divsByZero(x) :+ tree
case Apply(_, args) => args.flatMap(divsByZero)
}
divsByZero(n5)
divsByZero(p55)
divsByZero(p55div0)
divsByZero(zerodiv55)
divsByZero(zerodivp55)
divsByZero(zerodivp55div0)
def mkString(trees: List[String], sep: String): String = trees match {
case Nil => ""
case hd :: tl => hd + sep + mkString(tl, sep)
}
mkString(List("1", "2"), ", ")
def mkString(ss: List[String], sep: String): String = ss match {
case Nil => ""
case s :: Nil => s
case hd :: tl => hd + sep + mkString(ss, sep)
}
mkString(List("1", "2"), ", ")
def mkString(ss: List[String], sep: String): String = ss match {
case Nil => ""
case s :: Nil => s
case hd :: tl => hd + sep + mkString(tl, sep)
}
mkString(List("1", "2"), ", ")
def flatten(trees: List[List[Tree]]): List[Tree] = trees match {
case Nil => Nil
case hd :: tl => hd ++ flatten(fl)
}
def flatten(trees: List[List[Tree]]): List[Tree] = trees match {
case Nil => Nil
case hd :: tl => hd ++ flatten(tl)
}
def flatten(trees: List[List[Tree]]): List[Tree] = trees match {
case Nil => Nil
case hd :: tl => hd ++ flatten(tl)
}
type Tree = String
def flatten(trees: List[List[Tree]]): List[Tree] = trees match {
case Nil => Nil
case hd :: tl => hd ++ flatten(tl)
}
flatten(List(List("1"), List("1", "2")))
import scala.reflect.runtime.universe._
val TypeRef(optType, optClass, dummyArgs) = typeOf[Option[Any]]
def foo[U <: Universe with Singleton](t: U # Tree) = ???
import scala.reflect.runtime.universe._
def foo[U <: Universe with Singleton](t: U # Tree) = ???
import scala.reflect.api._
def foo[U <: Universe with Singleton](t: U # Tree) = ???
foo(Ident("x"))
def foo[U <: Universe](t: U # Tree) = ???
foo(Ident("x"))
def foo(t: u.Tree forSome { val u: Universe }) = ???
foo(Ident("x"))
def foo(t: u.Tree forSome { val u: Universe }) = ()
foo(Ident("x"))
def foo[U <: Universe](t: U # Tree) = ()
foo(Ident("x"))
import scala.reflect.api._
import scala.reflect.runtime.universe._
def foo(x: Universe # Tree) = ???
def foo(x: Universe # Tree) = x match {
import scala.reflect.api.Universe
import scala.reflect.api.Trees._
def foo(x: Universe # Tree) = x match {
case Universe # Ident(_) => ???
brew search tree
def foo(x: Universe # Tree) = x match {
case Universe # Ident(_) => ???
def foo(tree: Universe # Tree) = tree match {
import scala.reflect.runtime.universe._
Ident("x")
res0.$outer
res0.getClass
res0.getClass.getDeclaredMethods
res0.getClass.getDeclaredMethods foreach (m => println(m.getName))
res0.getClass.getDeclaredMethod("scala$reflect$internal$Trees$Ident$$$outer")
res5.invoke(res0)
import scala.reflect.runtime.universe._
typeOf[Int]
lub(typeOf[Int], typeOf[String])
lub(List(typeOf[Int], typeOf[String]))
}
import scala.reflect.runtime.universe._
val cm = runtimeMirror(getClass.getClassLoader)
cm.reflect(f).symbol
cm.reflect(f).symbol.typeSignature
def typeOf[T: TypeTag](x: T) = typeOf[T]
def typeOf[T: TypeTag](x: T) = ru.typeOf[T]
def typeOf[T: TypeTag](x: T) = scala.reflect.runtime.universe.typeOf[T]
typeOf(f)
typeOf[Int]
def typeOf[T: TypeTag] = scala.reflect.runtime.universe.typeOf[T]; def typeOf[T: TypeTag](x: T) = scala.reflect.runtime.universe.typeOf[T]
typeOf[Int]
typeOf(f)
import scala.reflect.runtime.{universe => ru}
def typeOf[T: ru.TypeTag](x: T) = ru.typeOf[T]
typeOf(f)
val mt = typeOf(f)
val MethodType(param :: Nil, ret) = mt
showRaw(mt)
import scala.reflect.runtime.{universe => ru}
def typeOf[T: ru.TypeTag](x: T) = ru.typeOf[T] // capture compile-time type info
val tpe = typeOf(f)
val f = (r: {val s: String}) => {}
val tpe = typeOf(f)
showRaw(tpe)
ru.showRaw(tpe)
val TypeRef(_, _, refinement :: _) = tpe
val ru.TypeRef(_, _, refinement :: _) = tpe
import scala.reflect.runtime.{universe => ru}
import scala.reflect.runtime.universe._
def typeOf[T: ru.TypeTag](x: T) = ru.typeOf[T] // capture compile-time type info
val f = (r: {val s: String}) => {}
val tpe = typeOf(f)
ru.showRaw(tpe)
val ru.TypeRef(_, _, refinement :: _) = tpe
1 #: 2
import Stream._
1 #:: empty
res1.toList
1 #:: 2
1 #:: Stream(2)
res1.tail
res2.tail
typeOf[List[_]].typeSymbol
import scala.reflect.runtime.universe._
typeOf[List[_]].typeSymbol
class D[T] { def m: T = ??? }
scala> import scala.reflect.runtime.{universe => ru}
import scala.reflect.runtime.{universe=>ru}
scala> import scala.reflect.runtime.universe._
import scala.reflect.runtime.universe._
scala> def typeOf[T: ru.TypeTag](x: T) = ru.typeOf[T] // capture compile-time type info
typeOf: [T](x: T)(implicit evidence$1: reflect.runtime.universe.TypeTag[T])reflect.runtime.universe.Type
scala> val f = (r: {val s: String}) => {}
f: AnyRef{val s: String} => Unit = <function1>
scala> val tpe = typeOf(f)
tpe: reflect.runtime.universe.Type = scala.AnyRef{val s: String} => Unit
scala> ru.showRaw(tpe)
res0: String = TypeRef(ThisType(scala), scala.Function1, List(RefinedType(List(TypeRef(ThisType(scala), newTypeName("AnyRef"), List())), Scope(newTermName("s"))), TypeRef(ThisType(scala), scala.Unit, List())))
scala> val ru.TypeRef(_, _, refinement :: _) = tpe
refinement: reflect.runtime.universe.Type = scala.AnyRef{val s: String}
import scala.reflect.runtime.{universe => ru}
import scala.reflect.runtime.universe._
def typeOf[T: ru.TypeTag](x: T) = ru.typeOf[T]
val f = (r: {val s: String}) => {}
val tpe = typeOf(f)
ru.showRaw(tpe)
val ru.TypeRef(_, _, refinement :: _) = tpe
import scala.tools.reflect.ToolBox
val tb = ru.runtimeMirror(getClass.getClassLoader).mkToolBox()
val ru.RefinedType(_, decls) = refinement
val context = Map("s" -> "hello")
def declsToSyntheticClassDef(decls: List[Symbol]): ClassDef = {
ClassDef(NoMods, newTypeName("C"), Nil, Template(Nil, emptyValDef, decls map (decl => {
ValDef(NoMods, decl.name, TypeTree(decl.typeSignature), Ident(build.newFreeTerm(decl.name.toString, decl.typeSignature, context(decl.name.toString)))
}
def declsToSyntheticClassDef(decls: List[Symbol]): ClassDef = {
ClassDef(NoMods, newTypeName("C"), Nil, Template(Nil, emptyValDef, decls map (decl => {
ValDef(NoMods, decl.name, TypeTree(decl.typeSignature), Ident(build.newFreeTerm(decl.name.toString, decl.typeSignature, context(decl.name.toString)))
})
def declsToSyntheticClassDef(decls: List[Symbol]): ClassDef = {
ClassDef(NoMods, newTypeName("C"), Nil, Template(Nil, emptyValDef, decls map (decl => {
ValDef(NoMods, decl.name, TypeTree(decl.typeSignature), Ident(build.newFreeTerm(decl.name.toString, decl.typeSignature, context(decl.name.toString))))
})))
}
def declsToSyntheticClassDef(decls: List[Symbol]): ClassDef = {
ClassDef(NoMods, newTypeName("C"), Nil, Template(Nil, emptyValDef, decls map (decl => {
ValDef(NoMods, decl.name.toTermName, TypeTree(decl.typeSignature), Ident(build.newFreeTerm(decl.name.toString, decl.typeSignature, context(decl.name.toString))))
})))
}
def declsToSyntheticClassDef(decls: List[Symbol]): ClassDef = {
ClassDef(NoMods, newTypeName("C"), Nil, Template(Nil, emptyValDef, decls map (decl => {
  def referenceContext(name: String) = {
    val freeTerm = build.newFreeTerm(decl.name.toString, context(decl.name.toString))
    build.setTypeSignature(freeTerm, decl.typeSignature)
  }
  ValDef(NoMods, decl.name.toTermName, TypeTree(decl.typeSignature), Ident(referenceContext(decl.name.toString)))
})))
}
declsToSyntheticClassDef(decls)
declsToSyntheticClassDef(decls.toList)
decls.toList(0)
showRaw(decls.toList(0).typeSignature)
decls.toList(0).typeSignature
def declsToSyntheticClassDef(decls: List[Symbol]): ClassDef = {
ClassDef(NoMods, newTypeName("C"), Nil, Template(Nil, emptyValDef, decls map (decl => {
  val NullaryMethodType(typeOfVal) = decl.typeSignature
  val refToContextVal = build.newFreeTerm(decl.name.toString, context(decl.name.toString))
  build.setTypeSignature(refToContextVal, typeOfVal)
  ValDef(NoMods, decl.name.toTermName, TypeTree(decl.typeSignature), Ident(refToContextVal))
})))
}
  ValDef(NoMods, decl.name.toTermName, TypeTree(decl.typeSignature), Ident(refToContextVal))
declsToSyntheticClassDef(decls.toList)
reify({ class C; new C })
import scala.reflect.runtime.universe._
reify({ class C; new C })
reify({ class C; new C; () })
showRaw(res2.tree)
import scala.reflect.macros.Context
class Helper[C <: Context with Singleton](val c: C) {
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper[c.type](c)
c.Expr(helper.generate)
}
class Helper[C <: Context](val c: C) {
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper[c.type](c)
c.Expr(helper.generate)
}
import scala.reflect.runtime.universe._
val t = reify ( (_: List[Any]).contains(null) ).tree
showRaw(t, printIds = true)
import scala.reflect.runtime.universe._
val t = reify ( (_: List[Any]).contains(null) ).tree
exit
import scala.reflect.runtime.universe._
val t = reify ( (_: List[Any]).contains(null) ).tree
showRaw(t, printIds = true)
import scala.reflect.runtime.universe._
showRaw(t, printIds = true)
val t = reify ( (_: List[Any]).contains(null) ).tree
showRaw(t, printIds = true)
2
Ident
cm
exit
ru
Ident
1
2
reify(ru).eval
import scala.util.continuations
reset
shift
List(1, 2).dis
List(1, 2).distinct
List(1, 1, 2).distinct
{ class B(b:Int); typeTag[B] }
{ class B(b:Int); weakTypeTag[B] }
exit
{ class B(b:Int); weakTypeTag[B] }
exit
{ class B(b:Int); typeTag[B] }
reify(List(1, 2))
exit
reflect.runtime.universe.reify { trait Foo { val a: Int } }
exit
reflect.runtime.universe.reify { trait Foo { val a: Int } }
exit
reflect.runtime.universe.reify { trait Foo { val a: Int } }
exit
reflect.runtime.universe.reify { trait Foo { val a: Int } }
exit
reflect.runtime.universe.reify { trait Foo { def a: Int } }
reflect.runtime.universe.reify { trait Foo { val a: Int } }
def f[A,B,C,D]:((A,B)) => (C,D) = ???
typeOf[f]
def typeOf[T: TypeTag](x: T) = typeOf[T]
def typeOf[T: TypeTag](x: T) = ru.typeOf[T]
typeOf(f)
typeOf(f _)
def typeOf[T: TypeTag](x: T) = ru.typeOf[T]
class C { def f[A,B,C,D]:((A,B)) => (C,D) = ???; print(typeOf(this.f)) }
new C
class C { def f[A,B,C,D]:((A,B)) => (C,D) = ???; print(typeOf(this.f _)) }
class C { def f[A,B,C,D]():((A,B)) => (C,D) = ???; print(typeOf(this.f _)) }
new C
class C { def f[A,B,C,D]():((A,B)) => (C,D) = ??? }
typeOf[C].member(newTermName("f")).typeSignature
class C { def f[A,B,C,D]():((A,B)) => (C,D) = ??? }
typeOf[C].member(newTermName("f")).typeSignature
class C { def f[A,B,C,D]:((A,B)) => (C,D) = ??? }
typeOf[C].member(newTermName("f")).typeSignature
class C { def g[A,B]: ((A,B)) = ??? }
typeOf[C].member(newTermName("g")).typeSignature
def g[A,B]: ((A,B)) = ???
showRaw(res0)
showRaw(res1)
List(1, 2).mkString
def pp(x: Int) = x
List(1, 2) map pp
List(1, 2).map(pp(_))
for (t <- List(1, 2)) yield List(t)
for (t <- List(1, 2)) yield Nil
for (i <- 0 until 2) yield 1
List(1, 2).foldLeft(_ + _)
List(1, 2).foldLeft(0)(_ + _)
List().foldLeft
List().foldLeft _
List().foldLeft[String] _
List[Int]().foldLeft[String] _
type Tree = Int
def prettyprint(tree: Tree): String = ""
List[Tree]().foldLeft("")(_ + ", " + prettyprint(_))
List[Tree]().foldLeft("")(prettyprint(_) + ", " + prettyprint(_))
reify(ru)
showRaw(ru)
showRaw(res0)
showRaw(res0, printIds = true)
{ class C; typeOf[C] }
exit
{ class C; typeOf[C] }
exit
type Tree = Int
def prettyprint(x: Tree): String = ""
List[Tree]().foldLeft("")(_ + "," + prettyprint(_))
type Tree = String
def divsByZero(tree: Tree): List[Tree] = Nil
List[Tree]().foldRight(Nil)(divsByZero(_) :: _)
List[Tree]().foldRight(Nil)(divsByZero(_) :+ _)
List[Tree]().foldRight(Nil)(_ +: divsByZero(_))
List[Tree]().foldRight(List[Tree]())(_ +: divsByZero(_))
List[Tree]().foldRight(List[Tree]())(divsByZero(_) :+ _)
List[Tree]().foldRight(List[Tree]())(divsByZero(_) :: _)
List[Tree]().foldRight(List[Tree]())(divsByZero(_) ::: _)
s"""${"""a"""}"""
  def id[T]: T => T
  def compose[A, B, C](f: B => C, g: A => B): A => C
}
trait PairCategory[F[_,_]] extends Category[F] {
  def affix[A, B, C, D](f: A => B, g: C => D): (A, B) => (C, D)
}
trait Circuitry[F[_,_]] extends PairCategory[F] {
  def passr[A, B, X](f: A => B): (A, X) => (B, X)
  def passl[X, C, D](g: C => D): (X, C) => (X, D)
  override def affix[A, B, X, Y](f: A => B, g: X => Y): (A, X) => (B, Y) = {
    compose[(A, X), (B, X), (B, Y)](passl[B, X, Y](g), passr[A, B, X](f))
  }
}
def foo = macro impl
type Foo(x: Int) = Int
class C { type Foo <: macro Impl }
type Foo(x: Int) = Int
type Foo(x: Int)
type Foo(x: Int) = ???
type Foo(x: Int) = macro ???
type Foo(x: Int)
type Foo(x: Int) = macro ???
type Foo(x: Int)
=
...
type Foo + Bar
type Foo(x: Int)
=
d
type Foo(x: Int) +
type Foo(x: Int) = Int
type Foo: Int = Int
type Foo(x: Int) = macro impl
exit
typeOf[Macros]
classOf[Macros]
classOf[Macros.type]
classOf[Int]
type X = Macros
X
type X = Macros1
Macros.impl
exit
Macros.impl
exit
MyMacors
MyMacros
typeOf[MyMacros.type]
typeOf[MyMacros.type].typeSymbol
typeOf[MyMacros.type].members
typeOf[MyMacros.type].members.toList(0)
res5.name
res5.name.isTypeName
typeOf[Macros.type].members
typeOf[MyMacros.type].members
typeOf[MyMacros.type].members.toList(0)
typeOf[MyMacros.type].members.toList(0).name
typeOf[MyMacros.type].members.toList(0).name.isTypename
typeOf[MyMacros.type].members.toList(0).name.isTypeName
def foo[+T] = ???
def sc
)))
def foo
def f(x: Int) = 0 
val g = ru.reify(f _) 
ru.reify(g.splice _) 
val g1 = f _
val  g2 = g1 _
type Foo[+T] = macro ???
type Foo[+T] = Int
type Foo[+T] = macro bar
)
type Foo[+T] = macro ???
def foo
type Foo = { def x = 2 }
type Foo = { type Qqq(x: Int) = macro ??? }
type T = Int
type T[U] = Int
type T[+U] = Int
type T[U: List] = Int
type T[U, W: List] = Int
type T[+U]() = Int
type T[+U]: Int = Int
type T[U]: Int = Int
type T[U](): Int = Int
def foo = macro impl
ru
reify{ @deprecated("", "") def foo = 2 }
showRaw(res0)
typeOf[Macros].members.toList
typeOf[Macros.type].members.toList
typeOf[Macros.type].members.toList(1)
res2.annotations
typeOf[Macros.type].members.toList(1).annotations
exit
class X(x: Int)
class C extends X(2)
class C extends X(2) with X(3)
def impl(c: Context) = { c.info(c.universe.NoPosition, "hello", force = true); c.literalUnit }
def foo = macro impl
foo
def foo(f: String => Array[String])(s: String) = ()
foo _
foo(Array(_))
foo(Array(_)) _
def foo(f: String => Array[String])(s: String) = ()
foo(Array(_)) _
def foo(f: String => Array[String])(s: String) = ()
foo(Array(_)) _
def impl(c: Context) = c.literalUnit
def foo = macro impl
foo _
res0
res0()
() _
def impl(c: Context)(x: c.Expr[Int]) = c.literalUnit
def foo(x: Int) = macro impl
foo _
stree
exit
val test = foo(Array(_)) _
def foo(f: String => Array[String])(s: String) = f(s)
val test = foo(Array(_)) _
test("x")
exit
def foo = ???
reify(foo _)
class C(x: Int, y: Int)
class D(x: Int, y: Int) extends C(x, y)
{ def z(x: Int) = x; reify(z _) }
{ def z = 2; reify(z _) }
import scala.tools.reflect.Eval
{ def z = 2; reify(z _).eval }
res2()
{ def z = 2; reify(z).eval }
val x = { self: String => }
trait U
class C extends {} with U
class C extends { self: U => } with U
3 +: List(1, 2)
class B(x: Int)
class C extends B(2, 2)
class C[T: List] extends B(2, 2)
def foo(x: Int) = x
exit
typeOf[Macros.type].members
typeOf[Macros.type].members.toList(0)
typeOf[Macros.type].members.toList(0).name
typeOf[Macros.type].members.toList(0).name.isTerm
typeOf[Macros.type].members.toList(0).name.isTermName
exit
def impl[T: c.WeakTypeTag](c: Context) = c.literalUnit
def foo[T] = macro impl[T]
foo
def foo(a: Int, b: Int = 0) = a
def foo(a: Double, b: Int = 0) = a
{ def foo(a: Int, b: Int = 0) = a; def foo(a: Double, b: Int = 0) = a }
class C{ def foo(a: Int, b: Int = 0) = a; def foo(a: Double, b: Int = 0) = a }
kep
{ type 
{ type Foo = Any; }
{ type Foo <: Any }
class Arrrr[A](initSize: Int) { new Array[A](2) }
class Arrrr[A](initSize: Int) { def init(initSize: Int) { new Array[A](initSize) } }
class Arrrr[A](initSize: Int) { def init(initSize: Int) { var it = new Array[A](initSize) } }
class ArrayUser[A /*: ClassTag*/](initSize:Int) {
  var it: Array[A] = _
  initIt(initSize)
  def initIt(initSize:Int) { it = new Array[A](initSize) }
}
  val ff = u.reify {
    def f(x:Int):Int = x*2
    f _
  }
  println(u showRaw ff)
  import scala.tools.reflect.Eval
  def g = ff.eval
  println(g)
  println(g(3))
val ff = reify { def f(x: Int): Int = x * 2; f _ }
println(showRaw(ff)
)
ff.eval
val ff = reify { def f(x: Int): Int = x * 2; x => f(x) }
ff.eval
val ff = reify { def f(x: Int): Int = x * 2; (x: Int) => f(x) }
ff.eval
res6
res6(3)
reify { def f(x: Int) = x; f _ }
res0.eval
reify { def f(x: Int) = x; x => f(x) }
res2.eval
reify { def f(x: Int) = x; x => f(x) }
showRaw(res4)
res4.eval
reify { def f(x: Int) = x; f _ }
showRaw(res7)
res7.eval
exit
class C extends Foo[Int]("2")
class C extends Macros.Foo[Int]("2")
new C().toString
new C.toString
exit
class C extends Foo[Int]("2")
class C extends Macros.Foo[Int]("2")
new C
class C
new C
new C()
class C extends Foo[Int]("2")
class C extends Macros.Foo[Int]("2")
new C
new C().hello
class C extends Macros.Foo[Int]("2")
new C().hello
class C extends Macros.Foo[Int]("2")
new C().hello
class C extends AnyRef with Macros.Foo[Int]("2")
class C extends AnyRef() with Macros.Foo[Int]("2")
exit
class C extends AnyRef with Macros.Foo[Int]("2")
new C().hello
class C extends AnyRef with Macros.Foo[Int]("2")
new C().hello
exit
{ val z = () => 2; reify(z) }
res0.eval
{ def z() = 2; val zz = z _; reify(zz) }
res0.eval
{ def z() = 2; reify(z()) }
res4
res4.eval
class C extends AnyRef with Macros.Foo[Int]("2")
new C().hello
exit
object foo
object =.
object =>
object <=>
val _ = 2
object _
_
object *
:power
Ident(newTermName("x"))
res0 == res1
res0.equalsStructure(res1)
class B[T]
class C extends B
trait Foo extends B;
class C extends B;
class B[T](x: T)
new { val x = 2 } with B(x)
foo.super[bar[
foo.super[bar]
cm.staticPackage("foo")
def foo(c: Context) = c.literal(c.mirror.staticPackage("foo"))
def foo(c: Context) = c.literal(c.mirror.staticPackage("foo").toString)
def bar = macro foo
bar
class C
new C
exit
class C[T]
class C[T](x: T)
class C[T]
trait Foo[T] extends C[T]
class X extends Foo
:power
NoSymbol.initialize
class C
class D extends C
class E extends D with C
class C
new (C)
new (C)()
val x = List(1, 2, 3)
val init :+ last = x
trait T
class C extends T()
class C extends AnyRef with T()
trait T
class C extends T()()
class C(x: Int)
new { val x = 2 } with C(x: Int)
res0.x
}}
trait Wrapper[T](x : T) {}
trait Foo <: Int
trait Bar
trait Foo <: Bar
trait Foo extends { val x = 2 } with Bar
trait Foo extends { val x = 2 } with Bar(2)
trait Bar
trait Foo extends { val x = 2 } with Bar(2)
class C(x: Int)
trait T extends C(2)
class C(x: Int)
trait T extends C(2)
exit
class C(x: Int)
trait T extends C(2)
    object HasStuff extends Dynamic {
      def selectDynamic(name: String): String = s"I have $name!"
    }
HasStuff.foo
class C extends HasStuff.foo
trait T
class C extends T(2)
class C
class D extends AnyRef with C
trait Bar
trait Foo extends { val x = 2 } with Bar(2)
trait Bar
trait Foo extends { val x = 2 } with Bar(2)
trait Bar
trait Foo extends { val x = 2 } with Bar(2)
exit
trait Bar
trait Foo extends { val x = 2 } with Bar(2)
trait T
class C extends T
class C extends T()
exit
trait T
class C extends T
class C extends T()
new T {}
new T
new T() {}
new C
new C()
exit
class C
new C
new C()
class C
class C()
new C
case class C()
new C
new C with C
new C {}
trait T
new C with T {}
new C with T
case class Reset[+A]()
trait Undoable
new Reset with Undoable
case class Reset
trait Undoable
new Reset with Undoable
case class Reset[+A]()
new Reset
case class Reset[+A]()
trait Undoable
new Reset with Undoable
class C[T]
new C
exit
Apply(Select(Super(This(tpnme.EMPTY), tpnme.EMPTY), nme.CONSTRUCTOR)), List())
Apply(Select(Super(This(tpnme.EMPTY), tpnme.EMPTY), nme.CONSTRUCTOR))), List())
Apply(Select(Super(This(tpnme.EMPTY), tpnme.EMPTY), nme.CONSTRUCTOR)))), List())
Apply(Select(Super(This(tpnme.EMPTY), tpnme.EMPTY), nme.CONSTRUCTOR)), List())
Apply(Select(Super(This(tpnme.EMPTY), tpnme.EMPTY), nme.CONSTRUCTOR), List())
exit
class C
new C
exit
val ids = collection.mutable.ListBuffer[Ident]()
reify("hey".format((ids.map(id => Expr(id).eval)) : _*))
def foo(c: Context) = {
import c.universe._
val ids = collection.mutable.ListBuffer[Ident]()
c.reify("hey".format((ids.map(id => Expr(id).eval)) : _*))
}
def foo(c: Context) = {
import c.universe._
val ids = collection.mutable.ListBuffer[Ident]()
c.universe.reify("hey".format((ids.map(id => Expr(id).eval)) : _*))
}
def foo(c: Context) = {
import c.universe._
val ids = collection.mutable.ListBuffer[Ident]()
c.universe.reify("hey".format((ids.map(id => c.Expr(id).eval)) : _*))
}
def foo(c: Context) = {
import c.universe._
val ids = collection.mutable.ListBuffer[Ident]()
c.universe.reify("hey".format((ids.map(id => c.Expr(id).splice)) : _*))
}
reify{ new Object().getClass }
reify(manifest[Some[_]])
reify({ val (x, y) = ("abc": Any) match { case x => (x, x) } })
reify({ val (x, y) = "abc" match { case x => (x, x) } })
val List(x: _*) = List(1, 2)
List(1, 2) match {
case List(x: _*) => x
val List(x @ _*) = List(1, 2)
val List(x @ _**) = List(1, 2)
def _** (x: Int) = ???
def *_ (x: Int)
EmptyBoundsTree
EmptyBounds
(0 to 10).map(i => Ident(newTermName("i")))
exit
object foo { def unapply[T](x: T): Option[T] = Some(x) }
val foo(x) = 1
object foo { def unapply[T](x: T): Option[T] = Some(x) }
val foo(x: Int) = 1
val foo(x: String) = 1
object foo { object bar { def unapply[T](x: T): Option[T] = Some(x) } }
val foo.bar(x) = 1
object foo { object bar { def unapply[T](x: T)(implicit y: Int): Option[T] = Some(x) } }
implicit val y = 3
val foo.bar(x) = 1
object foo { object bar { def unapply[T](x: T)(implicit y: Int): Option[T] = Some(y) } }
object foo { object bar { def unapply[T](x: T)(implicit y: Int): Option[T] = Some(y.asInstanceOf[T]) } }
implicit val y = 3
val foo.bar(x) = 1
type Foo = List[Int]
val x: Foo(2) = ??
val x: List[Int][Int] = ???
type Foo[T] = List
type Foo[T] = { type Qwe[T] = List[T] } # Qwe
type Foo[T] = { type Qwe[T] = List[T] }
type Foo[T] = ({type Qwe[T] = List[T]}#Qwe
type Foo[T] = ({type Qwe[T] = List[T]}#Qwe)
type T = Int
val x: T(2) = ???
class C(x: T(2))
def foo(x: T(2))
= ???
exit
case class C(x: Int)
exit
showRaw(reify(ru.tree))
showRaw(reify(ru.Tree))
showRaw(reify { type X[T1, T2] = Tuple2[T1, T2] })
def impl(c: Context) = { import c.universe._; c.Ident("Int") }
def impl(c: Context) = { import c.universe._; Ident("Int") }
def t = macro impl
type t = macro impl
class C extends t
def foo(x: Int) = println(x)
(0 to 10).foreach(foo)
def foo(x: Int): Unit = println(x)
(0 to 10).foreach(foo)
exit
def foo[T] = { import T => U; ??? }
class C { type T }
def foo(c: C) = { import c.{T => U}; ??? }
class foo extends scala.annotation.StaticAnnotation
class C { self: C @foo => }
typeOf[C]
typeOf[C].typeSymbol.asClass.selfType
def impl[T: c.WeakTypeTag](c: Context) = { println(c.weakTypeOf[T]); c.literalUnit }
class C[T]
def impl[T: c.WeakTypeTag](c: Context) = { println(c.weakTypeOf[T]); c.Expr[C[T]](c.Literal(c.Constant(null)) }
def impl[T: c.WeakTypeTag](c: Context) = { println(c.weakTypeOf[T]); c.Expr[C[T]](c.Literal(c.Constant(null))) }
def impl[T: c.WeakTypeTag](c: Context) = { println(c.weakTypeOf[T]); c.Expr[C[T]](c.universe.Literal(c.universe.Constant(null))) }
class C[T]
def impl[T: c.WeakTypeTag](c: Context) = { println(c.weakTypeOf[T]); c.Expr[C[T]](c.universe.Literal(c.universe.Constant(null))) }
implicit def foo[T]: C[T] = macro impl[T]
implicitly[C[Int]]
exit
class C[T]
def impl[T: c.WeakTypeTag](c: Context) = { println(c.weakTypeOf[T]); c.Expr[C[T]](c.universe.Literal(c.universe.Constant(null))) }
implicit def foo[T]: C[T] = macro impl[T]
implicitly[C[Int]]
foo[Int]
reify { case class C }
reify { case class C } .eval
reify { case class C(x: Int) } .eval
reify { case class C(x: Int); println(C(2)) } .eval
reify { case class C(x: Int); println(C(2)) }
exit
class Lift {
  def apply(f: F0) {}
  class F0
  object F0 {
    implicit def f2f0(fn: String): F0 = ???
  }
}
val l = new Lift
l.apply("")
val x: (Int) = 2
class foo extends scala.annotation.StaticAnnotation
val x: Int @(foo) = 2
val x: Int @(foo(2)) = 2
class foo extends scala.annotation.StaticAnnotation
class C @foo (x: Int)
class C @foo() (x: Int)
def impl(c: Context) = c.Ident("Int")
def impl(c: Context) = c.universe.Ident(c.universe.newTermName("Int"))
type Hey = macro impl
val x: Hey = 2
def impl(c: Context) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey = macro impl
val x: Hey = 2
type Foo = Int
exit
def impl(c: Context) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey = macro impl
def foo = macro impl
def impl2(c: Context) = c.literalUnit
def foo2 = macro impl2
exit
def impl(c: Context) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey = macro impl
{ type Foo = Int; val x: Foo = 2 }
{ type Foo; val x: Foo = 2 }
def impl(c: Context) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey = macro impl
def impl(c: Context) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey = macro impl
type Foo = Int
def impl(c: Context) = c.literalUnit
def foo = macro impl
def impl(c: Context) = c.literalUnit
def impl(c: Context) = c.universe.Ident(c.universe.newTypeName("Int"))
type Foo = Int
type Hey = macro impl
def impl(c: Context) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey = macro impl
exit
def impl(c: Context) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey = macro impl
exit
def impl(c: Context) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey = macro impl
def impl2(c: Context) = c.literalUnit
def foo2 = macro impl2
def impl3(c: Context)(x: c.Expr[Int]) = c.literalUnit
def foo3 = macro impl3
def foo3(x: Int) = macro impl3
def foo3(x: Int) = ???
def impl3(c: Context)(x: c.Expr[Int]) = c.literalUnit
def foo3(x: Int) = macro impl3
def impl3(c: Context)(x: c.Expr[Int]) = c.literalUnit
def foo3(x: Int) = macro impl3
def impl3(c: Context)(x: c.Expr[Int]) = c.literalUnit
def foo3(x: Int) = macro impl3
def impl3(c: Context)(x: c.Expr[Int]) = c.literalUnit
def foo3(x: Int) = macro impl3
def impl3(c: Context)(x: c.Expr[Int]) = c.literalUnit
def foo3(x: Int) = macro impl3
def impl(c: Context) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey = macro impl
def impl(c: Context) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey = macro impl
def impl(c: Context) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey = macro impl
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey(x: Int) = macro impl
val x: Hey(2) = 2
exit
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.newTypeName("Int"))
val x: Hey(2) = 2
type Hey(x: Int) = macro impl
val iw = $line9.$read.$iw.$iw.$iw.$iw.$iw.$iw.$iw.$iw.$iw.$iw
val x: iw.Hey(2) = 2
case class C
C(2)
def impl(c: Context)(x: c.Expr[Int]) = x
def foo = macro impl
foo
def impl(c: Context) = c.literalUnit
def foo = macro impl
foo
def x = 2
x
C
def x = 2
def impl(c: Context) = c.literalUnit
def foo = macro impl
foo
def impl(c: Context) = c.literalUnit
def foo = macro impl
def impl(c: Context) = c.literalUnit
def foo = macro impl
foo
def impl(c: Context) = c.literalUnit
def foo = macro impl
foo
def impl(c: Context) = c.literalUnit
def foo = macro impl
foo
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey(x: Int) = macro impl
val x: Hey(2) = 2
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey(x: Int) = macro impl
val x: Hey(2) = 2
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey(x: Int) = macro impl
val x: Hey(2) = 2
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey(x: Int) = macro impl
val x: Hey(2) = 2
def impl(c: Context) = c.literalUnit
foo
def foo = macro impl
foo
def impl(c: Context) = c.literalUnit
def foo = macro impl
foo
def impl(c: Context) = c.literalUnit
def foo = macro impl
def impl(c: Context) = c.literalUnit
def foo = macro impl
foo
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey(x: Int) = macro impl
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey(x: Int) = macro impl
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey(x: Int) = macro impl
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey(x: Int) = macro impl
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey(x: Int) = macro impl
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey(x: Int) = macro impl
val x: Hey(2) = 2
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey(x: Int) = macro impl
val x: Hey(2) = 2
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.newTypeName("Int"))
type Hey(x: Int) = macro impl
val x: Hey(2) = 2
def foo() = ()
implicit class Foo(x: Int) { type Foo = Int }
2.Foo
(new Foo(2)).Foo
val c = new { type Foo = Int }
val x: c.Foo = 2
class Lift {
  def apply(f: F0) {}
  class F0
  object F0 {
    implicit def f2f0(fn: String): F0 = ???
  }
}
val l = new Lift
l.apply("")
typeOf[Anno].declarations.toList
res0(0).typeSignature.declarations
res0(1).typeSignature.declarations
typeOf[Anno].typeSymbol.companionSymbol
res3.typeSignature
res3.typeSignature.declarations
res5.toList(0) == res0(1)
res3.typeSignature.declarations.toList(0)
res3.typeSignature.declarations.toList
val cds = typeOf[Anno].declarations.toList
val ods = typeOf[Anno].typeSymbol.companionSymbol.declarations.toList
val ods = typeOf[Anno].typeSymbol.companionSymbol.typeSignature.declarations.toList
cds(0).typeSignature
cds(0).typeSignature.declarations
ods(0).typeSignature
ods(0).typeSignature.declarations
typeOf[Iface]
typeOf[Iface].declarations
typeOf[Iface].typeSymbol.companionSymbol.typeSignature.declarations
exit
def impl(c: Context)(x: c.Expr[Int]) = {
import c.universe._
println(showRaw(x, printIds = true))
println(showRaw(c.resetAllAttrs(x), printIds = true))
println(showRaw(x, printIds = true))
c.literalUnit
}
def impl(c: Context)(x: c.Expr[Int]) = {
import c.universe._
println(showRaw(x, printIds = true))
println(showRaw(c.resetAllAttrs(x.tree), printIds = true))
println(showRaw(x, printIds = true))
c.literalUnit
}
def foo(x: Int) = macro impl
foo(2)
val x = 2
foo(x)
def impl(c: Context) = c.universe.Ident(c.universe.newTermName("foo"))
type foo = macro impl
def impl(c: Context) = c.universe.Ident(c.universe.newTermName("foo"))
type foo = macro impl
def impl(c: Context) = c.universe.Ident(c.universe.newTermName("foo"))
type foo = macro impl
def impl(c: Context) = c.universe.Ident(c.universe.newTermName("foo"))
type foo = macro impl
def impl(c: Context) = c.universe.Ident(c.universe.newTypeName("Int"))
val macros = new { type Foo(x: Int) = macro Impls.foo }
{ val macros = new { type Foo(x: Int) = macro Impls.foo }; val x: macros.Foo(2) = 2 }
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.newTypeName("Int"))
type foo(x: Int) = macro impl
val x: foo(3) = 2
val x: foo("3") = 2
exit
type Foo(x: Int);
type Foo;
exit
type Foo(x: Int);
type Foo(x: Int) = foo
type Foo(x: Int)
def foo
class Foo { def foo }
{ type Foo
}
type Foo()
type Foo(x: Int) hey
exit
type Foo[
Int]
(x: Int)
type Foo[T](x: Int)
type Foo[Int]
def foo[T[_]] = ???
foo[Int]
exit
"aa" dropRight 1
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = {
import c.universe._
Ident(newTypeName("Int"))
}
type Foo(x: Int)(y: Int) = macro impl
type T = Foo(2)(3)
val x: T = 2
type T = Foo(2)
type T = Foo(2)(3)(4)
exit
0 to 5
1 to 5
class C extends scala.annotation.StaticAnnotation
@(C @C) class D
class C
class D extends C
trait T1 { type T = C }
trait T2 { type T = D }
trait T2 extends T1 { type T = D }
trait T2 extends T1 { override type T = D }
trait T1 { class T }
trait T2 extends T1 { type T = C }
trait T2 extends T1 { override type T = C }
exit
trait T1 { type T <: Int }
def impl(c: Context) = c.universe.Ident(c.universe.newTypeName("C"))
trait T1 { type T = macro impl }
def impl(c: Context) = c.literalUnit
trait T1 { def x: Unit }
trait T2 extends T1 { def x = macro impl }
trait T1 { type T <: Int }
trait T2 extends T1 { type T = macro impl }
def impl(c: Context) = c.universe.Ident(c.universe.newTypeName("C"))
trait T2 extends T1 { type T = macro impl }
trait T1 { type T <= Int }
trait T1 { type T = Int }
trait T2 extends T1 { type T = macro impl }
exit
trait T { abstract override type U }
trait T { type U }
trait T1 extends T { abstract override type U = Int }
exit
trait T1 { type T[U] <: Int }
trait T2 extends T1 { type T = Int }
exit
class C
new C().getClass.getSimpleName
new C().getClass.getName
classOf[scala.reflect.api.Trees#TreeApi]
classOf[scala.reflect.api.Trees#TreeApi].getSimpleName
"".toLowerCase
List(2).flatMap(2 => Some(3))
List(2).flatMap(x => Some(3))
List(2).flatMap(x => None)
class foo(x: Int)
def foo() = 2
foo
exit
trait T
class D
class C extends D with T()
trait T1 { class T }
trait T2 extends T1 { type T }
class C extends T1
class C extends T2
val prefix = new C()
new prefix.T()
trait T1 { def x = 2 }
trait T2 extends T1 { def x: Int }
class C extends T2
new C().x
trait T1 { type T }
trait T2 extends T1 { class T }
class C extends T2
val prefix = new C
new prefix.T()
val prefix: T1 = new C
new prefix.T()
class D
trait T1 { type T <: D }
trait T2 extends T1 { class T }
trait T1 { class T }
trait T2 extends T1 { type T <: D }
class C1 { def x = 2 }
abstract class C2 extend C1 { def x: Int }
abstract class C2 extends C1 { def x: Int }
class F extends C2
        trait T1 { class T }
trait T2 extends T1 { type T = X } // this compiles
trait T2 extends T1 { type T = D } // this compiles
exit
trait T
class C extends T()
new T(){}
class C extends AnyRef with T() // this one has been introduced lately
trait T1 { class T }
trait T2 extends T1 { type T  = macro impl2 }
trait T2 extends T1 { override type T  = macro impl2 }
trait T1 { class T }
trait T2 extends T1 { type T = T1 }
trait T2 extends T1 { override type T = T1 }
exit
class C11 { type T = Int }
class C12 extends C11 { type T = Int }
type T[U] = U
def impl(c: Context)(arg: c.Expr[Int]) = c.Expr[Int](Block(ValDef(NoMods, newTermName("x"), TypeTree(), Literal(Constant(3))), arg))
def impl(c: Context)(arg: c.Expr[Int]) = c.Expr[Int](Block(List(ValDef(NoMods, newTermName("x"), TypeTree(), Literal(Constant(3)))), arg))
def impl(c: Context)(arg: c.Expr[Int]) = c.Expr[Int](Block(List(ValDef(NoMods, newTermName("x"), TypeTree(), Literal(Constant(3)))), arg.tree))
def impl(c: Context)(arg: c.Expr[Int]) = { import c.universe._; c.Expr[Int](Block(List(ValDef(NoMods, newTermName("x"), TypeTree(), Literal(Constant(3)))), arg.tree)) }
def foo(x: Int) = macro impl
def foo(arg: Int) = macro impl
{ val x = 2; foo(x) }
exit
final class C
class C extends { type T = Int } with AnyRef
class C extends { def x = 2 } with AnyRef
class C extends { def x = 2 } with AnyRef { type T = String }
class C extends { type T = Int } with AnyRef { type T = String }
class C extends { type T = Int } with A
class B[T]
class C extends { type T = Int } with B[T]
class B(x: Int)
class C extends { val x = 2 } with B(2)
class B[T]
class C extends { type T = Int } with B[T]
impl2
class C extends { type T = macro impl2 } with AnyRef
exit
class C extends { val x = 2 } with B(x)
exit
type T = macro impl2
typeOf[T]
def foo = macro impl1
reify(foo)
res1.eval
class C(x: Int)(y: Int) extends scala.annotation.StaticAnnotation
class X @C(2)(3) ()
class X @C(2) ()
class ann1(x: Int) extends scala.annotation.StaticAnnotation
class C @ann1(2) ()
class ann2(x: Int)(y: Int) extends scala.annotation.StaticAnnotation
class C @ann2(2)(3) ()
exit
def foo( = macro impl
def foo( = macro impl)
def foo() = (macro impl
)
val macro = 1
def foo() = (macro impl
)
def foo = macro impl1
implicit class IntExt(i: Int) { def impl = 2 }
def foo() = (macro impl)
def foo() = (macro impl()
exit
Ident(newTermName("x")).attachmetns
Ident(newTermName("x")).attachments
exit
class C; object C { implicit val list = List[C](new C) }
exit
new B().toString
exit
reify{ object C }
showRaw(res0.tree)
exit
class C; object C extends C
class C { println(C); }; object C
new C
exit
typeOf[_ => _]
typeOf[_ => _].typeSymbol.typeSignature
exit
class C extends Any
class C extends AnyRef
def foo = { println("foo"); 1 }
foo #:: foo #:: Stream.Empty
def foo: Int = { println("foo"); 1 }
1 :: 2 :: Nil
foo #:: foo #:: Stream.Empty
1 #:: 2 #:: Stream.Empty
1 #:: Stream.Empty
1 #:: Stream.empty
foo #:: foo #:: Stream.Empty
foo #:: foo #:: Stream.empty
def foo1: Int = { println("foo1"); 1 }
def foo2: Int = { println("foo2"); 2 }
foo1 #:: foo2 #:: Stream.empty
Stream.iterate(1)(_)
Stream.iterate(1)(x => x)
List(1, 2) flatMap { case 1 => Some(1) }
List(1, 2) collect { case 1 => Some(1) }
List(1, 2) collect { case 1 => 1 }
foo1 #:: foo2 #:: Stream.empty
def foo1: Int = { println("foo1"); 1 }
def foo2: Int = { println("foo2"); 2 }
foo1 #:: foo2 #:: Stream.empty
res4 match { case hd #:: tl => }
Lisr(1, 2, 3) match { case hd #:: tl => }
List(1, 2, 3) match { case hd #:: tl => }
List(1, 2) collect { case 1 => println("x") }
exit
List(1, 2) match { case List(x, xs: _*) => }
List(1, 2) match { case xs :+ x => println(xs, x) }
List(1, 2) match { case xs ++ ys => xs }
trait Fooable[T]
class C; object C { implicit val x = new Fooable[C]{} }
implicitly[Fooable[C]]
trait Fooable[T]
class C; object C { implicit val x = new Fooable[C]{} }
implicitly[Fooable[C]]
exit
import scala.reflect.runtime.universe.{typeOf, TypeRef}
typeOf[Int] match { case TypeRef(_, sym, _) => println(sym) }
import scala.reflect.runtime.universe.TypeRefTag
typeOf[Int] match { case TypeRef(_, sym, _) => println(sym) }
exit
NoSymbol.associatedFile
staticClass("Int")
getClass("Int")
getDefinedClass("Int")
getClassByName("Int")
definitions.getClassByName("Int")
rootMirror.getClassByName("Int")
rootMirror.getClassByName(newTypeName("Int"))
rootMirror.getClassByName(newTypeName("scala.Int"))
res8.associatedFile
rootMirror.getClassByName(newTypeName("scala.collection.immutable.List"))
res10.associatedFile
res10.associatedFile.getFile
res10.associatedFile.path
case class C(x: Int)
new C().productIterator
new C(2).productIterator
new C(2).asInstanceOf[Product]
new C(2).asInstanceOf[Product].productIterator.toList
for (i <- 0 to 2) println(i)
import scala.collection.mutable.ListMap
ListMap(1 -> 2)
(2 -> 3) +: ListMap(1 -> 2)
(2 -> 3) + ListMap(1 -> 2)
(2 -> 3) ++: ListMap(1 -> 2)
(2 -> 3) +: ListMap(1 -> 2).toList
sys.props("foo")
Some(2) collect { case x == 3 => x }
Some(2) collect { case x if x == 3 => x }
q""
exit
q""
val x = ValDef(NoMods, TermName("x"), Ident(TypeName("Int")), EmptyTree)
q"def foo($x)"
exit
q"def foo($x)"
q"{ $x }"
exit
Block(Literal(Constant(2))
)
exit
object 
)
object X { { val x = 2 } }
object X { { val x = 2 } println(x) }
object X { { val x = 2 }; println(x) }
object X { { val x = 2 } }
X.x
val _1 = 2
_1
s"${_}"
_
List("x") map (s"${_}")
exit

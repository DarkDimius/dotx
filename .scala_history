val t = typeOf[Outer[Int]]
val m = t.member(newTermName("m"))
m.typeSignatureIn(SuperType(ThisType(t.typeSymbol), t))
m.typeSignatureIn(t.narrow)
res0 =:= res1
showRaw(res0)
showRaw(res1)
m.typeSignatureIn(ThisType(t.typeSymbol))
m.typeSignatureIn(t)
m.typeSignatureIn(t).narrow
trait Foo {
   def apply(i: Int): String

}
 reify(new Foo { def apply(i: Int) = "hello"+i })
showRaw(res0.tree)
showRaw(res0.tree, printKinds = true)
def foo[T: TypeTag <: String] = ???
def foo[T <: String: TypeTag] = ???
ClassManifest.Int <:< ClassTag.Int
ClassManifest.Int >:> ClassTag.Int
ClassManifest.Int == ClassTag.Int
ClassManifest.classType(classOf[Int])
ClassTag.Int == ClassManifest.classType(classOf[Int])
exist
exit
ClassManifest.Int.runtimeClass
ClassManifest.Int.erasure == ClassTag.Int.erasure
exit
Manifest.Int <:< TypeTag.Int
TypeTag.Int <:< Manifest.Int
trait X { self: D.type => }
trait X { self: D.type => }; object D extends X
lazy val x = 2
lazy val (x, y) = (2, 3)
Map(1 -> 2)(1)
Map(1 -> 2)(2)
Map(1 -> 2).get(2)
:power
NoSymbol.defString
def foo[T, U] = ???
foo[Int]
ru.showRaw(17592186077248L.asInstanceOf[FlagSet])
ru.show(17592186077248L.asInstanceOf[FlagSet])
new Exception().getMessage
new Exception().toString
"%noffender".format()
def foo[T[_]: TypeTag] = ???
def foo[T[_]] = ???
def foo[M[_]](implicit ev: TypeTag[M[_]]) = ev
foo
foo[List]
scala.util.Properties.ScalaCompilerVersion
scala.util.Properties.versionString
System.getProperties()
ClassTag.Nothing
ClassTag.Nothing.mkArray
ClassTag.Nothing.make
ClassTag.Nothing.getClass.getMethods
ClassTag.Nothing.newArray(10)
exit
def foo[T: TypeTag] = implicitly[TypeTag[T]]
def foo[T: ru.TypeTag] = implicitly[ru.TypeTag[T]]
foo[Int]
def foo[T: ru.TypeTag] = implicitly[ru.TypeTag[T]]
foo[Int]
def bar[T] = foo[T]
def bar[T: TypeTag] = foo[T]
def bar[T: TypeTag] = foo[List[T]]
def foo[T: ru.TypeTag] = implicitly[ru.TypeTag[T]]
foo[Int]
foo[List[Int]]
def bar[T] = foo[T]
def bar[T] = foo[List[T]]
def bar[T: TypeTag] = foo[T]
bar[Int]
def bar[T: TypeTag] = foo[List[T]]
bar[Int]
bar[List[Int]]
val ru = scala.reflect.runtime.universe
1
object c { def x(x: Int) = ???; def x(x: String) = ??? }
val x = c.x
ClassTag.Int <:< ClassTag.AnyVal
tb.runExpr(tb.parseExpr(
exit
))
tb.runExpr(tb.parseExpr("class C; new C"))
val tb = cm.mkToolBox()
tb.runExpr(tb.parseExpr("class C; new C"))
res2.getClass
val cm = scala.reflect.runtime.universe.runtimeMirror(getClass.getClassLoader)
val tb = cm.mkToolBox()
tb.runExpr(tb.parseExpr("class C; scala.reflect.classTag[C].runtimeClass"))
import scala.tools.reflect.ToolBox
exit
:paste
scala> import scala.reflect.runtime._ // requires scala-reflect.jar
                                      // in REPL it's implicitly added
                                      // to the classpath
                                      // but in your programs
                                      // you need to do this on your own
import scala.reflect.runtime
scala> val cm = universe.runtimeMirror(getClass.getClassLoader)
cm @ 41d0fe80: reflect.runtime.universe.Mirror = JavaMirror with scala.tools.nsc.interpreter.IMain$TranslatingClassLoader...
scala> import scala.tools.reflect.ToolBox // requires scala-compiler.jar
                                          // in REPL it's implicitly added
                                          // to the classpath
                                          // but in your programs
                                          // you need to do this on your own
import scala.tools.reflect.ToolBox
scala> val tb = cm.mkToolBox()
tb: scala.tools.reflect.ToolBox[reflect.runtime.universe.type] = scala.tools.reflect.ToolBoxFactory$ToolBoxImpl@3a962da5
scala> tb.runExpr(tb.parseExpr("class C; scala.reflect.classTag[C].runtimeClass"))
res2: Any = class __wrapper$1$f9d572ca0d884bca9333e251c64e980d$C$1
val cm = universe.runtimeMirror(getClass.getClassLoader)
import scala.tools.reflect.ToolBox // requires scala-compiler.jar
                                          // in REPL it's implicitly added
                                          // to the classpath
                                          // but in your programs
                                          // you need to do this on your own
val tb = cm.mkToolBox()
tb.runExpr(tb.parseExpr("class C; scala.reflect.classTag[C].runtimeClass"))
val tb = cm.mkToolBox()
import scala.reflect.runtime.universe._
val x = build.newFreeTerm("x", typeOf[Int], 2)
val tb = cm.mkToolBox()
val x = build.newFreeTerm("x", typeOf[Int], 2)
tb.runExpr(Apply(Select(Ident(x), newTermName("$plus")), List(Literal(Constant(2))))
)
List(1, 2, 3)
1 :: 2 :: 3
1 :: 2 :: 3 :: Nil
abstract class Funky(val i: Int) extends AnyVal
def C[T] { def foo[T] = ??? }
typeOf[C[_]].member(newTermName("foo")).asMethodSymbol
class C[T] { def foo[T] = ??? }
typeOf[C[_]].member(newTermName("foo")).asMethodSymbol
typeOf[C[_]].member(newTermName("foo")).asMethod
foo.typeParams
val meth = typeOf[C[_]].member(newTermName("foo")).asMethod
meth.typeParams
class C[T] { def foo(x: T) = ??? }
val meth = typeOf[C[_]].member(newTermName("foo")).asMethod
meth.paramss
meth.params
meth.typeParams
case class C(x: Int, y: Int)
typeOf[C].members.filter(_.isCaseAccessor)
typeOf[C].members.collect{case x: TermSymbol => x}.filter(_.isCaseAccessor)
typeOf[C].members.collect{case x: TermSymbol => x}.filter(sym => sym.isCaseAccessor && sym.isM)
typeOf[C].members.collect{case x: MethodSymbol => x}.filter(_.isCaseAccessor)
typeOf[C].members
case class C(x: Int, y: Int)
typeOf[C].members.collect{case x: MethodSymbol => x}.filter(_.isCaseAccessor)
 typeOf[C].members.collect{case m: MethodSymbol if m.isCaseAccessor => (m.name -> m.returnType)}
class C(val x: Int, val y: Int)
typeOf[C].members.sorted
case class C(val x: Int, val y: Int)
typeOf[C].members.sorted
  val Listing, Album = Value
}
typeOf[ResponseType.Value].asInstanceOf[TypeRef].pre.typeSymbol
typeOf[ResponseType.Value].owner
typeOf[ResponseType.Value].typeSymbol
typeOf[ResponseType.Value].typeSymbol.owner
cm.reflectModule(res0)
cm.reflectModule(res0.asModule)
val moduleClass = typeOf[ResponseType.Value].asInstanceOf[TypeRef].pre.typeSymbol
val module = moduleClass.owner.member(moduleClass.name.toTermName)
val module = moduleClass.owner.typeSignature.member(moduleClass.name.toTermName)
cm.reflectModule(res0.asModule)
val module = moduleClass.owner.typeSignature
val module = moduleClass.owner.typeSignature.member(moduleClass.name.toTermName)
cm.reflectModule(module.asModule)
cm.reflectModule(module.asModule).instance
val moduleClass = typeOf[ResponseType.Value].asInstanceOf[TypeRef].pre.typeSymbol
val module = moduleClass.owner.typeSignature.member(moduleClass.name.toTermName)
cm.reflectModule(module.asModule).instance
case class C
typeOf[C].declarations
typeOf[C.type].declarations
typeOf[C.type].typeSymbol
typeOf[C.type].typeSymbol.name
typeOf[C].typeSymbol
res2 == res4
typeOf[C].owner.typeSymbol
typeOf[C].typeSymbol.owner.typeSignature
typeOf[C.type].typeSymbol.owner.typeSignature
case class C; def C(x: Int) = ???
typeOf[C].typeSymbol.owner.typeSignature
typeOf[C].typeSymbol.owner.typeSignature.member(newTermName("C"))
typeOf[C].typeSymbol.owner.typeSignature.member(newTermName("C")).asModule
typeOf[C].typeSymbol.owner.typeSignature.member(newTermName("C")).suchThat(_.isModule)
typeOf[C].typeSymbol.owner.typeSignature.member(newTermName("C")).suchThat(_.isModule).asModule
showRaw(typeOf[Int])
showRaw(typeOf[Int].typeSymbol)
showRaw(typeOf[Int].typeSymbol, printKinds = true)
import scala.reflect.runtime.{universe => ru}
ru.showRaw(typeOf[Int])
ru.showRaw(typeOf[Int].typeSymbol, printKinds = true)
tb = cm.mkToolBox()
val tb = cm.mkToolBox()
tb.mirror.classLoader
val tb = cm.mkToolBox()
tb.mirror.classLoader
tb.mirror.classLoader.getClass.getMethods
tb.mirror.classLoader.getClass.getDeclaredMethods
val t1 = tb.parseExpr("1 to 3 map (_+1)")
tb.runExpr(t1)
val t1 = tb.parseExpr("1 to 3 map (_+1)")
val tb = cm.mkToolBox()
val t1 = tb.parseExpr("def foo = 1 to 3 map (_+1); foo")
tb.runExpr(t1)
{
  def main(args: Array[String])
  {
    println("test")
  }
}
exit
scala.util.Try(1.toString)
 'scala.util.Try(1.toString)
scala.util.Try(1.toString)
def impl[A](c: reflect.macros.Context) = c.universe.reify(())
def impl[A](c: scala.reflect.macros.Context) = c.universe.reify(())
def decl[A] = macro impl[A]
decl[Any]
decl
def impl(c: Context) = c.reify(new { val x = 2 })
def impl(c: Context) = c.universe.reify(new { val x = 2 })
def foo = macro impl
foo
scala.reflect.runtime.universe.reify(new {val x = 2 })
class C
type X = C with { val amount: Int }
type X = { val amount: Int }
type X = { val amount: Int } with C
type X = ({ val amount: Int }) with C
type X = C with ({ val amount: Int })
case class C(x: Int, y: Int)
typeOf[C].members.collect{ case x: TermSymbol => x }
typeOf[C].members.collect{ case x: TermSymbol if x.isCaseAccessor => x }
typeOf[C].members.collect{ case x: TermSymbol if x.isCaseAccessor && x.isMethod => x }
typeOf[C].members.sorted.collect{ case x: TermSymbol if x.isCaseAccessor && x.isMethod => x }
exit
case class Test(a:String,b:List[Int])
typeOf[Test]
res0.members
res1.filter(_.isMethod).map(_.asMethod).toArray
val ms = res2.toList
val methods = res2.toList
val mirroredMethods = methods.flatMap(e => try
 {Some(lookAtMe.reflectMethod(e))} catch {case e:Throwable =>
 e.printStackTrace();None})
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass
sym.isSealed
res0.isSealed
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.isSealed
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.initialize
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.typeSignature
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.isSealed
val n = 1
ClassTag.Int.runtimeClass
n.getClass
classManifest[Object]
classManifest[List]
classManifest[List[_]]
classTag[List[_]]
classManifest[Int]
classManifest[String]
exit
classTag[List[_]]
classManifest[List[_]]
classManifest[String]
classManifest[String].toString
classManifest[Array[Int]]
classTag[Int]
classTag[Array[Int]]
classManifest[Array[Int]].erasure
res7.isArray
import scala.runtime.ScalaRunTime._
arrayElementClass(res7)
class C[T]
reify { object O; O }
reify { object O; O.asInstanceOf[Object] }
classTag[String].newArray(10)
ClassTag.Object
ClassTag.Object.runtimeClass
class W extends scala.annotation.Annotation
trait A {
     | @W val a: Int
     | }
trait A { @W val a: Int }
typeOf[A].members.last
res0.annotations
res0.getAnnotations
res0.initialize
res0.typeSignature
res0.getAnnotations
typeOf[A].members
cla
class ValueClass(val x: Int) extends AnyVal
def foo(x: Any) = x
foo(new ValueClass(1))
val x = new ValueClass(1)
foo(x)
classTag[ValueClass].runtimeClass.isAssignableFrom(x.getClass)
x.getClass
class ValueClass(val x: Int) extends AnyVal
new ValueClass(1).getClass
exit
classManifest[List[_]]
manifest[List[_]]
exit
classManifest[List[_]]
exit
classManifest[List[_]]
exit
classManifest[List[_]]
exit
classManifest[List[_]]
exit
classManifest[List[_]]
exit
classManifest[List[_]]
exity
exit
class W extends scala.annotation.StaticAnnotation
class A { @W def x: Int = ??? }
typeOf[A].members.last
res0.typeSignature
res0.getAnnotations
typeOf[A].members
typeOf[A].members.first
typeOf[A].members(0)
typeOf[A].members.toList(0)
res6.getAnnotations
exit
class W extends scala.annotation.Annotation
class A { @W def x: Int = ??? }
typeOf[A].members.toList(0)
res0.getAnnotations
res0.typeSignature
res0.getAnnotations
exit
class W extends scala.annotation.StaticAnnotation
trait A { @W val a : Int }
typeOf[A].members.last
res0.getAnnotations
res0.typeSignature
res0.getAnnotations
exit
class W extends scala.annotation.Annotation
class W extends scala.annotation.StaticAnnotation
trait A { @W val a: Int }
typeOf[A].members.last
res0.getAnnotations
trait A { @W def a: Int }
typeOf[A].members.last
res2.getAnnotations
class W extends scala.annotation.ClassfileAnnotation
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.isSealed
type Foo = Annotation
type Foo = java.reflect.Annotation
type Foo = java.lang.reflect.Annotation
type Foo = java.lang.Annotation
class Outer[T] { trait Inner[T]; def m(): Inner[T] = null }
val t = typeOf[Outer[Int]]
 val m = t.member(newTermName("m"))
m.typeSignature
m.typeSignatureIn(SuperType(ThisType(t.typeSymbol), t))
m.typeSignatureIn(t)
class Outer[T] { trait Inner[T]; def m(): Inner[T] = null }
val t = typeOf[Outer[Int]]
 val m = t.member(newTermName("m"))
m.typeSignatureIn(t)
m.typeSignatureIn(SuperType(ThisType(t.typeSymbol), t))
m.typeSignatureIn(SingleType(t))
m.typeSignatureIn(t.narrow)
t.narrow
m.typeSignatureIn(SingleType(NoPrefix, t))
reify('foo)
typeOf[String]
weakTypeOf[String]
val tb = cm.mkToolBox(options = "-Yreify-copypaste")
tb.parseExpr("scala.reflect.runtime.universe.reify(2)")
tb.runExpr(res0)
val tb = cm.mkToolBox(options = "-Yreify-copypaste")
tb.parseExpr("scala.reflect.runtime.universe.reify(2)")
tb.runExpr(res0)
val a = 0.9
cm.reflect(a).symbol.asType <:< typeOf[Double]
cm.reflect(a).symbol.typeSignature <:< typeOf[Double]
cm.reflect(a).symbol.typeSignature
cm.reflect(a).symbol.toType
val a = 0.9
val t = cm.reflect(a).symbol.toType
t <:< typeOf[Double]
tpnme.ANON_CLASS_NAME
Apply(Select(
  Block(List(ClassDef(
    Modifiers(FINAL), tpnme.ANON_CLASS_NAME, Nil,
    Template(List(Ident(AnyRefClass)), emptyValDef, Nil))),
  Apply(Select(New(Ident(tpnme.ANON_CLASS_NAME)), nme.CONSTRUCTOR), Nil))
, sn.GetClass), Nil)
Apply(Select(
  Block(List(ClassDef(
    Modifiers(scala.tools.nsc.symtab.Flags.FINAL), tpnme.ANON_CLASS_NAME, Nil,
    Template(List(Ident(AnyRefClass)), emptyValDef, Nil))),
  Apply(Select(New(Ident(tpnme.ANON_CLASS_NAME)), nme.CONSTRUCTOR), Nil))
, sn.GetClass), Nil)
val t = typeOf[Outer[Int]]
class Outer[T] { trait Inner[T]; def m(): Inner[T] = null }
 val m = t.member(newTermName("m"))
val t = typeOf[Outer[Int]]
 val m = t.member(newTermName("m"))
m.typeSignatureIn(t)
m.typeSignatureIn(ThisType(t.typeSymbol))
m.typeSignatureIn(ThisType(t))
showRaw(t)
m.typeSignatureIn(ThisType(t.typeSymbol))
m.typeSignatureIn(t)
m.typeSignatureIn(t).narrow
m.typeSignatureIn(SingleType(t.pre))
m.typeSignatureIn(SingleType(t.pre, t.typeSymbol))
type T = { def x: Int }
type U = { def y: Int}
type Z = T with U
import scala.reflect.runtime.universe._
// example 1
implicit val intTag = typeTag[Int]
import scala.reflect.runtime.universe._
// example 1
def foo[T](implicit tag: TypeTag[T]) = typeTag[Array[T]]
foo[List[Int]]
// example 2
val tpe = typeOf[Int]
appliedType(definitions.ArrayClass.asType, tpe)
appliedType(definitions.ArrayClass.toType, tpe)
appliedType(definitions.ArrayClass.toType, List(tpe))
val tpe = typeOf[List[Int]]
appliedType(definitions.ArrayClass.toType, List(tpe))
trait C { def x: Int }
trait T { def x: Int }
type E = { def y: Int }
type U = T with E
class C extends C { def x = 2; def y = 2 }
class C extends T { def x = 2; def y = 2 }
val u: U = new C
u.x
u.y
(int)null
null.asInstanceOf[Int]
object Foo { def unapply(x: Int): Option[Boolean] = Some(true) }
2 match { case Foo(x) => x }
import scala.collection.immutable.ListMap
ListMap(List((1, 2)))
List((1, 2)).toListMap
List((1, 2)).toMap
ListMap(List((1, 2)).toMap)
ListMap(List(1 -> 2))
ListMap(List(1 -> 2): _*)
import scala.collection.immutable.ListMap
ListMap(1 -> 2)
ListMap(1 -> 2).toList
typeOf[Foo].typeSymbol
exit
typeOf[Foo].typeSymbol
exit
val b: Any = true
b match { case b: Boolean => println(b) }
b.getClass
b match { case b: scala.Boolean => println(b) }
Array(1).getClass.isArray
Array(1, 2).asInstanceOf[Array[_]]
"11".substring(0, 1)
import scala.collection.immutable.ListMap
ListMap(1 -> 2, 3 -> 4)
class W extends scala.annotation.StaticAnnotation
trait A { @W def x: Int }
typeOf[A].declarations.toList
typeOf[A].declarations.head.getAnnotations
trait A { @W val x: Int }
typeOf[A].declarations.head.getAnnotations
typeOf[A].declarations
typeOf[A].declarations.head
typeOf[A].declarations.head.asMethodSymbol
typeOf[A].declarations.head.asMethod
typeOf[A].declarations.head.asMethod.field
typeOf[A].declarations.head.asMethod.accessed
class W extends scala.annotation.StaticAnnotation
trait A { @W val x: Int }
class C extends A
class C extends A { val x = 2 }
typeOf[C].declarations
typeOf[C].declarations.toList(1)
typeOf[C].declarations.toList(1).getAnnotations
typeOf[C].declarations.toList(2).getAnnotations
class W extends scala.annotation.StaticAnnotation
trait T { @W val x: Int }
typeOf[T].declarations
typeOf[T].declarations.head.getAnnotations
trait T { @(W @scala.annotation.meta.getter) val x: Int }
typeOf[T].declarations.head.getAnnotations
class C { val x: Int }
class C extends T { val x: Int = 2 }
typeOf[C].declarations
typeOf[C].declarations.toList(1).getAnnotations
typeOf[C].declarations.toList(2).getAnnotations
class W extends scala.annotation.ClassfileAnnotation
implicit object Foo
lazy object Foo
classOf[Array[_]
]
res0.isArray
classOf[Array[_]]
import java.lang.annotation.Annotation
def foo(c: Context) = { import c.universe._; ??? }
typeOf[List[_]].typeSymbol.asClass
scala.reflect.runtime.universe.typeOf[List[_]].typeSymbol.asClass
res1.isSealed
exit
scala.reflect.runtime.universe.typeOf[List[_]].typeSymbol.asClass
res0.isSealed
exit
scala.reflect.runtime.universe.typeOf[List[_]].typeSymbol.asClass
res0.isSealed
exit
val tb1 = cm.mkToolBox()
var i = 0
val action = reify { i += 1; println(i) }.tree
tb1.runExpr(action)
tb1.eval(action)
tb1.frontEnd.reset()
tb1.eval(action)
cm.mkToolBox()
tb.parse("def x = {}")
res0.parse("def x = {}")
res0.parse("def x = {")
res0.parse("def x = {}")
def impl[A](c: Context) = c.reify(())
def impl[A](c: Context) = c.universe.reify(())
def decl[A] = macro impl[A]
decl
val tb = cm.mkToolBox()
val expr = tb.parse("1 to 3 map (_+1)")
tb.typeCheck(expr)
scala.reflect.runtime.universe.reify(2)
reflect.runtime.universe.reify("foo")
scala.reflect.runtime.universe.reify("foo")
exit
val x = 0, y = 1
val x = 0; val y = 1
val tb = cm.mkToolBox()
tb.eval(tb.parse("math.sqrt(4.0)"))
tb.eval(tb.parse("1 to 5"))
tb.frontEnd.reset
tb.eval(tb.parse("1 to 5"))
tb.eval(tb.parse("scala.math.sqrt(4.0)"))
tb.eval(tb.parse("import scala._; import Predef._; math.sqrt(4.0)"))
tb
tb.eval(tb.parse("object C"))
tb.eval(ModuleDef(NoMods, newTermName("C"), Template(Nil, emptyValDef, Nil)))
scala.reflect.runtime.universe.typeOf[List].isSealed
scala.reflect.runtime.universe.typeOf[List[_]].isSealed
scala.reflect.runtime.universe.typeOf[List[_]].typeSymbol.asClass.isSealed
exit
scala.reflect.runtime.universe.typeOf[List[_]].typeSymbol.asClass.isSealed
exit
scala.reflect.runtime.universe.typeOf[List[_]].typeSymbol.asClass.isSealed
exit
tb.eval(tb.parse("object C; C"))
tb.eval(tb.parse("object C"))
tb.eval(tb.parse("scala.math.sqrt(4.0)"))
def echoThisImpl(c:Context): c.Expr[Any] = {
  import c.universe._
  val selfTree = This(c.enclosingClass.symbol)
  c.Expr[AnyRef](selfTree)
}
def echoThisImpl(c:Context): c.Expr[Any] = {
import c.universe._
val selfTree = This(c.enclosingClass.symbol)
c.Expr[AnyRef](selfTree)
}
def echoThis: Any = macro CallMacro.echoThisImpl
def echoThis: Any = macro echoThisImpl
val thisValue = CallMacro.echoThis
val thisValue = echoThis
class C { this }
Map(1 -> 1, 1 ->2 )
typeOf[Int]
classTag[Int]
classOf[Int]
typeOf[Int]
classOf[Int]
typeOf[Int]
typeOf[List[Int]]
reify(2)
classOf[Array[Int]]
classOf[Int]
clssTag[Int]
classTag[Int]
classTag[List[Int]]
classOf[Int]
classTag[Int]
classTag[List[Int]]
typeTag[List[Int]]
typeTag[Int]
def foo[T: ru.TypeTag] = manifest[T]
def foo[T: ClassTag: ru.TypeTag] = manifest[T]
"1\n2".split("\n")
typeOf[Int]
scala.reflect.runtime.universe.typeOf[Int]
exit
typeOf[scala.reflect.runtime.SymbolTable]
res0.baseClasses
res0.typeSymbol.name
res0.typeSymbol.fullName
def allBaseClasses = { def loop(tpe: Type): List[Type] = tpe.baseClasses.filter(_.typeSymbol.fullName.toString startsWith "scala.reflect").map(loop); loop(res0) }
def allBaseClasses = { def loop(tpe: Symbol): List[Symbol] = tpe.baseClasses.filter(_.typeSymbol.fullName.toString startsWith "scala.reflect").map(loop); loop(res0.typeSymbol) }
def allBaseClasses = { def loop(tpe: Symbol): List[Symbol] = tpe.asClass.baseClasses.filter(_.typeSymbol.fullName.toString startsWith "scala.reflect").map(loop); loop(res0.typeSymbol) }
def allBaseClasses = { def loop(tpe: Symbol): List[Symbol] = tpe.asClass.baseClasses.filter(_.fullName.toString startsWith "scala.reflect").map(loop); loop(res0.typeSymbol) }
def allBaseClasses = { def loop(tpe: Symbol): List[Symbol] = tpe.asClass.baseClasses.filter(_.fullName.toString startsWith "scala.reflect").map(loop).flatten; loop(res0.typeSymbol) }
allBaseClasses
def loop(tpe: Symbol): List[Symbol] = { val bases = tpe.asClass.baseClasses.filter(_.fullName.toString startsWith "scala.reflect"); bases.head +: bases.tail.map(loop).flatten }
loop(res0.typeSymbol)
def loop(tpe: Symbol): List[Symbol] = { val bases = tpe.asClass.baseClasses.filter(_.fullName.toString startsWith "scala.reflect.internal"); bases.head +: bases.tail.map(loop).flatten }
loop(res0.typeSymbol)
loop(res0.typeSymbol) map (_.asClass) map (_.typeSignature)
1
val sigs = res7
sigs.flatMap(_.declarations.toList)
val decls = sigs.flatMap(_.declarations.toList)
decls.filter(sym => sym.isVal || sym.isVar).foreach(println)
decls.collect{case ts: TermSymbol => ts}.filter(sym => sym.isVal || sym.isVar).foreach(println)
decls.collect{case ts: TermSymbol => ts}.filter(sym => !sym.name.toString.endsWith("Tag") && (sym.isVal || sym.isVar)).foreach(println)
decls.collect{case ts: TermSymbol => ts}.filter(sym => !sym.name.toString.trim.endsWith("Tag") && (sym.isVal || sym.isVar)).foreach(println)
Some(1).collect{case 1 => 2}
Some(1).collect{case 2 => 2}
import ru.QuasiQuote
import scala.reflect.runtime.universe
import universe.QuasiQuote
exit
:power
val tpe = UniqueConstantType(Constant(StringTpe))
val tpe = ConstantType(Constant(StringTpe))
val tpe = ConstantType(Constant(definitions.StringTpe))
val tpe = ConstantType(Constant(IntTpe))
tpe.underlying
Constant(IntTpe).tpe
afterPhase(1)
afterPhase(erasurePpahse)
afterPhase(erasurePhase)
afterPhase(erasure)
afterPhase(phaseNamed(erasure))
afterPhase(erasure)
afterPhase(run.erasure)
afterPhase(currentRun.erasure)
afterPhase(currentRun.erasurePhase)
ConstantType(Constant(IntTpe)).erasure
typed(1)
typed(Literal(Constant(1))
)
typed(Literal(Constant(1)))
typed(Literal(Constant(1))).tpe
typed(Literal(Constant(1))).tpe.underlying
typed(Literal(Constant(IntTpe))
)
typed(Literal(Constant(IntTpe))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe))))
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe
typed(Apply(Ident(ListModule), List(Literal(Constant(1))))).tpe
afterPhase(currentRun.erasurePhase)(typed(Apply(Ident(ListModule), List(Literal(Constant(1))))).tpe)
New(ConsClass, Literal(Constant(1)), Ident(NilModule))
typed(New(ConsClass, Literal(Constant(1)), Ident(NilModule)))
New(appliedType(ConsClass, List(Ident(IntTpe))), Literal(Constant(1)), Ident(NilModule))
New(appliedType(ConsClass, List(Ident(IntClass))), Literal(Constant(1)), Ident(NilModule))
New(appliedType(ConsClass, Ident(IntClass)), Literal(Constant(1)), Ident(NilModule))
New(appliedType(ConsClass, IntTpe), Literal(Constant(1)), Ident(NilModule))
typed(New(appliedType(ConsClass, IntTpe), Literal(Constant(1)), Ident(NilModule)))
typed(New(appliedType(ConsClass, IntTpe), Literal(Constant(1)), Ident(NilModule))).tpe
afterPhase(currentRun.erasurePhase)(typed(Apply(Ident(ListModule), List(Literal(Constant(1))))).tpe)
afterPhase(currentRun.erasurePhase)(typed(New(appliedType(ConsClass, IntTpe), Literal(Constant(1)), Ident(NilModule))).tpe)
typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(1)), Ident(NilModule))).tpe
typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe
afterPhase(currentRun.erasurePhase)(typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe)
:power
typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe
afterPhase(currentRun.erasurePhase)(typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe)
typed(Literal(Constant(IntTpe))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe
:power
typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe
afterPhase(currentRun.erasurePhase)(typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe)
typed(Literal(Constant(IntTpe))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.underlying
typed(Literal(Constant(IntTpe))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.underlying
:power
typed(Literal(Constant(IntTpe))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.underlying
:power
typed(Literal(Constant(IntTpe))).tpe.underlying
typed(Literal(Constant(IntClass.asTypeConstructor))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntClass.asTypeConstructor)))).tpe.underlying
macro def foo = ???
exit
:power
typed(Literal(Constant(IntTpe))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntClass.asTypeConstructor)))).tpe.underlying
exit
val head = typeOf[List[Int]].member(newTermName("head")).asMethod
head.returnType
println(showRaw(head.returnType))
val head = typeOf[List[Int]].member(newTermName("head")).asMethod
val head_a = head.returnType.typeSymbol
val TypeRef(_,_,List(a)) = typeOf[List[_]].typeSymbol.asType.toType
val list_a = a.typeSymbol
head_a eq list_a\
head_a eq list_a
val list = typeOf[List[_]].typeSymbol.asType.toType
val head = typeOf[List[Int]].member(newTermName("head")).asMethod
showRaw(list)
showRaw(head.typeSignature)
showRaw(list.returnType, printIds = true, printKinds = true)
showRaw(list, printIds = true, printKinds = true)
showRaw(head.returnType, printIds = true, printKinds = true)
showRaw(typeOf[List[_]].member(newTermName("head")).typeSignature)
showRaw(typeOf[List[_]].member(newTermName("head")).typeSignature, printIds = true, printKinds = true)
showRaw(typeOf[List[_]].member(newTermName("tail")).typeSignature, printIds = true, printKinds = true)
showRaw(typeOf[List[_]].declaration(newTermName("tail")).typeSignature, printIds = true, printKinds = true)
showRaw(typeOf[List[_]].declaration(newTermName("head")).typeSignature, printIds = true, printKinds = true)
val TypeRef(_, _, List(a)) = typeOf[List[_]].dealias.typeSymbol.asType.toType
val TypeRef(_, _, List(a)) = typeOf[List[_]].normalize.typeSymbol.asType.toType
showRaw(a, printIds = true, printKinds = true)
val TypeRef(_, _, List(type_parameter_of_list)) = typeOf[List[_]].dealias.typeSymbol.asType.toType
val TypeRef(_, _, List(type_parameter_of_list)) = typeOf[List[_]].normalize.typeSymbol.asType.toType
val NullaryMethodType(type_parameter_of_head) = typeOf[List[_]].declaration(newTermName("head")).typeSignature
:power
typed(Literal(Constant(IntTpe))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.underlying
ConstantType(Constant(IntTpe))
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(IntTpe)))
typed(Literal(Constant(StringTpe))).tpe.underlying
typed(Literal(Constant(StringTpe))).tpe.getClass
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(StringTpe)))
afterPhase(currentRun.erasurePhase)(Literal(Constant(IntTpe)))
afterPhase(currentRun.erasurePhase)(Literal(Constant(IntTpe))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe
Constant(IntTpe).tpe
Constant(IntTpe).typeValue
afterPhase(currentRun.erasurePhase)(Constant(IntTpe).typeValue)
afterPhase(currentRun.erasurePhase)(Constant(IntTpe))
afterPhase(currentRun.erasurePhase)(Constant(IntTpe).tpe)
:power
RootClass
RootClass.id
JavaPackage
JavaLangPackageClass.id
JavaLangPackage.id
JavaLangPackageClass.owner
JavaLangPackageClass.owner.id
showRaw(StringTpe, printIds = true)
:power
transformedType
transformedType(IntTpe)
showRaw(res1, printIds = true)
ConstantType(Constant(res1))
ConstantType(Constant(res1)).underlying
typed(Literal(Constant(res2)))
typed(Literal(Constant(res2))).tpe
typed(Literal(Constant(res1))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(res1))))
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(res1)))).tpe
ConstantType(Constant(res1)).getClass
transformedType(StringClass.toType)
showRaw(res11, printIds = true)
ConstantType(Constant(res11))
ConstantType(Constant(res11)).underlying
res11
ConstantType(Constant(res11)).underlying
ConstantType(Constant(res11))
exit
val s = transformedType(StringClass.toType)
:power
val s = transformedType(StringClass.toType)
showRaw(s)
ConstantType(Constant(s))
exit
val s = transformedType(StringClass.toType)
ConstantType(Constant(s))
Constant(s).##
new UniqueConstantType(Constant(s)).##
unique
new UniqueConstantType(Constant(s)) == new UniqueConstantType(Constant(s))
ConstantType(Constant(s)) == ConstantType(Constant(s))
ConstantType(Constant(s)) eq ConstantType(Constant(s))
ConstantType(Constant(s))
ConstantType(Constant(s)).##
:power
val s = transformedType(StringClass.toType)
val s = transformedType(StringClass.asTypeConstructor)
showRaw(s)
ConstantType(Constant(s))
System.identityHashCode(ConstantType(Constant(s)))
uniques
unique
exit
:power
val s = transformedType(StringClass.asTypeConstructor)
val s = transformedType(StringClass.toType)
Constant(StringClass.toType)
Constant(s)
res0.##
res1.##
Constant(s)
Constant(s).##
Constant(StringClass.toType).##
ConstantType(res0).##
ConstantType(res1).##
exit
val s = transformedType(StringClass.toType)
ConstantType(Constant(s))
{ ConstantType(Constant(s)); ConstantType(Constant(s)) }
{ println(ConstantType(Constant(s))); afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); }
exit
:power
val s = transformedType(StringClass.toType)
{ val t1 = ConstantType(Constant(s))); println(t1.underlying); val t2 = afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); println(t2.underlying); }
{ val t1 = ConstantType(Constant(s)); println(t1.underlying); val t2 = afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); println(t2.underlying); }
{ val t1 = ConstantType(Constant(s)); println(t1.underlying); val t2 = afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); println(t2.underlying); println(t2) }
{ val t1 = ConstantType(Constant(s)); println(t1.underlying); println(afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))); }
{ val t1 = ConstantType(Constant(s)); println(afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))); }
{ println(afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))); }
Seq(1, 2).toString
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
{ afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); ConstantType(Constant(s)) }
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
cm.staticModule("scala.math.package")
cm.reflectModule(res0)
res1.runtimeClass
res1.instance
NoSymbol.baseClasses
EnumType(NoSymbol)
EnumType(IntClass)
q""
typeOf[List[_]].typeSymbol.asClass.isSealed
trait A { type T <: A }
trait B { type T <: B }
glb(typeOf[A], typeOf[B])
glb(List(typeOf[A], typeOf[B]))
ru.asInstanceOf[scala.reflect.internal.Types].uniques
ru.asInstanceOf[scala.reflect.internal.Types].uniques.asInstanceOf[scala.reflect.internal.util.HashSet[_]]
trait A { type T <: A }
trait B { type T <: B }
uniques
glb(List(typeOf[A], typeOf[B]))
uniques
glb(List(typeOf[A], typeOf[B]))
uniques
trait A1 { type T <: A1 }
trait B1 { type T <: B1 }
uniques
glb(List(typeOf[A1], typeOf[B1]))
uniques
glb(List(typeOf[A1], typeOf[B1]))
uniques
Runtime.freeMemort
Runtime.freeMemory
Runtime.freeMemory()
java.lang.Runtime.freeMemory()
Runtime.getRuntime().freeMemory()
Array(1, 2).sum
val arr = Array(1, 2)
arr.toArray[Any]
trait A { type T <: A }
trait B { type T <: B }
typeOf[A with B]
typeOf[List[List[A with B]]]
scala.math.`package`
def impl(c: Context) = c.literal(c.compilerSettings)
def impl(c: Context) = c.literal(c.compilerSettings.toString)
def foo = macro impl
foo
def impl(c: Context) = c.literal(show(c.libraryClassLoader))
def foo = macro impl
foo
val cache = scala.collection.mutable.HashMap[scala.reflect.macros.Context#Run, Int]()
def impl(c: Context) = c.literal(cache(c.currentRun) = cache.getOrElseUpdate(c.currentRun, 0) + 1)
def impl(c: Context) = c.literal({cache(c.currentRun) = cache.getOrElseUpdate(c.currentRun, 0) + 1; cache(c.currentRun)})
def foo = macro impl
foo
{ foo; foo }
def foo[T] = println(showRaw(weakTypeOf[List[T]]))
foo
typeOf[scala.math.type]
typeOf[scala.math.`package`.type]
res1.typeSymbol
showRaw(res1.typeSymbol.flags)
res1.typeSymbol.isPackageClass
res1.typeSymbol.isModuleClass
List() forall (_ % 2 == 1)
List[Int]() forall (_ % 2 == 1)
shiowRaw(res0.staticCpe)
showRaw(res0.staticTpe)
showRaw(res0.)
showRaw(res0.ac
showRaw(res0.ac))
showRaw(res0.actualTpe)
res0.
))
showRaw(res0.staticType)
List().toHashSet
exit
1 to 10 foreach (_ => Thread.sleep(1000))
exit
class S(x: Int, y: Int) extends scala.annotation.StaticAnnotation
@S(1 + 1, 2) class C
import scala.reflect.runtime._
import scala.reflect.runtime.universe._
import scala.reflect.runtime.currentMirror
import scala.reflect.runtime.{currentMirror => cm}
val c = typeOf[C].typeSymbol
val c = cm.staticClass("C")
val c = typeOf[C].typeSymbol
c.annotations
showRaw(c.annotations)
showRaw(c.annotations(0))
c.annotations(0).scalaArgs
c.annotations(0).javaArgs
val x = 2
@S(x, 2) class C
val c = typeOf[C].typeSymbol
c.annotations(0).scalaArgs
import scala.reflect.runtime.universe._
class C(x: Int, y: Int) extends scala.annotation.StaticAnnotation
class S(x: Int, y: Int) extends scala.annotation.StaticAnnotation
val x = 2
@S(x, 2) class C
val c = typeOf[C].typeSymbol
c.annotations
showRaw(c.annotations(0).scalaArgs(0))
showRaw(c.annotations(0).scalaArgs(1))
class J(x: Int, y: Int) extends scala.annotation.ClassfileAnnotation
import scala.reflect.runtime.universe._
showRaw(reify{ class C { def x = 2 } }.tree)
showRaw(typeOf[{ def x: Int; val y: List[Int] }])
showRaw(typeOf[{ def x: Int; val y: List[Int] }], printIds = true, printKinds = true)
show(cm.classLoader)
import scala.reflect.runtime.universe._
val tree = reify{ class C { def x = 2 } }
val tree = reify{ class C { def x = 2 } }.tree
import scala.reflect.runtime.universe._
show(reify{ class C { def x = 2 } }.tree)
import scala.reflect.runtime.universe._
show(reify{ class C { def x = 2 } }.tree)
showRaw(reify{ class C { def x = 2 } }.tree)
show(typeOf[{ def x: Int; val y: List[Int] }])
showRaw(typeOf[{ def x: Int; val y: List[Int] }])
showRaw(typeOf[{ def x: Int; val y: List[Int] }], printIds = true, printKinds = true)
import scala.tools.reflect.ToolBox._ // requires scala-compiler.jar
import scala.tools.reflect.ToolBox // requires scala-compiler.jar
import scala.reflect.runtime.{currentMirror => cm}
cm.mkToolBox().typeCheck(reify{ class C { def x = 2 } })
cm.mkToolBox().typeCheck(reify{ class C { def x = 2 } }.tree)
showRaw(cm.mkToolBox().typeCheck(reify{ class C { def x = 2 } }.tree), printTypes = true)
show(reify{ final class C { def x = 2 } }.tree)
def tree = reify{ final class C { def x = 2 } }.tree
showRaw(tree)
showRaw(cm.mkToolBox().typeCheck(tree), printTypes = true)
def tree = reify{ final class C { def x = 2 } }.tree
showRaw(cm.mkToolBox().typeCheck(tree), printTypes = true)
def tree = reify{ final class C { def x = 2 } }.tree
showRaw(cm.mkToolBox().typeCheck(tree), printTypes = true)
def tree = reify{ final class C { def x = 2 } }.tree
showRaw(cm.mkToolBox().typeCheck(tree), printTypes = true)
def m(x: Int*) = ???
class C { def m(x: Int*) = ??? }
val m = typeOf[C].member(newTermName("m")).asMethod
m.params
m.params(0)(0).typeSignature
showRaw(m.params(0)(0).typeSignature)
import scala.reflect.runtime.universe._
class C { def m(x: => Int) = ??? }
val m = typeOf[C].member(newTermName("m")).asMethod
m.params(0)(0).typeSignature
showRaw(m.params(0)(0).typeSignature)
import scala.reflect.runtime.universe._
reify(x + 2)
val x = 2
reify(x + 2)
reify(x + 2).tree
res2.getClass
res2.getClass.toString
import scala.reflect.runtime.universe._
import scala.reflect.runtime.{currentMirror => cm}
import scala.reflect.runtime.ToolBox
import scala.tools.reflect.ToolBox
val tb = cm.mkToolBox()
tb.parse("x + 2")
val mirror = runtimeMirror(getClass.getClassLoader)
tb.eval(tb.parse("2 + 2"))
showRaw(reify{ trait X { def x: Int } })
showRaw(reify{ trait X { def x: Int } }.tree)
showRaw(reify{ trait X { def x = 2 } }.tree)
showRaw(reify{ 2 match { case x @ List(_) => } }.tree)
showRaw(reify(2 match { case x @ List(_) => }).tree)
showRaw(reify(2).tree)
showRaw(2 match { case x => x })
showRaw(2 match { case x => x }.tree)
showRaw(reify(2 match { case x => x }))
showRaw(reify(2 match { case x => x }).tree)
showRaw(reify(2 match { case x @ List(_) => x }).tree)
showRaw(reify(2 match { case _ => x }).tree)
showRaw(reify(2 match { case _ => }).tree)
showRaw(reify(2 match { case List(_) => }).tree)
showRaw(reify(2 match { case List(x) => }).tree)
showRaw(reify(2 match { case List(_) => }).tree)
showRaw(reify(List(2) match { case List(_) => }).tree)
showRaw(reify(List(2) match { case List(x) => }).tree)
exit
trait Foo { self: scala.reflect.api.Universe =>
def foo(x: Any) = x match { case expr: Expr[_] => }
}
showRaw(reify(this))
showRaw{ def foo[T <: Int] = ??? }
showRaw(reify{ def foo[T <: Int] = ??? })
showRaw(reify{ def foo[T] = ??? })
object i
reify{val x = i; x}
res0.eval
val x: i.type = i; x
reify{val x: i.type = i; x}
res3.eval
import scala.reflect.runtime.universe._
val cm = runtimeMirror(getClass.getClassLoader)
val list = cm.staticClass("scala.List")
val list = typeOf[List].typeSymbol
val list = typeOf[List[_]].typeSymbol
list.typeSignature.member("map": TermName)
val map = list.typeSignature.member("map": TermName).asMethod
map.params
map.params(0)(0)
val f = map.params(0)(0)
val filter = map.params(0)(0)
filter.name
filter.typeSignature
map.typeParams
val list = typeOf[List[_]].typeSymbol
list.member("mkString": TermName)
list.typeSignature.member("mkString": TermName)
val mkString = list.typeSignature.member("mkString": TermName)
val mkString = list.typeSignature.member("mkString": TermName).asTerm
mkString.isMethod
mkString.alternatives
mkString.alternatives foreach println
mkString.alternatives foreach (alt => println(alt.typeSignature))
def foo(x: Int*) = ???
def foo(xs: Int*) = ???
def foo(xs: Int*) = xs.sum
def add(xs: Int*) = xs.sum
def impl(c: Context)(xs: c.Expr[Int]*): c.Expr[Int] = {
import c.universe._
val map = list.typeSignature.member("map": TermName).asMethod
val filter = map.params(0)(0)
filter.typeSignatureIn(typeOf[List[Int]])
map.typeSignatureIn(typeOf[List[Int]])
filter.typeSignatureIn(res1)
map.typeSignature
map.typeSignatureIn(typeOf[List[Int]])
typeOf[List[Int]]
showRaw(res0)
res0.typeSignature
res0.members
typeOf[scala.List[_]] =:= typeOf[scala.collection.immutable.List[_]]
typeOf[scala.List[_]] == typeOf[scala.collection.immutable.List[_]]
import scala.reflect.runtime.universe._
typeOf[List[_]].members take 5 foreach println
typeOf[List[_]].members.sorted take 5 foreach println
def test[T: TypeTag](x: T) = s"I've been called for x with the type ${typeOf[T]}"
test(2)
test(List(2, "x"))
import scala.reflect.runtime.universe._
val cm = runtimeMirror(getClass.getClassLoader)
cm.classSymbol(List(1, 2).getClass)
typeOf[List[Int]]
cm.classSymbol(List(1, 2).getClass).typeSignature
cm.classSymbol(List(1, 2).getClass).toType
typeOf[List[Int]]
def invokeHead(x: Any): Any = ???
def invokeHead[T: TypeTag](x: T): Any = ???
def invokeHead(x: Any): Any = {
// type of x is unknown, the best we can do is
// cm.classSymbol(x.getClass).toType
???
}
def invokeHead[T: TypeTag](x: T): Any = {
// type of x is preserved by the compiler
println(typeOf[T])
}
invokeHead(List(1, 2))
invokeHead(List("x"))
def invokeHead(x: Any): Any = {
// type of x is unknown, the best we can do is
println(cm.classSymbol(x.getClass).toType)
}
invokeHead(List(1, 2))
invokeHead(List("x"))
typeOf[List[Int]].member("head": TermName).asMethod
val head = typeOf[List[Int]].member("head": TermName).asMethod
val im = cm.reflect(List(1, 2))
val mm = im.reflectMethod(head)
mm()
def foo(x: Int = 2) = ???
class C { def foo(x: Int = 2) = ??? }
typeOf[C].declarations
class Coll[T] {
def filter(p: T => Boolean): Coll[T] = macro filter_impl[T]
}
class Coll[T] {
def filter(p: T => Boolean): Coll[T] = macro filter_impl[T]
} object Coll
class Coll[T] {
def filter(p: T => Boolean): Coll[T] = macro Macros.filter[T]
}
class Coll[T] {
def filter(p: T => Boolean): Coll[T] = macro Macros.filter[T]
} object Macros {
class Coll[T] {
def filter(p: T => Boolean): Coll[T] = macro Macros.filter[T]
}; object Macros {
def filter[T](c: Context { type PrefixType = Coll[T] })(p: c.Expr[T => Boolean]): c.Expr[Coll[T]] = { println(c.prefix); c.prefix }
}
new Coll[Int]().filter(_ % 2 == 0)
val x = new Coll[String]()
x.filter(_ != "")
def impl(c: Context)(x: c.Expr[Int]) = {
println(s"compile-time value is: ${c.eval(x)}")
x
}
def test(x: Int) = macro impl
test(2)
def impl(c: Context)(x: c.Expr[Int]) = {
val x1 = c.Expr[Int](c.resetAllAttrs(x.tree.duplicate))
println(s"compile-time value is: ${c.eval(x1)}")
x
}
def test(x: Int) = macros impl
def test(x: Int) = macro impl
test(2)
test(2 + 2)
def impl(c: Context)(x: c.Expr[String]) = {
val x1 = c.Expr[String](c.resetAllAttrs(x.tree.duplicate))
println(s"compile-time value is: ${c.eval(x1)}")
x
}
def test(x: String) = macro impl
test("x")
test("x" + "y")
val x = "x"
test(x + "y")
{ val x = "x"; test(x + "y") }
trait Foo { implicit def manifest = implicitly[Manifest[Element]] }
trait Foo { implicit def manifest = implicitly[Manifest[Int]] }
trait Foo { implicit def manifest = implicitly[Manifest[Foo]] }
class C
trait Foo { implicit def manifest = implicitly[Manifest[C]] }
new Foo{}
new Foo{}.manifest
typeOf[String].typeSymbol.asType.isAliasType
showRaw(typeOf[String])
typeOf[String].typeSymbol.typeSignature
typeOf[String].typeSymbol.asType.isAliasType
typeOf[String].typeSymbol
typeOf[String].flags
typeOf[List].flags
typeOf[List[_]].flags
showRaw(typeOf[List[_]])
typeOf[String].typeSymbol.asType.isAliasType
val TypeRef(_, sym, _) = typeOf[String]
sym.typeSymbol.asType.isAliasType
sym.asType.isAliasType
showRaw(typeOf[String])
typeOf[String].typeSymbol
def foo(c: Context): c.Tree = ???
def bar(c: Context): c.Tree = foo(c)
def bar(c: Context): c.Tree = c.literalUnit.tree
class Helper(c: Context) {
def generate: c.Tree = ???
}
class Helper(val c: Context) {
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper(c)
c.Expr(helper.generate)
}
class Helper(val c: Context) {
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper
}
abstract class Helper {
val c: Context
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val c1: c.type
}
def impl(c1: Context): c1.Expr[Unit] = {
val helper = new { val c: c1.type = c1 } with Helper
c.Expr(helper.generate)
}
def impl(c1: Context): c1.Expr[Unit] = {
val helper = new { val c: c1.type = c1 } with Helper
c1.Expr(helper.generate)
}
class Helper[C <: Singleton]
class Helper[C <: Singleton](val c: Context) {
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper(c)
c.Expr(helper.generate)
}
class Helper[C <: Singleton](val c: C) {
def generate: c.Tree = ???
}
class Helper[C <: Context with Singleton](val c: C) {
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper(c)
c.Expr(helper.generate)
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper[c.type](c)
c.Expr(helper.generate)
}
class C(val x: Any) { def cast[T]: T = x.asInstanceOf[T] }
new C("xxx").cast[Int]
class C(val x: Any) { def cast[T]: Any = x.asInstanceOf[T] }
new C("xxx").cast[Int]
class C(val x: Any) { def cast[T <: Int]: Any = x.asInstanceOf[T] }
new C("xxx").cast[Int]
def foo[T: TypeTag] = println(typeOf[T])
foo[Int]
foo[String]
foo[List[Int]]
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typetag = c.inferImplicitValue(weakTypeOf[T])
if (typeTag == EmptyTree) c.abort(
}
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typeTags= c.mirror.staticClass("scala.reflect.api.TypeTags)
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typeTags= c.mirror.staticClass("scala.reflect.api.TypeTags"
)
}
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typeTags= c.mirror.staticClass("scala.reflect.api.TypeTags")
val typeTag = typeTags.typeSignature.member(newTypeName("TypeTag")).asClass.toType
val typeTagOfT = appliedType(typeTag, List(weakTypeOf[T])
val inferred = c.inferImplicitValue(typeTagOfT)
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typeTags = c.mirror.staticClass("scala.reflect.api.TypeTags")
val typeTag = typeTags.typeSignature.member(newTypeName("TypeTag")).asClass.toType
val typeTagOfT = appliedType(typeTag, List(weakTypeOf[T]))
val inferred = c.inferImplicitValue(typeTagOfT)
if (inferred == EmptyTree) c.abort("can't provide a weak type here")
c.literalUnit
}
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typeTags = c.mirror.staticClass("scala.reflect.api.TypeTags")
val typeTag = typeTags.typeSignature.member(newTypeName("TypeTag")).asClass.toType
val typeTagOfT = appliedType(typeTag, List(weakTypeOf[T]))
val inferred = c.inferImplicitValue(typeTagOfT)
if (inferred == EmptyTree) c.abort("can't provide a weak type here")
}
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typeTags = c.mirror.staticClass("scala.reflect.api.TypeTags")
val typeTag = typeTags.typeSignature.member(newTypeName("TypeTag")).asClass.toType
val typeTagOfT = appliedType(typeTag, List(weakTypeOf[T]))
val inferred = c.inferImplicitValue(typeTagOfT)
if (inferred == EmptyTree) c.abort(c.enclosingPosition, "can't provide a weak type here")
c.literalUnit
}
def foo[T] = macro impl[T]
foo[List[Int]]
def bar[T] = foo[T]
new Exception().getStackTraceString
new Exception().printStackTrace
scala.tools.nsc.util.stackTraceString(new Exception)
def impl[T: c.WeakTypeTag](c: Context) = c.universe.reify { val x: T = null.asInstanceOf[T] }
def foo[T] = macro impl[T]
foo[Int]
def foo[T] = println("1")
def foo[T](x: T) = println("2")
foo[Int]
foo[Int]()
def foo[T] = println("1"); def foo[T](x: T) = println("2")
foo[Int]
foo(1)
class C { def foo[T <: Int]: T = ??? }
typeOf[C].member(newTermName("foo"))
vak foo = typeOf[C].member(newTermName("foo")).asMethod
val foo = typeOf[C].member(newTermName("foo")).asMethod
foo.typeParams(0)
foo.typeParams(0).typeSignature
foo.typeParams(0).typeSignature.erasure
def foo[T] = weakTypeOf[Map[Int, T]]
foo[Int]
def foo[T] = weakTypeOf[Map[Int, T]].erasure
foo[Int]
def foo[T] = weakTypeOf[Map[String, T]].erasure
foo[Int]
(params: Seq[Any]) => params(0).asInstanceOf[math.Numeric[_]].mkNumericOps (params(1).asInstanceOf[Object]))
(params: Seq[Any]) => params(0).asInstanceOf[math.Numeric[_]].mkNumericOps (params(1).asInstanceOf[Object])
type T1 = T forSome { type T }
type T = T1 forSome { type T1 }
(params: Seq[Any]) => params(0).asInstanceOf[math.Numeric[T]].mkNumericOps (params(1).asInstanceOf[T])
type T = T forSome { type T }
(params: Seq[Any]) => params(0).asInstanceOf[math.Numeric[T]].mkNumericOps (params(1).asInstanceOf[T])
case class C(val x: Int, val y: Int)
typeOf[C].declarations.collect{case x: MethodSymbol if x.isCaseAccessor}
typeOf[C].declarations.collect{case x: MethodSymbol if x.isCaseAccessor => x}
case class C(val x: Int, val y: Int)
typeOf[C].declarations.collect{case x: MethodSymbol if x.isCaseAccessor => x}
class C { def x = 2 }
val m = ru.runtimeMirror(getClass.getClassLoader)
val im = m.reflect(new C)
val mm = m.reflectMethod(typeOf[C].declaration(newTermName("x")).asMethod)
val mm = im.reflectMethod(typeOf[C].declaration(newTermName("x")).asMethod)
mm()
val methodX = typeOf[C].declaration(newTermName("x")).asMethod
val mm = im.reflectMethod(methodX)
class C { var x = 2 }
class C { val x = 2; var y = 3 }
val fieldX = typeOf[C].declaration(newTermName("x")).asTerm.accessed
val fieldY = typeOf[C].declaration(newTermName("y")).asTerm.accessed
val im = m.reflect(new C)
val fmX = im.reflectField(fieldX)
val fieldX = typeOf[C].declaration(newTermName("x")).asTerm.accessed.asTerm
val fieldY = typeOf[C].declaration(newTermName("y")).asTerm.accessed.asTerm
val fmX = im.reflectField(fieldX)
val fmY = im.reflectField(fieldY)
fmX.get
fmX.set(3)
fmY.get(3)
fmY.get
fmY.set(4)
fmY.get
case class C(val x: Int)
val classC = typeOf[C].typeSymbol
val cm = im.reflectClass(classC)
val classC = typeOf[C].typeSymbol.asClass
val cm = im.reflectClass(classC)
val cm = m.reflectClass(classC)
val ctorC = typeOf[C].declaration(ru.nme.CONSTRUCTOR).asMethod
val ctorm = cm.reflectConstructor(ctorC)
ctorm(2)
object C { def x = 2 }
val objectC = typeOf[C.type].termSymbol.asModule
val modm = m.reflectModule(objectC)
modm.instance
val mod = modm.instance
val mm = m.reflectModule(objectC)
val obj = mm.instance
import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;
ManagementFactory.getRuntimeMXBean().getInputArguments()
ManagementFactory.getRuntimeMXBean().getInputArguments().toString
exit
import scala.reflect.macros.Context
def impl(c: Context): c.Expr[Int] = {
import c.universe._
val lm = DefDef(NoMod, newTermName("foo"), Nil, List(Nil), TypeTree(), Literal(Constant(2)))
Block(List(lm), Ident(newTermName("foo")))
}
def impl(c: Context): c.Expr[Int] = {
import c.universe._
val lm = DefDef(NoMods, newTermName("foo"), Nil, List(Nil), TypeTree(), Literal(Constant(2)))
c.Expr(Block(List(lm), Ident(newTermName("foo"))))
}
def test = macro impl
import language.experimental.macros
def test = macro impl
test
typeOf[List[Int]].member(newTermName("head"))
import scala.reflect.runtime.universe._
typeOf[List[Int]].member(newTermName("head"))
res2.asMethod.paramss
res2.asMethod.params
res2.asMethod.returnType
typeOf[Range].member(newTermName("inclusive")).asMethod.returnType
typeOf[Range].member(newTermName("inclusive")).asMethod
res7.owner
exit
      case m if m.isMethod => m.asMethod 
    }
import scala.reflect.runtime.universe._
typeOf[String].members.collect { 
      case m if m.isMethod => m.asMethod 
    }
import scala.reflect.runtime.universe._
def invoke[Target : TypeTag](obj: Any): Seq[Target] = {
  val mirror = runtimeMirror(obj.getClass.getClassLoader)
  val insMirror = mirror reflect obj
  val originType = insMirror.symbol.typeSignature
  val targetType = typeTag[Target].tpe
  val members = originType.nonPrivateMembers.filter(_.isValue)
  val result = members collect (member => member.typeSignature match {
    case tpe if tpe <:< typeOf[ThirdParty] =>
      if (member.isModule)
        (insMirror reflectModule member.asModuleSymbol).instance
      else
        (insMirror reflectField member.asTermSymbol).get
    case NullaryMethodType(tpe) if tpe <:< typeOf[ThirdParty] =>
      (insMirror reflectMethod member.asMethodSymbol).apply()
    case MethodType(Nil, tpe) if tpe <:< typeOf[ThirdParty] =>
      (insMirror reflectMethod member.asMethodSymbol).apply()
  })
  result.map(_.asInstanceOf[Target]).toSeq
}
exit
import scala.reflect.runtime.universe._
trait ThirdParty { def invoke = println("right") }
trait WeatherIcon { def invoke = println("wrong") }
class MyClass {
    object objA extends ThirdParty
    object objB extends WeatherIcon
}
val members = typeOf[MyClass].members.filter(_.isValue).filter(_.typeSignature match {
  case tpe if tpe <:< typeOf[ThirdParty] => true
  case NullaryMethodType(tpe) if tpe <:< typeOf[ThirdParty] => true
  case MethodType(Nil, tpe) if tpe <:< typeOf[ThirdParty] => true
  case _ => false
})
val members = typeOf[MyClass].members.filter(_.typeSignature match {
  case tpe if tpe <:< typeOf[ThirdParty] => true
  case NullaryMethodType(tpe) if tpe <:< typeOf[ThirdParty] => true
  case MethodType(Nil, tpe) if tpe <:< typeOf[ThirdParty] => true
  case _ => false
}
)
import scala.reflect.runtime.universe._
def invoke[Target : TypeTag](obj: Any): Seq[Target] = {
  val mirror = runtimeMirror(obj.getClass.getClassLoader)
  val insMirror = mirror reflect obj
  val originType = insMirror.symbol.typeSignature
  val targetType = typeTag[Target].tpe
  val members = originType.members
  val result = members collect (member => member.typeSignature match {
    case tpe if tpe <:< typeOf[ThirdParty] =>
      if (member.isModule)
        (insMirror reflectModule member.asModuleSymbol).instance
      else
        (insMirror reflectField member.asTermSymbol).get
    case NullaryMethodType(tpe) if tpe <:< typeOf[ThirdParty] =>
      (insMirror reflectMethod member.asMethodSymbol).apply()
    case MethodType(Nil, tpe) if tpe <:< typeOf[ThirdParty] =>
      (insMirror reflectMethod member.asMethodSymbol).apply()
  })
  result.map(_.asInstanceOf[Target]).toSeq
}
    import scala.reflect.runtime.universe._
    def invoke[Target : TypeTag](obj: Any): Seq[Target] = {
      val mirror = runtimeMirror(obj.getClass.getClassLoader)
      val insMirror = mirror reflect obj
      val originType = insMirror.symbol.typeSignature
      val targetType = typeTag[Target].tpe
      val members = originType.members
      val result = members collect (member => member.typeSignature match {
        case tpe if tpe <:< typeOf[ThirdParty] =>
          if (member.isModule)
            (insMirror reflectModule member.asModule).instance
          else
            (insMirror reflectField member.asTerm).get
        case NullaryMethodType(tpe) if tpe <:< typeOf[ThirdParty] =>
          (insMirror reflectMethod member.asMethod).apply()
        case MethodType(Nil, tpe) if tpe <:< typeOf[ThirdParty] =>
          (insMirror reflectMethod member.asMethod).apply()
      })
      result.map(_.asInstanceOf[Target]).toSeq
    }
class MyClass {
        object objA extends ThirdParty
        object objB extends WeatherIcon
        val aVal = new ThirdParty {}
        val bVal = new WeatherIcon {}
        def aDef = new ThirdParty {}
        def bDef = new WeatherIcon {}
        def anotherDef() = new ThirdParty {}
        def yetAnotherDef() = new WeatherIcon {}
      }
nvoke[ThirdParty](new MyClass)
invoke[ThirdParty](new MyClass)
import scala.reflect.runtime.universe._
trait A { type T <: A }
import scala.reflect.runtime.universe._
trait A { type T <: A }
trait B { type T <: B }
glb(typeOf[A], typeOf[B])
glb(List(typeOf[A], typeOf[B]))
res1.member(newTypeName("T"))
val p = new A with B {}
class C extends A with B
class C { def x = 2 }
class D extends C { def y = 3 }
typeOf[D].members
import scala.reflect.runtime.universe._
class C { def x = 2 }
case class D(y: Int, z: Int)
typeOf[D].members
case class C(x: Int, y: Int)
typeOf[C].members
typeOf[C].declarations
class C { def x = 2; def y = 2 }
import scala.reflect.runtime.universe._
class C { def x = 2; def y = 3 }
typeOf[C].members
typeOf[C].declarations
typeOf[C].members.sorted
typeOf[List[_]].member(newTermName("head")).asMethod
import scala.reflect.runtime.universe._
typeOf[List[_]].member(newTermName("head")).asMethod
val head = typeOf[List[_]].member(newTermName("head")).asMethod
head.paramss
import scala.reflect.runtime.universe._
class C[T] { def test[U](x: T)(y: U): Int = ??? }
val test = typeOf[C[Int]].member(newTermName("test")).asMethod
test.paramss
test.typeParams
test.returnType
test.paramss.flatten(0).typeSignature
test.paramss.flatten
test.paramss.flatten(0)
test.paramss.flatten.apply(0)
test.paramss(0)(0)
val x = test.paramss(0)(0)
x.typeSignature
test.typeSignature
x.typeSignatureIn(typeOf[C[Int]])
test.typeSignatureIn(typeOf[C[Int]])
val mt = test.typeSignatureIn(typeOf[C[Int]])
mt match { 
case MethodType(List(x), _) => x
}
val x = mt match { 
case PolyType(List(u), MethodType(List(x), MethodType(List(y), ret))) => (u, x, y, ret)
}
x.typeSignature
PolyType(List(u), MethodType(List(x), MethodType(List(y), ret))) = mt
val PolyType(List(u), MethodType(List(x), MethodType(List(y), ret))) = mt
x.typeSignature
List(1) match { case _: List[Int] => 2 }
val x: Any = List(1)
x match { case _: List[Int] => 2 }
showRaw(mt)
import scala.reflect.runtime.universe.
_
class C { def x: Int = 2 }
class D extends C { override def y: Any = "a" }
class D extends C { override def x: Any = "a" }
class D extends C { override def x: Long = 1 }
class C { def x: Any = 2 }
class D extends C { override def x: AnyRef = "x" }
typeOf[C].member(newTermName("x"))
res0.typeSignatuer
res0.typeSignature
res0.typeSignatureIn(typeOf[C])
res0.typeSignatureIn(typeOf[D])
class C[T] { def x: T = ??? }
class D extends C[Int]
typeOf[C].member(newTermName("x"))
typeOf[C[_]].member(newTermName("x"))
res6.typeSignature
res6.typeSignatureIn(typeOf[D])
res6.typeSignatureIn(typeOf[C[_]])
class C[T] { def test[U](x: T)(y: U): Int = ??? }
val test = typeOf[C[Int]].member(newTermName("test")).asMethod
showRaw(test)
showRaw(test.typeSignature)
showRaw(test.typeSignature, printIds = true)
import scala.reflect.runtime.universe._
ru.reify{ object Test { println("Hello World!") } }
reify{ object Test { println("Hello World!") } }
showRaw(res1.tree)
exit
reify(1 != 1)
val x = 0
reify(x != 0)
reify(x != 0).tree
show(reify(x != 0).tree)
trait Persisted {
  def id: Long
}
reify case class Person(first: String, last: String)
case class Person(first: String, last: String)
reify({ class C(val x: Int, val y: Int) })
case class Person(first: String, last: String)
reify { class Person$Persisted1(first: String, last: String) extends Person(first, last) with Persisted }
scala.reflect.runtime.universe.reify { class Person$Persisted1(first: String, last: String) extends Person(first, last) with Persisted }
trait Persisted { def id: Long }
scala.reflect.runtime.universe.reify { class Person$Persisted1(first: String, last: String) extends Person(first, last) with Persisted }
showRaw(res2)
scala.reflect.runtime.universe.showRaw(res2)
val x: List[_] = List(1)
T forSome { type T }
type U = T forSome { type T }
import scala.reflect.runtime.universe._
val x = 2
val tree = Apply(Select(Ident(newTermName("x")), newTermName("$plus")), List(Literal(Constant(2))))
show(tree)
showRaw(tree)
import scala.reflect.runtime.universe._
val tree = Apply(Select(Ident(newTermName("x")), newTermName("$plus")), List(Literal(Constant(2))))
show(tree)
showRaw(tree)
import scala.tools.reflect.ToolBox
val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
tb.typecheck(tree)
tb.typeCheck(tree)
"foo".length
import scala.reflect.runtime.universe._
val tree = Select(Literal(Constant("test")), newTermName("length"))
show(tree)
import scala.tools.reflect.ToolBox 
val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
tb.typeCheck(tree)
showRaw(tree)
showRaw(tree, printIds = true)
showRaw(res1, printIds = true)
showRaw(res1, printIds = true, printTypes = true)
val x = 2
def tree = reify(x + 2)
val Apply(fun, arg :: Nil) = tree
def tree = reify(x + 2).tree
val Apply(fun, arg :: Nil) = tree
object traverser extends Traverser {
def traverse(tree: Tree): Unit = {
}
object traverser extends Traverser {
  override def traverse(tree: Tree): Unit = {
    }
}
object traverser extends Traverser {
  override def traverse(tree: Tree): Unit = tree match {
    case Apply(_, _) => println("found an Apply")}}
object traverser extends Traverser {
  override def traverse(tree: Tree): Unit = {
    tree match {
      case Apply(_, _) => println("found an Apply")
      case _ => 
    }
    super.traverse(tree)
  }
}
traverse(tree)
traverser(tree)
ttree.type
ttree.tpe
val tree = Select(Literal(Constant("test")), newTermName("length"))
val ttree = tb.typeCheck(tree)
ttree.tpe
ttree.symbol
object Foo
typeOf[Foo.type].name
import scala.reflect.runtime.universe._
typeOf[Foo.type].name
typeOf[Foo.type].termSymbol.name
Apply(Select(Ident(newTermName("x")), newTermName("+").encoded), List(Literal(Constant(2))))
import scala.reflect.runtime.universe._
Apply(Select(Ident(newTermName("x")), newTermName("+").encoded), List(Literal(Constant(2))))
val x = 2
reify(x + 2)
reify(x + 2).tree
val x = 2
val tree = reify(x + 2).tree
showRaw(tree)
{ val x = 2; val tree = reify(x + 2).tree; showRaw(tree) }
{ val tree = reify(println(2)).tree; showRaw(tree) }
val x = reify(2)
val y = reify(2)
reify(x.splice + y.splice)
val prefix = reify("Scala ")
val suffix = reify("reflection")
val prefix = reify("Scala")
val suffix = reify("reflection")
reify(prefix.splice + " " + suffix.splice)
val x = reify(2)
reify(println(x.splice))
val fn = reify(println)
reify(fn.splice(2))
reify(fn.splice()(2))
val fn = reify(println _)
reify(fn.splice(2))
import scala.tools.reflect.ToolBox
val tb = runtimeMirror(getClass.getClassLoader)
tb.parse("println(2)")
val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
tb.parse("println(2)")
showRaw(tb.parse("println(2)"))
Apply(Ident(newTermName("println")), List(Literal(Constant(2))))
import scala.reflect.macros.Context
def impl(c: scala.reflect.macros.Context) = c.Expr(c.parse("println(2)"))
def impl(c: scala.reflect.macros.Context) = c.Expr[Unit](c.parse("println(2)"))
def test = macro impl
import language.experimental.macros
def test = macro impl
test
List(1, 2, 3) sliding 2
List(1, 2, 3) sliding 2 toList
List(1, 2, 3) tails
List(1, 2, 3) tails toList
List(1, 2, 3).tails.toList
import scala.reflect.runtime.universe._
class Foo { def x = 2 }
val foo = new Foo
import foo._
x
typeOf[List[Int]]
val cm = runtimeMirror(getClass.getClassLoader)
cm.staticClass("Foo")
typeOf[Foo].typeSymbol
typeOf[Foo].typeSymbol.fullName
val x = 2
typeOf[Foo].typeSymbol.typeSignature
res5.member(newTermName("x"))
foo
cm
cm.reflect(foo)
val im = cm.reflect(foo)
val mm = im.reflectMethod(x.asMethod)
val x = res5.member(newTermName("x"))
val mm = im.reflectMethod(x.asMethod)
mm()
class Foo { var x = 2 }
val foo = typeOf[Foo].typeSymbol
val x = foo.typeSignature.member(newTermName("x"))
val foo = new Foo
val im = cm.reflect(foo)
val fm = im.reflectField(x)
val fm = im.reflectField(x.asTerm)
fm.get
fm.set(3)
fm.get
foo.x
x.typeSignature
cm
exit
import scala.reflect.runtime.universe._
// scala-reflect.jar
// scala-library.jar => core jar
// scala-compiler.jar
import scala.tools.reflect.ToolBox
val cm = runtimeMirror(getClass.getClassLoader)
cm.mkToolBox
val tb = cm.mkToolBox()
tb.eval(tb.parse("2 + 2"))
Apply(Select(Literal(Constant(2)), newTermName("$plus")), List(Literal(Constant(2))))
import scala.reflect.runtime.universe._
val t = tb.parse("2 + 2")
tb.typeCheck(t)
res3.tpe
import scala.reflect.runtime.universe._
val x = 2
reify(x + 2)
showRaw(res0.tree)
class Foo
reify{ class C { def x = 2 } }
showRaw(res2.tree)
reify(x + 2)
reify(x)
reify(2)
reify(res5.splice + res6.splice)
res5.splice
reify(x + 2)
reify(res5.splice + res6.splice)
reify(List(2))
showRaw(res11.tree)
showRaw(res11.tree, printIds = true)
import scala.tools.reflect.ToolBox
val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
tb.typeCheck(res11.tree)
showRaw(res14, printIds = true)
reify(res5.splice + res6.splice)
reify(+)
reify(2)
showRaw(res17.tree)
tb
tb.parse("+")
tb.parse("2 + 2")
tb.typeCheck(res21)
val cm = runtimeMirror(getClass.getClassLoader)
val tb = cm.mkToolBox()
reify(2 + 2)
reify(if (false) 0 else 1)
reify(" hello " + "world")
abstract class Tree
case class Number(n: Int) extends Tree
case class Apply(fun: String, args: List[Tree]) extends Tree
val n5 = Number(5)
val p55 = Apply("plus", List(n5, n5))
val p55div0 = Apply("div", List(p55, Number(0)))
val zerodivp55 = Apply("div", List(Number(0), p55))
val zerodivp55div0 = Apply("div", List(Apply("div", List(Number(0), p55)), Number(0)))
def prettyprint(tree: Tree): String = tree match {
case Number(n) => n.toString
case Apply(fun, args) => fun + args.mkString("(", ", ", ")")
}
def prettyprint(tree: Tree): String = tree match {
case Number(n) => n.toString
case Apply(fun, args) => fun + args.map(prettyprint).mkString("(", ", ", ")")
}
prettyprint(n5)
prettyprint(p55)
prettyprint(p55div0)
prettyprint(zerodivp55)
prettyprint(zerodivp55div0)
def divsByZero(tree: Tree): List[Tree] = tree match {
case Number(_) => Nil
case Apply("div", List(x, Number(0))) => divsByZero(x) :+ tree
case Apply(_, args) => args.flatMap(divsByZero)
}
divsByZero(n5)
divsByZero(p55)
divsByZero(p55div0)
divsByZero(zerodiv55)
divsByZero(zerodivp55)
divsByZero(zerodivp55div0)
def mkString(trees: List[String], sep: String): String = trees match {
case Nil => ""
case hd :: tl => hd + sep + mkString(tl, sep)
}
mkString(List("1", "2"), ", ")
def mkString(ss: List[String], sep: String): String = ss match {
case Nil => ""
case s :: Nil => s
case hd :: tl => hd + sep + mkString(ss, sep)
}
mkString(List("1", "2"), ", ")
def mkString(ss: List[String], sep: String): String = ss match {
case Nil => ""
case s :: Nil => s
case hd :: tl => hd + sep + mkString(tl, sep)
}
mkString(List("1", "2"), ", ")
def flatten(trees: List[List[Tree]]): List[Tree] = trees match {
case Nil => Nil
case hd :: tl => hd ++ flatten(fl)
}
def flatten(trees: List[List[Tree]]): List[Tree] = trees match {
case Nil => Nil
case hd :: tl => hd ++ flatten(tl)
}
def flatten(trees: List[List[Tree]]): List[Tree] = trees match {
case Nil => Nil
case hd :: tl => hd ++ flatten(tl)
}
type Tree = String
def flatten(trees: List[List[Tree]]): List[Tree] = trees match {
case Nil => Nil
case hd :: tl => hd ++ flatten(tl)
}
flatten(List(List("1"), List("1", "2")))
import scala.reflect.runtime.universe._
val TypeRef(optType, optClass, dummyArgs) = typeOf[Option[Any]]
def foo[U <: Universe with Singleton](t: U # Tree) = ???
import scala.reflect.runtime.universe._
def foo[U <: Universe with Singleton](t: U # Tree) = ???
import scala.reflect.api._
def foo[U <: Universe with Singleton](t: U # Tree) = ???
foo(Ident("x"))
def foo[U <: Universe](t: U # Tree) = ???
foo(Ident("x"))
def foo(t: u.Tree forSome { val u: Universe }) = ???
foo(Ident("x"))
def foo(t: u.Tree forSome { val u: Universe }) = ()
foo(Ident("x"))
def foo[U <: Universe](t: U # Tree) = ()
foo(Ident("x"))
import scala.reflect.api._
import scala.reflect.runtime.universe._
def foo(x: Universe # Tree) = ???
def foo(x: Universe # Tree) = x match {
import scala.reflect.api.Universe
import scala.reflect.api.Trees._
def foo(x: Universe # Tree) = x match {
case Universe # Ident(_) => ???
brew search tree
def foo(x: Universe # Tree) = x match {
case Universe # Ident(_) => ???
def foo(tree: Universe # Tree) = tree match {
import scala.reflect.runtime.universe._
Ident("x")
res0.$outer
res0.getClass
res0.getClass.getDeclaredMethods
res0.getClass.getDeclaredMethods foreach (m => println(m.getName))
res0.getClass.getDeclaredMethod("scala$reflect$internal$Trees$Ident$$$outer")
res5.invoke(res0)
import scala.reflect.runtime.universe._
typeOf[Int]
lub(typeOf[Int], typeOf[String])
lub(List(typeOf[Int], typeOf[String]))
}
import scala.reflect.runtime.universe._
val cm = runtimeMirror(getClass.getClassLoader)
cm.reflect(f).symbol
cm.reflect(f).symbol.typeSignature
def typeOf[T: TypeTag](x: T) = typeOf[T]
def typeOf[T: TypeTag](x: T) = ru.typeOf[T]
def typeOf[T: TypeTag](x: T) = scala.reflect.runtime.universe.typeOf[T]
typeOf(f)
typeOf[Int]
def typeOf[T: TypeTag] = scala.reflect.runtime.universe.typeOf[T]; def typeOf[T: TypeTag](x: T) = scala.reflect.runtime.universe.typeOf[T]
typeOf[Int]
typeOf(f)
import scala.reflect.runtime.{universe => ru}
def typeOf[T: ru.TypeTag](x: T) = ru.typeOf[T]
typeOf(f)
val mt = typeOf(f)
val MethodType(param :: Nil, ret) = mt
showRaw(mt)
import scala.reflect.runtime.{universe => ru}
def typeOf[T: ru.TypeTag](x: T) = ru.typeOf[T] // capture compile-time type info
val tpe = typeOf(f)
val f = (r: {val s: String}) => {}
val tpe = typeOf(f)
showRaw(tpe)
ru.showRaw(tpe)
val TypeRef(_, _, refinement :: _) = tpe
val ru.TypeRef(_, _, refinement :: _) = tpe
import scala.reflect.runtime.{universe => ru}
import scala.reflect.runtime.universe._
def typeOf[T: ru.TypeTag](x: T) = ru.typeOf[T] // capture compile-time type info
val f = (r: {val s: String}) => {}
val tpe = typeOf(f)
ru.showRaw(tpe)
val ru.TypeRef(_, _, refinement :: _) = tpe
1 #: 2
import Stream._
1 #:: empty
res1.toList
1 #:: 2
1 #:: Stream(2)
res1.tail
res2.tail
typeOf[List[_]].typeSymbol
import scala.reflect.runtime.universe._
typeOf[List[_]].typeSymbol
class D[T] { def m: T = ??? }
scala> import scala.reflect.runtime.{universe => ru}
import scala.reflect.runtime.{universe=>ru}
scala> import scala.reflect.runtime.universe._
import scala.reflect.runtime.universe._
scala> def typeOf[T: ru.TypeTag](x: T) = ru.typeOf[T] // capture compile-time type info
typeOf: [T](x: T)(implicit evidence$1: reflect.runtime.universe.TypeTag[T])reflect.runtime.universe.Type
scala> val f = (r: {val s: String}) => {}
f: AnyRef{val s: String} => Unit = <function1>
scala> val tpe = typeOf(f)
tpe: reflect.runtime.universe.Type = scala.AnyRef{val s: String} => Unit
scala> ru.showRaw(tpe)
res0: String = TypeRef(ThisType(scala), scala.Function1, List(RefinedType(List(TypeRef(ThisType(scala), newTypeName("AnyRef"), List())), Scope(newTermName("s"))), TypeRef(ThisType(scala), scala.Unit, List())))
scala> val ru.TypeRef(_, _, refinement :: _) = tpe
refinement: reflect.runtime.universe.Type = scala.AnyRef{val s: String}
import scala.reflect.runtime.{universe => ru}
import scala.reflect.runtime.universe._
def typeOf[T: ru.TypeTag](x: T) = ru.typeOf[T]
val f = (r: {val s: String}) => {}
val tpe = typeOf(f)
ru.showRaw(tpe)
val ru.TypeRef(_, _, refinement :: _) = tpe
import scala.tools.reflect.ToolBox
val tb = ru.runtimeMirror(getClass.getClassLoader).mkToolBox()
val ru.RefinedType(_, decls) = refinement
val context = Map("s" -> "hello")
def declsToSyntheticClassDef(decls: List[Symbol]): ClassDef = {
ClassDef(NoMods, newTypeName("C"), Nil, Template(Nil, emptyValDef, decls map (decl => {
ValDef(NoMods, decl.name, TypeTree(decl.typeSignature), Ident(build.newFreeTerm(decl.name.toString, decl.typeSignature, context(decl.name.toString)))
}
def declsToSyntheticClassDef(decls: List[Symbol]): ClassDef = {
ClassDef(NoMods, newTypeName("C"), Nil, Template(Nil, emptyValDef, decls map (decl => {
ValDef(NoMods, decl.name, TypeTree(decl.typeSignature), Ident(build.newFreeTerm(decl.name.toString, decl.typeSignature, context(decl.name.toString)))
})
def declsToSyntheticClassDef(decls: List[Symbol]): ClassDef = {
ClassDef(NoMods, newTypeName("C"), Nil, Template(Nil, emptyValDef, decls map (decl => {
ValDef(NoMods, decl.name, TypeTree(decl.typeSignature), Ident(build.newFreeTerm(decl.name.toString, decl.typeSignature, context(decl.name.toString))))
})))
}
def declsToSyntheticClassDef(decls: List[Symbol]): ClassDef = {
ClassDef(NoMods, newTypeName("C"), Nil, Template(Nil, emptyValDef, decls map (decl => {
ValDef(NoMods, decl.name.toTermName, TypeTree(decl.typeSignature), Ident(build.newFreeTerm(decl.name.toString, decl.typeSignature, context(decl.name.toString))))
})))
}
def declsToSyntheticClassDef(decls: List[Symbol]): ClassDef = {
ClassDef(NoMods, newTypeName("C"), Nil, Template(Nil, emptyValDef, decls map (decl => {
  def referenceContext(name: String) = {
    val freeTerm = build.newFreeTerm(decl.name.toString, context(decl.name.toString))
    build.setTypeSignature(freeTerm, decl.typeSignature)
  }
  ValDef(NoMods, decl.name.toTermName, TypeTree(decl.typeSignature), Ident(referenceContext(decl.name.toString)))
})))
}
declsToSyntheticClassDef(decls)
declsToSyntheticClassDef(decls.toList)
decls.toList(0)
showRaw(decls.toList(0).typeSignature)
decls.toList(0).typeSignature
def declsToSyntheticClassDef(decls: List[Symbol]): ClassDef = {
ClassDef(NoMods, newTypeName("C"), Nil, Template(Nil, emptyValDef, decls map (decl => {
  val NullaryMethodType(typeOfVal) = decl.typeSignature
  val refToContextVal = build.newFreeTerm(decl.name.toString, context(decl.name.toString))
  build.setTypeSignature(refToContextVal, typeOfVal)
  ValDef(NoMods, decl.name.toTermName, TypeTree(decl.typeSignature), Ident(refToContextVal))
})))
}
  ValDef(NoMods, decl.name.toTermName, TypeTree(decl.typeSignature), Ident(refToContextVal))
declsToSyntheticClassDef(decls.toList)
reify({ class C; new C })
import scala.reflect.runtime.universe._
reify({ class C; new C })
reify({ class C; new C; () })
showRaw(res2.tree)
import scala.reflect.macros.Context
class Helper[C <: Context with Singleton](val c: C) {
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper[c.type](c)
c.Expr(helper.generate)
}
class Helper[C <: Context](val c: C) {
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper[c.type](c)
c.Expr(helper.generate)
}
import scala.reflect.runtime.universe._
val t = reify ( (_: List[Any]).contains(null) ).tree
showRaw(t, printIds = true)
import scala.reflect.runtime.universe._
val t = reify ( (_: List[Any]).contains(null) ).tree
exit
import scala.reflect.runtime.universe._
val t = reify ( (_: List[Any]).contains(null) ).tree
showRaw(t, printIds = true)
import scala.reflect.runtime.universe._
showRaw(t, printIds = true)
val t = reify ( (_: List[Any]).contains(null) ).tree
showRaw(t, printIds = true)
2
Ident
cm
exit
ru
Ident
1
2
reify(ru).eval
import scala.util.continuations
reset
shift
List(1, 2).dis
List(1, 2).distinct
List(1, 1, 2).distinct
{ class B(b:Int); typeTag[B] }
{ class B(b:Int); weakTypeTag[B] }
exit
{ class B(b:Int); weakTypeTag[B] }
exit
{ class B(b:Int); typeTag[B] }
reify(List(1, 2))
exit
reflect.runtime.universe.reify { trait Foo { val a: Int } }
exit
reflect.runtime.universe.reify { trait Foo { val a: Int } }
exit
reflect.runtime.universe.reify { trait Foo { val a: Int } }
exit
reflect.runtime.universe.reify { trait Foo { val a: Int } }
exit
reflect.runtime.universe.reify { trait Foo { def a: Int } }
reflect.runtime.universe.reify { trait Foo { val a: Int } }
def f[A,B,C,D]:((A,B)) => (C,D) = ???
typeOf[f]
def typeOf[T: TypeTag](x: T) = typeOf[T]
def typeOf[T: TypeTag](x: T) = ru.typeOf[T]
typeOf(f)
typeOf(f _)
def typeOf[T: TypeTag](x: T) = ru.typeOf[T]
class C { def f[A,B,C,D]:((A,B)) => (C,D) = ???; print(typeOf(this.f)) }
new C
class C { def f[A,B,C,D]:((A,B)) => (C,D) = ???; print(typeOf(this.f _)) }
class C { def f[A,B,C,D]():((A,B)) => (C,D) = ???; print(typeOf(this.f _)) }
new C
class C { def f[A,B,C,D]():((A,B)) => (C,D) = ??? }
typeOf[C].member(newTermName("f")).typeSignature
class C { def f[A,B,C,D]():((A,B)) => (C,D) = ??? }
typeOf[C].member(newTermName("f")).typeSignature
class C { def f[A,B,C,D]:((A,B)) => (C,D) = ??? }
typeOf[C].member(newTermName("f")).typeSignature
class C { def g[A,B]: ((A,B)) = ??? }
typeOf[C].member(newTermName("g")).typeSignature
def g[A,B]: ((A,B)) = ???
showRaw(res0)
showRaw(res1)
List(1, 2).mkString
def pp(x: Int) = x
List(1, 2) map pp
List(1, 2).map(pp(_))
for (t <- List(1, 2)) yield List(t)
for (t <- List(1, 2)) yield Nil
for (i <- 0 until 2) yield 1
List(1, 2).foldLeft(_ + _)
List(1, 2).foldLeft(0)(_ + _)
List().foldLeft
List().foldLeft _
List().foldLeft[String] _
List[Int]().foldLeft[String] _
type Tree = Int
def prettyprint(tree: Tree): String = ""
List[Tree]().foldLeft("")(_ + ", " + prettyprint(_))
List[Tree]().foldLeft("")(prettyprint(_) + ", " + prettyprint(_))
reify(ru)
showRaw(ru)
showRaw(res0)
showRaw(res0, printIds = true)
{ class C; typeOf[C] }
exit
{ class C; typeOf[C] }
exit
type Tree = Int
def prettyprint(x: Tree): String = ""
List[Tree]().foldLeft("")(_ + "," + prettyprint(_))
type Tree = String
def divsByZero(tree: Tree): List[Tree] = Nil
List[Tree]().foldRight(Nil)(divsByZero(_) :: _)
List[Tree]().foldRight(Nil)(divsByZero(_) :+ _)
List[Tree]().foldRight(Nil)(_ +: divsByZero(_))
List[Tree]().foldRight(List[Tree]())(_ +: divsByZero(_))
List[Tree]().foldRight(List[Tree]())(divsByZero(_) :+ _)
List[Tree]().foldRight(List[Tree]())(divsByZero(_) :: _)
List[Tree]().foldRight(List[Tree]())(divsByZero(_) ::: _)
s"""${"""a"""}"""
  def id[T]: T => T
  def compose[A, B, C](f: B => C, g: A => B): A => C
}
trait PairCategory[F[_,_]] extends Category[F] {
  def affix[A, B, C, D](f: A => B, g: C => D): (A, B) => (C, D)
}
trait Circuitry[F[_,_]] extends PairCategory[F] {
  def passr[A, B, X](f: A => B): (A, X) => (B, X)
  def passl[X, C, D](g: C => D): (X, C) => (X, D)
  override def affix[A, B, X, Y](f: A => B, g: X => Y): (A, X) => (B, Y) = {
    compose[(A, X), (B, X), (B, Y)](passl[B, X, Y](g), passr[A, B, X](f))
  }
}
def foo = macro impl
type Foo(x: Int) = Int
class C { type Foo <: macro Impl }
type Foo(x: Int) = Int
type Foo(x: Int)
type Foo(x: Int) = ???
type Foo(x: Int) = macro ???
type Foo(x: Int)
type Foo(x: Int) = macro ???
type Foo(x: Int)
=
...
type Foo + Bar
type Foo(x: Int)
=
d
type Foo(x: Int) +
type Foo(x: Int) = Int
type Foo: Int = Int
type Foo(x: Int) = macro impl
exit
typeOf[Macros]
classOf[Macros]
classOf[Macros.type]
classOf[Int]
type X = Macros
X
type X = Macros1
Macros.impl
exit
Macros.impl
exit
MyMacors
MyMacros
typeOf[MyMacros.type]
typeOf[MyMacros.type].typeSymbol
typeOf[MyMacros.type].members
typeOf[MyMacros.type].members.toList(0)
res5.name
res5.name.isTypeName
typeOf[Macros.type].members
typeOf[MyMacros.type].members
typeOf[MyMacros.type].members.toList(0)
typeOf[MyMacros.type].members.toList(0).name
typeOf[MyMacros.type].members.toList(0).name.isTypename
typeOf[MyMacros.type].members.toList(0).name.isTypeName
def foo[+T] = ???
def sc
)))
def foo
def f(x: Int) = 0 
val g = ru.reify(f _) 
ru.reify(g.splice _) 
val g1 = f _
val  g2 = g1 _
type Foo[+T] = macro ???
type Foo[+T] = Int
type Foo[+T] = macro bar
)
type Foo[+T] = macro ???
def foo
type Foo = { def x = 2 }
type Foo = { type Qqq(x: Int) = macro ??? }
type T = Int
type T[U] = Int
type T[+U] = Int
type T[U: List] = Int
type T[U, W: List] = Int
type T[+U]() = Int
type T[+U]: Int = Int
type T[U]: Int = Int
type T[U](): Int = Int
def foo = macro impl
ru
reify{ @deprecated("", "") def foo = 2 }
showRaw(res0)
typeOf[Macros].members.toList
typeOf[Macros.type].members.toList
typeOf[Macros.type].members.toList(1)
res2.annotations
typeOf[Macros.type].members.toList(1).annotations
exit
class X(x: Int)
class C extends X(2)
class C extends X(2) with X(3)
def impl(c: Context) = { c.info(c.universe.NoPosition, "hello", force = true); c.literalUnit }
def foo = macro impl
foo
def foo(f: String => Array[String])(s: String) = ()
foo _
foo(Array(_))
foo(Array(_)) _
def foo(f: String => Array[String])(s: String) = ()
foo(Array(_)) _
def foo(f: String => Array[String])(s: String) = ()
foo(Array(_)) _
def impl(c: Context) = c.literalUnit
def foo = macro impl
foo _
res0
res0()
() _
def impl(c: Context)(x: c.Expr[Int]) = c.literalUnit
def foo(x: Int) = macro impl
foo _
stree
exit
val test = foo(Array(_)) _
def foo(f: String => Array[String])(s: String) = f(s)
val test = foo(Array(_)) _
test("x")
exit
def foo = ???
reify(foo _)
class C(x: Int, y: Int)
class D(x: Int, y: Int) extends C(x, y)
{ def z(x: Int) = x; reify(z _) }
{ def z = 2; reify(z _) }
import scala.tools.reflect.Eval
{ def z = 2; reify(z _).eval }
res2()
{ def z = 2; reify(z).eval }
val x = { self: String => }
trait U
class C extends {} with U
class C extends { self: U => } with U
3 +: List(1, 2)
class B(x: Int)
class C extends B(2, 2)
class C[T: List] extends B(2, 2)
def foo(x: Int) = x
exit
typeOf[Macros.type].members
typeOf[Macros.type].members.toList(0)
typeOf[Macros.type].members.toList(0).name
typeOf[Macros.type].members.toList(0).name.isTerm
typeOf[Macros.type].members.toList(0).name.isTermName
exit
def impl[T: c.WeakTypeTag](c: Context) = c.literalUnit
def foo[T] = macro impl[T]
foo
def foo(a: Int, b: Int = 0) = a
def foo(a: Double, b: Int = 0) = a
{ def foo(a: Int, b: Int = 0) = a; def foo(a: Double, b: Int = 0) = a }
class C{ def foo(a: Int, b: Int = 0) = a; def foo(a: Double, b: Int = 0) = a }
kep
{ type 
{ type Foo = Any; }
{ type Foo <: Any }
class Arrrr[A](initSize: Int) { new Array[A](2) }
class Arrrr[A](initSize: Int) { def init(initSize: Int) { new Array[A](initSize) } }
class Arrrr[A](initSize: Int) { def init(initSize: Int) { var it = new Array[A](initSize) } }
class ArrayUser[A /*: ClassTag*/](initSize:Int) {
  var it: Array[A] = _
  initIt(initSize)
  def initIt(initSize:Int) { it = new Array[A](initSize) }
}
  val ff = u.reify {
    def f(x:Int):Int = x*2
    f _
  }
  println(u showRaw ff)
  import scala.tools.reflect.Eval
  def g = ff.eval
  println(g)
  println(g(3))
val ff = reify { def f(x: Int): Int = x * 2; f _ }
println(showRaw(ff)
)
ff.eval
val ff = reify { def f(x: Int): Int = x * 2; x => f(x) }
ff.eval
val ff = reify { def f(x: Int): Int = x * 2; (x: Int) => f(x) }
ff.eval
res6
res6(3)
reify { def f(x: Int) = x; f _ }
res0.eval
reify { def f(x: Int) = x; x => f(x) }
res2.eval
reify { def f(x: Int) = x; x => f(x) }
showRaw(res4)
res4.eval
reify { def f(x: Int) = x; f _ }
showRaw(res7)
res7.eval
exit
class C extends Foo[Int]("2")
class C extends Macros.Foo[Int]("2")
new C().toString
new C.toString
exit
class C extends Foo[Int]("2")
class C extends Macros.Foo[Int]("2")
new C
class C
new C
new C()
class C extends Foo[Int]("2")
class C extends Macros.Foo[Int]("2")
new C
new C().hello
class C extends Macros.Foo[Int]("2")
new C().hello
class C extends Macros.Foo[Int]("2")
new C().hello
class C extends AnyRef with Macros.Foo[Int]("2")
class C extends AnyRef() with Macros.Foo[Int]("2")
exit
class C extends AnyRef with Macros.Foo[Int]("2")
new C().hello
class C extends AnyRef with Macros.Foo[Int]("2")
new C().hello
exit
{ val z = () => 2; reify(z) }
res0.eval
{ def z() = 2; val zz = z _; reify(zz) }
res0.eval
{ def z() = 2; reify(z()) }
res4
res4.eval
class C extends AnyRef with Macros.Foo[Int]("2")
new C().hello
exit
object foo
object =.
object =>
object <=>
val _ = 2
object _
_
object *
:power
Ident(newTermName("x"))
res0 == res1
res0.equalsStructure(res1)
class B[T]
class C extends B
trait Foo extends B;
class C extends B;
class B[T](x: T)
new { val x = 2 } with B(x)
foo.super[bar[
foo.super[bar]
cm.staticPackage("foo")
def foo(c: Context) = c.literal(c.mirror.staticPackage("foo"))
def foo(c: Context) = c.literal(c.mirror.staticPackage("foo").toString)
def bar = macro foo
bar
class C
new C
exit
class C[T]
class C[T](x: T)
class C[T]
trait Foo[T] extends C[T]
class X extends Foo
:power
NoSymbol.initialize
class C
class D extends C
class E extends D with C
class C
new (C)
new (C)()
val x = List(1, 2, 3)
val init :+ last = x
trait T
class C extends T()
class C extends AnyRef with T()
trait T
class C extends T()()
class C(x: Int)
new { val x = 2 } with C(x: Int)
res0.x
}}
trait Wrapper[T](x : T) {}
trait Foo <: Int
trait Bar
trait Foo <: Bar
trait Foo extends { val x = 2 } with Bar
trait Foo extends { val x = 2 } with Bar(2)
trait Bar
trait Foo extends { val x = 2 } with Bar(2)
class C(x: Int)
trait T extends C(2)
class C(x: Int)
trait T extends C(2)
exit
class C(x: Int)
trait T extends C(2)
    object HasStuff extends Dynamic {
      def selectDynamic(name: String): String = s"I have $name!"
    }
HasStuff.foo
class C extends HasStuff.foo
trait T
class C extends T(2)
class C
class D extends AnyRef with C
trait Bar
trait Foo extends { val x = 2 } with Bar(2)
trait Bar
trait Foo extends { val x = 2 } with Bar(2)
trait Bar
trait Foo extends { val x = 2 } with Bar(2)
exit
trait Bar
trait Foo extends { val x = 2 } with Bar(2)
trait T
class C extends T
class C extends T()
exit
trait T
class C extends T
class C extends T()
new T {}
new T
new T() {}
new C
new C()
exit

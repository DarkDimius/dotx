class C extends { type T = Int } with A
class B[T]
class C extends { type T = Int } with B[T]
class B(x: Int)
class C extends { val x = 2 } with B(2)
class B[T]
class C extends { type T = Int } with B[T]
impl2
class C extends { type T = macro impl2 } with AnyRef
exit
class C extends { val x = 2 } with B(x)
exit
type T = macro impl2
typeOf[T]
def foo = macro impl1
reify(foo)
res1.eval
class C(x: Int)(y: Int) extends scala.annotation.StaticAnnotation
class X @C(2)(3) ()
class X @C(2) ()
class ann1(x: Int) extends scala.annotation.StaticAnnotation
class C @ann1(2) ()
class ann2(x: Int)(y: Int) extends scala.annotation.StaticAnnotation
class C @ann2(2)(3) ()
exit
def foo( = macro impl
def foo( = macro impl)
def foo() = (macro impl
)
val macro = 1
def foo() = (macro impl
)
def foo = macro impl1
implicit class IntExt(i: Int) { def impl = 2 }
def foo() = (macro impl)
def foo() = (macro impl()
exit
Ident(newTermName("x")).attachmetns
Ident(newTermName("x")).attachments
exit
class C; object C { implicit val list = List[C](new C) }
exit
new B().toString
exit
reify{ object C }
showRaw(res0.tree)
exit
class C; object C extends C
class C { println(C); }; object C
new C
exit
typeOf[_ => _]
typeOf[_ => _].typeSymbol.typeSignature
exit
class C extends Any
class C extends AnyRef
def foo = { println("foo"); 1 }
foo #:: foo #:: Stream.Empty
def foo: Int = { println("foo"); 1 }
1 :: 2 :: Nil
foo #:: foo #:: Stream.Empty
1 #:: 2 #:: Stream.Empty
1 #:: Stream.Empty
1 #:: Stream.empty
foo #:: foo #:: Stream.Empty
foo #:: foo #:: Stream.empty
def foo1: Int = { println("foo1"); 1 }
def foo2: Int = { println("foo2"); 2 }
foo1 #:: foo2 #:: Stream.empty
Stream.iterate(1)(_)
Stream.iterate(1)(x => x)
List(1, 2) flatMap { case 1 => Some(1) }
List(1, 2) collect { case 1 => Some(1) }
List(1, 2) collect { case 1 => 1 }
foo1 #:: foo2 #:: Stream.empty
def foo1: Int = { println("foo1"); 1 }
def foo2: Int = { println("foo2"); 2 }
foo1 #:: foo2 #:: Stream.empty
res4 match { case hd #:: tl => }
Lisr(1, 2, 3) match { case hd #:: tl => }
List(1, 2, 3) match { case hd #:: tl => }
List(1, 2) collect { case 1 => println("x") }
exit
List(1, 2) match { case List(x, xs: _*) => }
List(1, 2) match { case xs :+ x => println(xs, x) }
List(1, 2) match { case xs ++ ys => xs }
trait Fooable[T]
class C; object C { implicit val x = new Fooable[C]{} }
implicitly[Fooable[C]]
trait Fooable[T]
class C; object C { implicit val x = new Fooable[C]{} }
implicitly[Fooable[C]]
exit
import scala.reflect.runtime.universe.{typeOf, TypeRef}
typeOf[Int] match { case TypeRef(_, sym, _) => println(sym) }
import scala.reflect.runtime.universe.TypeRefTag
typeOf[Int] match { case TypeRef(_, sym, _) => println(sym) }
exit
NoSymbol.associatedFile
staticClass("Int")
getClass("Int")
getDefinedClass("Int")
getClassByName("Int")
definitions.getClassByName("Int")
rootMirror.getClassByName("Int")
rootMirror.getClassByName(newTypeName("Int"))
rootMirror.getClassByName(newTypeName("scala.Int"))
res8.associatedFile
rootMirror.getClassByName(newTypeName("scala.collection.immutable.List"))
res10.associatedFile
res10.associatedFile.getFile
res10.associatedFile.path
case class C(x: Int)
new C().productIterator
new C(2).productIterator
new C(2).asInstanceOf[Product]
new C(2).asInstanceOf[Product].productIterator.toList
for (i <- 0 to 2) println(i)
import scala.collection.mutable.ListMap
ListMap(1 -> 2)
(2 -> 3) +: ListMap(1 -> 2)
(2 -> 3) + ListMap(1 -> 2)
(2 -> 3) ++: ListMap(1 -> 2)
(2 -> 3) +: ListMap(1 -> 2).toList
sys.props("foo")
Some(2) collect { case x == 3 => x }
Some(2) collect { case x if x == 3 => x }
q""
exit
q""
val x = ValDef(NoMods, TermName("x"), Ident(TypeName("Int")), EmptyTree)
q"def foo($x)"
exit
q"def foo($x)"
q"{ $x }"
exit
Block(Literal(Constant(2))
)
exit
object 
)
object X { { val x = 2 } }
object X { { val x = 2 } println(x) }
object X { { val x = 2 }; println(x) }
object X { { val x = 2 } }
X.x
val _1 = 2
_1
s"${_}"
_
List("x") map (s"${_}")
exit
reify{List[String]()}
reify{List[String]("a")}
type X = Int
reify{List[X](2)}
exit
List(1) ++ List(2)
def foo e
class foo extends scala.annotation.StaticAnnotation
class C @foo (x: Int)
class foo extends scala.annotation.StaticAnnotation
def impl(c: Context) = c.universe.Ident(c.universe.TypeName("Int"))
@foo({def fooInAnn = macro Impls.foo; fooInAnn})
  def foo = println("it works")
class foo(val bar: Int) extends annotation.StaticAnnotation
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.TypeName("Int"))
@foo({ type Foo(x: Int) = macro Impls.foo; class D extends Foo(2); val x: Foo(2) = new D; x.x })
  def foo = println("it works")
@foo({ type Foo(x: Int) = macro impl; class D extends Foo(2); val x: Foo(2) = new D; x.x }) def foo = ???
class
C
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.TypeName("C"))
@foo({ type Foo(x: Int) = macro impl; class D extends Foo(2); val x: Foo(2) = new D; x.x }) def foo = println("it works")
{ class C; @foo({ type Foo(x: Int) = macro impl; class D extends Foo(2); val x: Foo(2) = new D; x.x }) def foo = println("it works") }
exit
q"class Foo extends ${tq"Bar"}"
q"class Foo extends ..${List(tq"Bar", tq"Baz")}"
val q"class Foo extends ..$parents" = res1
q"package foo"
val v = q"val x: Int"
q"def foo($v)"
val v: ValDef = q"val x: Int"
val v: Tree = q"val x: Int"
q"def foo($v)"
q"def foo(${TermName("x")})"
def impl(c: Contex
def impl(c: Context) = c.abort(c.enclosingPosition, "macro has reported an error")
def test = macro impl
test
val q"foo(...$argss)" = q"foo(2)(3)"
val name = newTermName("foo")
val name = TermName("foo")
val name = TypeName("C")
val q"class $name1" = q"class $name"
val args = List(Literal(Constant(2)))
val q"foo(..$args)" = q"foo(..$args)"
val q"foo(..$args1)" = q"foo(..$args)"
val q"foo(..$args1)" = q"foo($args)"
val argss = List(List(Literal(Constant(2))), List(Literal(Constant(3)))))
val argss = List(List(Literal(Constant(2))), List(Literal(Constant(3))))
val q"foo(..$argss1)" = q"foo(..$argss)"
val q"foo(...$argss1)" = q"foo(...$argss)"
q"foo(...$argss)
q"foo(...$argss)"
val argss = List(List(Literal(Constant(2))), List(Literal(Constant(3)))))
val argss = List(List(Literal(Constant(2))), List(Literal(Constant(3))))
q"foo(...$argss)"
val foo = TermName("foo")
q"$foo(...$argss)"
q"$foo()(...$argss)"
case class Foo[A <: TypeTag]
case class Foo[A: TypeTag]
case class Foo[A: TypeTag](xs: List[A])
"foo.bar".split(".")
"foo.bar".split("b")
"foo.bar".split(".")
"foo.bar".split(Pattern.quote("."))
"foo.bar".split(java.util.regex.Pattern.quote("."))
"foo".split(java.util.regex.Pattern.quote("."))
"".split(java.util.regex.Pattern.quote("."))
typeOf[List].typeSymbol.fullName
typeOf[List[_]].typeSymbol.name
typeOf[List[_]].typeSymbol.fullName
Select(Ident(TermName("foo")), TermName("bar"))
def 
))
def impl(c: Context)(x: c.Expr[String]) = x
def foo = macro impl
def foo(x: String) = macro impl
foo("""z""")
def impl(c: Context)(x: c.Expr[String]) = { println(showRaw(x)); x }
def foo(x: String) = macro impl
foo("""zzz""")
def impl(c: Context)(x: c.Expr[String]) = { println(showRaw(x.tree)); x }
def foo(x: String) = macro impl
foo("""zzz""")
foo(s"zzz")
def impl(c: Context)(x: c.Expr[String]) = { println(showRaw(x.tree)); println(c.eval(x)); x }
def foo(x: String) = macro impl
foo(s"zzz")
val ct = classTag[List[_]]
ct.unapply(List(2))
ct.unapply(Map(1 -> 2))
def impl(c: Conte
def impl(c: Context) = c.universe.Ident(c.universe.TypeName("C"))
type foo = macro impl
def impl(c: Context) = c.universe.Ident(c.universe.TypeName("C"))
type foo = macro impl
type X = foo
type Foo = impl2
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
def foo = 2
foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
q"x"
exit
q"x"
exit
typeTag[String]
showRaw(typeTag[String], printIds = true)
typeOf[ClassManifest].typeSymbol.annotations
typeOf[ClassManifest[_]].typeSymbol.annotations
cm.staticPackage("scala")
cm.staticPackage("scala").typeSignature.member(newTermName("package"))
res3.typeSignature.getMember(newTypeName("cloneable"))
res3.typeSignature.member(newTypeName("cloneable"))
res5.annotations
class C { def x = 2 }
cm.reflect(new C)
val cm = scala.reflect.runtime.currentMirror
cm.reflect(new C)
res1.reflectMethod(typeOf[C].member(newTermName("x")).asMethod)
res1.reflectMethod(scala.reflect.runtime.universe.typeOf[C].member(newTermName("x")).asMethod)
import scala.reflect.runtime.universe._
res1.reflectMethod(typeOf[C].member(newTermName("x")).asMethod)
res4.bind(new C)
res4()
res5()
class C { class D }
val c = new C
c.D
typeOf[c.D]
showRaw(typeOf[c.D])
{ val c = new C; showRaw(typeOf[c.D]) }
{ var c = new C; showRaw(typeOf[c.D]) }
trait TypezSig {
  case class Num(i:Int,f:Float)
  case class Mat(rows:Num,cols:Num)
  type Alphabet = Mat
  type Answer = (Num,Mat)
}
typeOf[TypezSig#Num]
trait TypezSig {
  case class Num(i:Int,f:Float)
  case class Mat(rows:Num,cols:Num)
  type Alphabet = Mat
  type Answer = (Num,Mat)
}
object Typez extends TypezSig {
  import scala.reflect.runtime.universe._
  import scala.reflect._
  def foo[Alphabet,Answer]()(implicit t1:TypeTag[Alphabet],t2:TypeTag[Answer],c1:ClassTag[Alphabet],c2:ClassTag[Answer],m1:Manifest[Alphabet],m2:Manifest[Answer]) {
  println(t1.tpe.toString+" --- "+c1.toString+" --- "+m1.toString)
  println(t2.tpe.toString+" --- "+c2.toString+" --- "+m2.toString)
  }
  foo[Alphabet,Answer]();
}
Typez
exit
val x = classTag[List[Int]]
val y: ClassTag[List[_]] = x
exit
{ def foo(x: Int) = x; def foo(x: Int*) = x }
class C{ def foo(x: Int) = x; def foo(x: Int*) = x }
new C().foo(1)
new C().foo(1, 2)
new C().foo()
typeOf[List[_]].typeSymbol.fullName
trait Foo[T]; object Foo { implicit object FooString extends Foo[String] }
def foo[T: Foo](x: T)
= ???
def foo[T: Foo](x: T) = x
foo(1)
foo("1")
class Qwe { trait Foo[T]; object Foo { implicit object FooString extends Foo[String] } }
class Qwe { trait Foo[T]; object Foo { implicit object FooString extends Foo[String] }; def foo[T: Foo](x: T) = x }
new Qwe().foo(1)
new Qwe().foo("1")
val qwe = new Qwe()
qwe.foo(1)
qwe.foo("1")
exit
{ class C; weakTypeOf[C] }
cm.runtimeClass(res0)
showRaw(res0)
showRaw(res0, printIds = true, printKinds = true)
classOf[List[_]].getName
typeOf[List[_]].typeSymbol.typeSignature
typeOf[List[_]].typeSymbol.typeParams
typeOf[List[_]].typeSymbol.asClass.typeParams
exit
locally { class E; manifest[E] }
exit
  def _seq = _op(";")_
def _op (opSymbol: String)(children: Int*)  = {}
  def _seq = _op(";")_
null eq null
exit
val q"x" = Ident(TermName("x"))
val q"$x" = Ident(TermName("x"))
1 to 5
1 to 5 map (_)
1 to 5 map (x => x)
q"x"
def impl(c: Context) = { import c.universe._; println(showRaw(c.macroApplication, printPositions = true); c.literalUnit
def impl(c: Context) = { import c.universe._; println(showRaw(c.macroApplication, printPositions = true); c.literalUnit }
def impl(c: Context) = { import c.universe._; println(showRaw(c.macroApplication, printPositions = true)); c.literalUnit }
import scala.reflect.macros.Context
def impl(c: Context) = { import c.universe._; println(showRaw(c.macroApplication, printPositions = true)); c.literalUnit }
def foo = macro impl
foo
case class C(x: Int)
typeOf[X].fields
typeOf[X].declarations
typeOf[C].declarations
typeOf[C].declarations.filter(_.isCaseAccessor)
typeOf[C].declarations.collect{ case x: TermSymbol if x.isCaseAccessor => x }
typeOf[C].declarations.collect{ case x: TermSymbol if x.isParamAccessor => x }
typeOf[C].declarations.collect{ case x: TermSymbol if x.isValue && x.isCaseAccessor => x }
typeOf[C].declarations.collect{ case x: TermSymbol if x.isVal && x.isCaseAccessor => x }
exit
cl
class C { def foo[T]: T = ??? }
val sym = typeOf[C].declaration(TermName("foo")).asMethod
sym.typeSignature
def impl[A](c: reflect.makro.Context) = c.reify(())
def impl[A](c: reflect.macros.Context) = c.reify(())
def impl[A](c: reflect.macros.Context) = c.universe.reify(())
def decl[A] = macro impl[A]
decl
def impl[A](c: reflect.macros.Context) = c.universe.reify(())
def decl[A] = macro impl[A]
decl
object impl { def apply = "" }
impl
impl()
object M { def apply[T, U](x: Int) = ??? }
M[Int, Int]
object M { def apply[T, U] = ??? }
M[Int, Int]
def impl(c: Context): Unit = c.enclosingMethod match {
case DefDef(_, name, _, _, _, _) => c.universe.reify(println(c.literal(name.toString).splice))
case _ => c.abort(c.enclosingPosition, "no enclosing method")
}
def impl(c: Context): Unit = {
import c.universe._
c.enclosingMethod match {
case DefDef(_, name, _, _, _, _) => c.universe.reify(println(c.literal(name.toString).splice))
case _ => c.abort(c.enclosingPosition, "no enclosing method")
}
def printEnclosingMethod = macro impl
def impl(c: Context) = {
import c.universe._
c.enclosingMethod match {
case DefDef(_, name, _, _, _, _) => c.universe.reify(println(c.literal(name.toString).splice))
case _ => c.abort(c.enclosingPosition, "no enclosing method")
}
def printEnclosingMethod = macro impl
def foo = printEnclosingMethod
foo
printEnclosingMethod
exit
import scala.reflect.runtime.{universe => ru}
trait X { def foo: String }
ru.typeOf[X]
res0.members
res0.members.sorted
def foo[T](x: T) = x.getClass
foo(List(1, 2, 3))
def foo[T: ru.TypeTag](x: T) = ru.typeOf[T]
foo(List(1, 2, 3))
ru.showRaw(res4)
import scala.reflect.runtime.universe._
import scala.tools.reflect.ToolBox
val tree = Apply(Select(Literal(Constant(40)),
    newTermName("$plus")), List(Literal(Constant(2))))
val cm = ru.runtimeMirror(getClass.getClassLoader)
println(cm.mkToolBox().eval(tree))
def impl(c: Context) = { c.error(c.enclosingPosition, "foo"); c.error(c.enclosingPosition, "bar"); c.literalUnit }
def foo = macro impl
foo
def impl(c: Context) = { c.warning(c.enclosingPosition, "foo"); c.warning(c.enclosingPosition, "bar"); c.literalUnit }
def foo = macro impl
foo
def impl(c: Context) = { c.error(c.enclosingPosition, "foo"); c.warning(c.enclosingPosition, "bar"); c.literalUnit }
def foo = macro impl
foo
if (false) Array("qwe") else Array[Nothing]()
class C(val x: Int) extends AnyVal
class D { val c = new C(2) }
reify(Nil: _*)
exit
List(1) match { case _ :: Nil => }
List(1, 2) match { case _ :: Nil => }
List() match { case _ :: Nil => }
List(1, 2) match { case _ +: Nil => }
List(1, 2) match { case _ ::: Nil => }
List(1, 2) match { case _ :+ Nil => }
List(1, 2) match { case _ :+ _ => }
List(1) match { case _ :+ _ => }
List() match { case _ :+ _ => }
List() match { case _ :: _ => }
List(1) match { case _ :: _ => }
List(1, 2) match { case _ :: _ => }
List(1, 2) match { case _ :+ superCall => }
List(1) match { case _ :+ superCall => }
List() match { case _ :+ superCall => }
class C @ann (x: Int)
class C @ann() (x: Int)
class C { class I }
def foo(c: C) = new c.I()
def foo(c: => C) = new c.I()
class A
(ru: scala.reflect.api.Universe).typeOf[A]
ru.typeOf[A]
(ru: scala.reflect.api.Universe).typeTag[A]
(ru: scala.reflect.api.Universe).weakTypeTag[A]
Some(null)
Option(null)
Option(2)
Option(null)
Some(null)
Option(None)
xit
exit
val list = (1 to 10000).toList
    list.par.map(_ + 42)
exit
0 until 5
exit
-1 % 8
1 to 5
1.5.asInstanceOf[Int]
List.range(0, 10)
1.5.asInstanceOf[Int]
0.9.toInt
0 to 1
0 to 15
-(-1 % 8)
class C { def foo(x: Int)(y: Int) = 2 }
typeOf[C].member(TermName("foo")).typeSignature
res0.paramss
typeOf[C].member(TermName("foo")).asMethodSymbol
typeOf[C].member(TermName("foo")).asMethod
res3.paramss
res3.returnType
res3.paramss.tail.foldLeft(MethodType(res3.paramss.head, res3.returnType), (MethodType(_, _)))
res3.paramss.tail.foldLeft(MethodType(res3.paramss.head, res3.returnType))((MethodType(_, _)))
res3.paramss.tail.foldLeft(MethodType(res3.paramss.head, res3.returnType))((acc, params) => MethodType(params, acc))
class C { def foo(x: Int)(y: Int) = 2 }
class C { def foo(x: Int)(y: Int)(z: Int) = 2 }
typeOf[C].member(TermName("foo")).asMethod
val paramss = res9.paramss
val implReturnType = res9.returnType
paramss.tail.foldLeft(MethodType(paramss.head, implReturnType))((acc, params) => MethodType(params, acc))
paramss.init.foldLeft(MethodType(paramss.last, implReturnType))((acc, params) => MethodType(params, acc))
paramss.init.foldRight(MethodType(paramss.last, implReturnType))((acc, params) => MethodType(params, acc))
paramss.init.foldRight(MethodType(paramss.last, implReturnType))((acc, params) => MethodType(acc, params))
paramss.init.foldRight(MethodType(paramss.head, implReturnType))(MethodType(_, _))
res14.asInstanceOf[scala.reflect.internal.Types#Type]
res15.paramss
res15.finalResultType
res15.typeParams
exit
def StringContext(parts: String*) = ???
s"a"
def impl(c: scala..macros.Context) = ???
def impl(c: scala.reflect.macros.Context) = ???
def foo(x: Int) = 2
def foo(x: _) = 2
def impl(c: scala.reflect.macros.Context)(x: c.Tree) = ???
class C { def m(x: _): _ = macro impl }
def impl(c: Context)(x: c.Expr[Int]) = ???
def foo(x: Int = 2) = macro impl
1 match { case 1 | 2 => }
1 match { case 3 | 2 => }
List(1) match { case List(1 | 2) => }
zip(List(1, 2), List(1, 2, 3))
List(1, 2).zip(List(1, 2, 3))
List(1, 2) exists { case 1 => true }
List(1, 2) collect { case 1 => -1; case 3 => -2 }
List(1, 2, 3).init
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = x
def foo(x: Int)(y: Int) = macro impl
foo(2)(3)
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = x
def foo(x: Int)(y: Int) = macro impl
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = x
def foo(x: Int)(y: Int) = macro impl
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = x
def foo(x: Int)(y: Int) = macro impl
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = x
def foo(x: Int)(y: Int) = macro impl
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = x
def foo(x: Int)(y: Int) = macro impl
def impl(c: Context): c.Tree = ???
def foo: Int = macro impl
def impl(c: Context): c.Tree = ???
def foo: Int = macro impl
def foo(x: => Any) = ???
def foo[M[_]] = ()
foo[List]
foo[List[T] forSome { type T }]
val x: List[T] forSome { type T } = List(1, 2)
x ++ 3
x :+ 3
List(1, 2) splitAt -1
List() :+ List(1, 2)
if true Nil else List(1) ++ List(2)
if (true) Nil else List(1) ++ List(2)
2 min 3
min(2, 3)
import Math.min
min(2, 3)
java.lang.Math
scala.Math
java.lang.Math
import java.lang.Math.min
def foo(x: Int*) = x
foo(2, 3, 4)
"(Found in|and)".r.replaceAllIn("Found in", m => m.group(1))
"(Found in|and)".r.replaceAllIn("Foundn", m => m.group(1))
"(Found in|and)".r.replaceAllIn("Foundn", m => m.group(0))
"(Found in|and)".r.replaceAllIn("Foundn", m => m.group(2))
"(Found in|and)".r.replaceAllIn("Foundn", m => m.group)
"(Found in|and)".r.replaceAllIn("Foundn", m => m.groupCount)
"(Found in|and)".r.replaceAllIn("Foundn", m => m.groupCount.toString)
"(Found in|and)".r.replaceAllIn("and", m => m.groupCount.toString)
"(Found in|and)".r.replaceAllIn("and", m => m.group(0))
"(Found in|and)".r.replaceAllIn("and", m => m.group(1))
"(Found in|and)".r.replaceAllIn("and", m => m.group(3))
class C { def foo(x: Int*) = ??? }
typeOf[C].member(TermName("foo")).typeSignature
showRaw(res0)
class C { def m(x: _): _ = macro impl }
import scala.reflect.runtime.universe._
val m = typeOf[C].member(newTermName("m")).asMethod
m.params(0)(0).typeSignature
m.paramss(0)(0).typeSignature
showRaw(m.paramss(0)(0).typeSignature)
def impl(c: Context)(x: c.Tree): c.Tree = ???
def foo(x: _) = macro impl
foo(2)(3)
foo
def impl(c: Context)(x: c.Tree): c.Tree = ???
def foo(x: _) = macro impl
foo(2)(3)
foo
def impl(c: Context)(x: c.Tree): c.Tree = ???
def foo(x: _) = macro impl
foo(2)(3)
foo(2)
foo
def impl(c: Context)(x: c.Tree): c.Tree = ???
def foo(x: Int) = macro impl
foo
foo(2)(3)
def impl(c: Context)(x: c.Tree): c.Tree = c.literal(2)
def impl(c: Context)(x: c.Tree): c.Tree = c.literal(2).tree
def foo(x: Int) = macro impl
foo(2) + foo(3)
def foo(x: Int): Int = macro impl
foo(2)(3)
def impl(c: Context)(x: c.Tree): c.Tree = c.literal(2).tree
def foo(x: Int) = macro impl
foo(2)(3)
def impl(c: Context)(x: c.Tree): c.Tree = c.literal(2).tree
def foo(x: Int) = macro impl
foo(2)(3)
def impl(c: Context)(x: c.Tree): c.Tree = c.literal(2).tree; def foo(x: Int) = macro impl; foo(2)(3)
val cm = universe.runtimeMirror(getClass.getClassLoader)
import scala.tools.reflect.ToolBox
val tb = cm.mkToolBox()
tb.eval(tb.parse("class C; new D"))
tb.frontEnd.infos
case class Country(id: String, name: String) extends Domain
case class Country(id: String, name: String)
typeOf[Country].declarations
typeOf[Country].declarations.collect{ case sym if sym.isVal => sym.asTerm }
typeOf[Country].declarations.collect{ case sym if sym.Term => sym.asTerm }.filter(_.isVal)
typeOf[Country].declarations.collect{ case sym if sym.isTerm => sym.asTerm }.filter(_.isVal)
typeOf[Country].declarations.toList.collect{ case sym if sym.isTerm => sym.asTerm }.filter(_.isVal)
typeOf[Country].declarations.toList.collect{ case sym if sym.isTerm => sym.asTerm }.filter(_.isParamAccessor)
typeOf[Country].declarations.toList.collect{ case sym if sym.isTerm => sym.asTerm }.filter(sym => sym.isVal && sym.ParamAccessor)
typeOf[Country].declarations.toList.collect{ case sym if sym.isTerm => sym.asTerm }.filter(sym => sym.isVal && sym.isParamAccessor)
def impl(c: Context)(x: c.universe.Ident) = ???
def foo(x: _) = macro impl
def foo = macro impl
exit
def foo = macro impl
impl
impl2
def foo = macro impl1
def foo(x) = x
def impl[A](c: reflect.makro.Context) = c.reify(())
def impl[A](c: Context) = c.reify(())
def impl[A](c: Context) = c.literalUnit
def decl[A] = macro impl[A
]
decl[Any]
decl
exit
def foo = macro impl1
foo
exit
lazy List(x, y) = List(1, 2)
lazy val List(x, y) = List(1, 2)
:power
ScalaPackage
ScalaPackageClass
ScalaPackageClass.isModuleClass
ScalaPackageClass.isModule
ScalaPackage.isModule
ScalaPackage.sourceModule
ScalaPackageClass.sourceModule
class C {
lazy val list = List(1, 2)
lazy val List(x, y) = list
}
class C {
private lazy val list = List(1, 2)
lazy val List(x, y) = list
}
def foo = macro impl1
{ class anon { def x = 2 }; new anon }
{ final class anon { def x = 2 }; new anon }
scala.reflect.runtime.universe
res0.asInstanceOf[scala.reflect.internal.SymbolTable]
res1.phase
:power
typer
typer.typedType(EmptyTree)
def foo = macro impl
def foo = macro impl1
foo
class C { def foo(x) = 2 }
class C { def foo(x: Int) = 2 }
new C().foo
def foo = macro impl
def foo = macro impl1
foo
:power
PredefModule.moduleClass
PredefModule.moduleClass.moduleClass
exit
typeOf[java.io.File].declarations.foreach(sym => println(s"$sym, ${sym.privateWithin}"))
class C
classOf[C].getName
typeOf[Int]
class C { def foo: List[Tuple2[Set[Int],Int]] = ??? }
typeOf[C].member(TermName("foo")).typeSignature
Map(1, 2).get(3)
Map(1 -> 2).get(3)
Map(1 -> 2)(3)
List(1, 2) - 1
reify(2)
def foo(x: Int) = x
foo _
def foo(x: Int = 2) = x
foo _
res1
res1()
null.isInstanceOf[Int]
trait Monoid { def neutral: this.type }
class Nat extends Monoid { def neutral = new Nat() }
trait Printable { def print: String }
trait Showable[T] { def show: String }
def show[T: Showable](x: T) = implicitly[Showable[T]].show(x)
trait Showable[T] { def show(x: T): String }
def show[T: Showable](x: T) = implicitly[Showable[T]].show(x)
object IntShowable { def show(x: Int) = x.toString }
show(2)
trait Showable[T] { def show(x: T): String }
def show[T: Showable](x: T) = implicitly[Showable[T]].show(x)
implicit object IntShowable { def show(x: Int) = x.toString }
show("2")
show(2)
trait Showable[T] { def show(x: T): String }
def show[T: Showable](x: T) = implicitly[Showable[T]].show(x)
implicit object IntShowable extends Showable[Int] { def show(x: Int) = x.toString }
show("2")
show(2)
String.concat
String.+
"".concat
class Foo { lazy val x = 2 }
class Bar extends Foo { override lazy val x = 3 }
new Bar().x
class Foo { lazy val x = 2 }
class Bar extends Foo { override lazy val x = 3 }
new Bar().x
class Bar extends Foo { override lazy val x = super.x + 1 }
System.currentTimeMillis
Map(1, 2) map { case (k, v) => (k, v) }
Map(1 -> 2) map { case (k, v) => (k, v) }
exit
clojure.lang.RT.T
import reflect.macros.Context
def foo_impl(c :Context): c.Expr[Any] = { import c.universe._; println(clojure.lang.RT.T); reify("foo") }
def foo = macro foo_impl
import language.experimental.macros
def foo = macro foo_impl
foo
exit
import language.experimental.macros
def foo_impl(c :Context): c.Expr[Any] = { import c.universe._; println(clojure.lang.RT.T); reify("foo") }
import reflect.macros.Context
def foo_impl(c :Context): c.Expr[Any] = { import c.universe._; println(clojure.lang.RT.T); reify("foo") }
def foo = macro foo_impl
foo
def foo_impl(c :Context): c.Expr[Any] = { import c.universe._; c.literalUnit }
Macros.foo
class C[T, M[_]]
val c = typeOf[C].typeSymbol
val c = typeOf[C[_]].typeSymbol
val c = typeOf[C[_, _]].typeSymbol
val c = typeOf[C[_, _[_]]].typeSymbol
val c = typeOf[C[_, List]].typeSymbol
c.info
c.tpe
c.tpe_*
c.tpeHK
{ import List._; }
(1 to 5).product
exit
class C { class D }
1 to 4
class C { object X }
class D extends C { override object X }
class C { object X { def x = 2 } }
class D extends C { override object X { override def x = 3 } }
class D extends C { override object X { def x = 3 } }
new C().X.x
new D().X.x
val x: C = new D()
x.X.x
typeOf[String]
:power
JavaLangPackage
JavaLangPackage.fullName
tb.eval(reify(2))
tb.eval(reify(2).tree)
reify(2).eval
new Any
new Any{}
new Any(){}
new AnyVal
new AnyVal{}
new Any
new Any{}
new AnyVal
new AnyVal{}
typeOf[String]
grh0
2
scala.reflect.runtime.universe
2
{ type T; }
List(1, 2) match { case _ :+ x => println(x) }
ScalaPackageClass.info.decls
ScalaPackageClass.typeSignature.declarations
ScalaPackageClass.typeSignature.declarations foreach println
mirror.reflect("hello").symbol
cm.reflect("hello").symbol
typeOf[String]
class C { def foo(x: Int) = println(2) }
trait X { def foo(x: Int) = println(3) }
class D extends C with X
trait X { override def foo(x: Int) = println(3) }
trait X extends C { override def foo(x: Int) = println(3) }
class D extends C with X
new D().foo
new D().foo(2)
class C { def foo = println(2) }
class D extends C { override def foo = println(3) }
trait X extends C { override def foo = println(100500) }
class C1 extends C with X
new C1().foo
class D1 extends D with X
new D1().foo
cm.staticClass("scala.reflect.runtime.JavaMirrors")
res0.isInitialized
res0.asInstanceOf[scala.reflect.internal.Symbols#Symbol]
res0.asInstanceOf[scala.reflect.internal.Symbols#Symbol].isInitialized
res0.associatedFIle
res0.associatedFile
exit 
false && 22 
false && 2 == 2
trait Foo extends Macro
trait Foo extends scala.reflect.Macros.Macro 
trait Foo extends scala.reflect.macros.Macro 
trait Foo extends scala.reflect.macros.Macro { 
class C
class D { self: C => }
List(2, 1).sorted
class C(val x: Int) extends AnyVal
typeOf[C].declarations
typeOf[C].declarations.collect{ case ts: TermSymbol if ts.isParamAccessor => ts }
typeOf[C].declarations.collect{ case ts: TermSymbol if ts.isParamAccessor && ts.isVal => ts }
typeOf[C].declarations.collect{ case ts: TermSymbol if ts.isParamAccessor && ts.isMethod => ts }
res4.toList(0)
res5.name
res5.name.length
res5.name.toString.length
class C { def foo(xs: Int*) = println(xs) }
cm.reflect(new C)
res0.reflectMethod(typeOf[C].declaration(newTermName("foo")))
res0.reflectMethod(typeOf[C].declaration(newTermName("foo")).asMethod)
res2(1)
class C { def foo(xs: String*) = println(xs) }
cm.reflect(new C)
res0.reflectMethod(typeOf[C].declaration(newTermName("foo")).asMethod)
res4.reflectMethod(typeOf[C].declaration(newTermName("foo")).asMethod)
res4("a")
res6("a")
class C { def fooi1(x: Int, xs: Int*) = (x, xs) }
classOf[C].getDeclaredMethod("fooi1")
classOf[C].getMethods()
classOf[C].getMethods().first
classOf[C].getMethods().toList.head
res3.invoke(new C, 1, 2)
res3.invoke(new C, 1.asInstanceOf[Any], 2.asInstanceOf[Any])
res3.invoke(new C, 1.asInstanceOf[AnyRef], 2.asInstanceOf[AnyRef])
class C { def fooi1(x: String, xs: String*) = (x, xs) }
classOf[C].getMethods().toList.head
res3.invoke(new C, "x", "y")
res7.invoke(new C, "x", "y")
res7.invoke(new C, "x", "y", "z")
class C { def foo(x: String, xs: String*) = (x, xs) }
val foo = classOf[C].getMethods().toList.head
foo.invoke(new C, "1", "2")
typeOf[java.lang.reflect.Method]
typeOf[java.lang.reflect.Method].declaration(newTermName("invoke"))
cm.reflect(foo)
res14.reflectMethod(res13.asMethod)
res15(new C, "1")
class C { def foo(x: String) = (x) }
val foo = classOf[C].getMethods().toList.head
foo.invoke(new C, "1"))
foo.invoke(new C, "1")
val invoke = typeOf[java.lang.reflect.Method].declaration(newTermName("invoke"))
cm.reflect(foo).reflectMethod(invoke.asMethod)(new C, "1")
classOf[java.lang.Method].getMethods
classOf[java.lang.reflect.Method].getMethods
classOf[java.lang.reflect.Method].getMethods.toList.head
val invoke = classOf[java.lang.reflect.Method].getMethods.toList.head
invoke.invoke(foo, new C, "1")
class C { def foo = 1 }
classOf[C].getMethods.head
res0.invoke(new C, 1)
res0.invoke(new C, "1")
List.fill(0)(1)
typeOf[List[Int]]
exit
typeOf[List[Int]]
{ class C { def x = 2 }; typeOf[C] }
{ class C { def x = 2 }; weakTypeOf[C] }
typeOf[String]
List(1, 2, 3, 4).permutations
List(1, 2, 3, 4).permutations.toList
typeOf[String]
typeOf[scala.reflect.api.TypeTags].typeSymbol
res0.thisSym
res0.thisPrefix
res0.asClass.selfType
typeOf[List[T] forSome { type T }]
typeOf[List[Any]]
res0 <:< res1
res0 <:< res0
res1 <:< res0
typeOf[List[Any]] <:< typeOf[List[T] forSome { type T }]
val lany = typeOf[List[Any]]
val lt = typeOf[List[T] forSome { type T }]
lany <:< lt
val lany = typeOf[List[Any]]
val lt = typeOf[List[T] forSome { type T }]
lany <:< lt
val lany = typeOf[List[Any]]
val lt = typeOf[List[T] forSome { type T }]
lany <:< lt
typeOf[Types].declarations.sorted foreach println
typeOf[scala.reflect.internal.Types].declarations.sorted foreach println
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(_.isValue).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(_.isVal).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(_.isVal).filter(!_.name.toString.contains("TypeTag")).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(_.isVal).filter(!_.name.toString.endsWith("Tag")).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(_.isVal).filter(!_.name.toString.strip.endsWith("Tag")).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(_.isVal).filter(!_.name.toString.trim.endsWith("Tag")).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(sym => sym.isVal || sym.isVar).filter(!_.name.toString.trim.endsWith("Tag")).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(sym => sym.isVal || sym.isVar || sym.isLazy).filter(!_.name.toString.trim.endsWith("Tag")).foreach(println)
new ThreadLocal[Int]()
new ThreadLocal(1)
class C { def foo(x: Int) = x }
classOf[C].getDeclaredMethod("foo", classOf[Int])
res0.invoke(new C, null)
class C { def foo[T](x: T, y: T) = () }
cm.reflect(new C).reflectMethod(typeOf[C].declaration(newTermName("foo")).asMethod)
res0(1, "1")
class C { def foo[T](x: T, y: T) = () }
class C { def foo[T <: U](x: T, y: U) = () }
class C { def foo[T, U <: T](x: T, y: U) = () }
cm.reflect(new C).reflectMethod(typeOf[C].declaration(newTermName("foo")).asMethod)
class C { def foo[T <: Int, U <: T](x: T, y: U) = () }
cm.reflect(new C).reflectMethod(typeOf[C].declaration(newTermName("foo")).asMethod)
res3(1, "1")
scala.collection.mutable.ArrayBuffer[Int](1, 2)
typeOf[Int]
typeOf[String]
case class Shop(store: String, item: String, cost: Int) { def this() = this(null, null, 0) }
val t = typeOf[Shop]
val m = runtimeMirror(getClass.getClassLoader)
val cls = t.typeSymbol.asClass
val cm = m.reflectClass(cls)
val alts = t.declaration(nme.CONSTRUCTOR).asTerm.alternatives
val noargCtor = alts.collect{ case ms: MethodSymbol if ms.paramss => ms }.head
val noargCtor = alts.collect{ case ms: MethodSymbol if ms.paramss == List() => ms }.head
val noargCtor = alts.collect{ case ms: MethodSymbol if ms.paramss == List(List()) => ms }.head
cm.reflectConstructor(noargCtor)()
import scala.reflect.runtime.universe._
trait Foo
object Bar {
  def apply[A]()(implicit tpe: TypeTag[A]): Bar[A] = ???
}
trait Bar[A]
class test {
  type A = Foo
  implicit val foo = typeOf[A]
  def test = Bar[A]()                                                 
}
newTermName("Test") eq newTermName("Test")
newTermName("Test") == newTermName("Test")
case class Foo(a: Int, b: Int); object Foo { def apply(a: Int) = Foo(a, 0) }
case class Foo(a: Int, b: Int); object Foo { def apply(a: Int): Foo = Foo(a, 0) }
abstract class Applyable[T] { def apply(a: Int): T = apply(a, 0); def apply(a: Int, b: Int): T }
case class Foo(a: Int, b: Int); object Foo extends Applyable[Foo]
def foo(implicit i: Int) = i
foo
object M { def foo = 2 }
typeOf[M].declaration(newTermName("foo"))
typeOf[M.type].declaration(newTermName("foo"))
res1.owner
res1.owner.asModule
object C
:javap -v C
class C1 { object D }
:javap C1
:javap -v -p C1
class Foo(x: => Int)
import scala.reflect.runtime.{universe => ru}
reify(ru).eval
typeOf[String]
class C
typeOf[C]
class C { def c: C = this }
typeOf[C]
abstract class PrimitiveTC[X:TypeTag]
{ def is[T:TypeTag]: Boolean = typeOf[X] <:< typeOf[T] } 
abstract class PrimitiveTC[X:TypeTag] {
   def is[T:TypeTag]: Boolean = typeOf[X] <:< typeOf[T]
}
object StringTypeTag extends PrimitiveTC[String]
StringTypeTag
class A[X](implicit val tt: TypeTag[X]) {println(tt)}
object Obj { val x = { object InVal extends A[String]; InVal; 5 } }
Obj
exit
scala.reflect.runtime.universe.forInteractive
"1\n2".split("\n")
"1\n2".split("\n").map("  " + _)
"1\n2".split("\n").map("  " + _).mkString
"1\n2".split("\n").map("  " + _).mkString("\n")
"1".split("\n")
" ".strip
" ".trim
" ".trimLeft
def impl(c: Context)(x: c.Expr[Int]) = c.Ident(TypeName("C"))
def impl(c: Context)(x: c.Expr[Int]) = { import c.universe._; Ident(TypeName("C")) }
class C
type TM(x: Int) = macro impl
class C extends AnyRef with TM(2)
class D extends AnyRef with TM(2)
trait C
def tm(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = c.universe.Ident(c.universe.TypeName("C"))
def tm(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = c.universe.Ident(c.weakTypeOf[C].typeSymbol)
type TM(x: Int)(y: Int) = macro Impls.tm
type TM(x: Int)(y: Int) = macro tm
trait X extends TM(2)(3)
reify{ new Object().getClass }
reify(manifest[Some[_]])
reify{ new Object().getClass }
reify(manifest[Some[_]])
Thread.currentThread().getContextClassLoader
res0.getClass.getFields
res1.length
val outerField = res0.getClass.getFields.head
outerField.setAccessible(true)
outerField.get(res0)
res4.asInstanceOf[IMain].definedSymbolList
res4.asInstanceOf[scala.tools.nsc.interpreter.IMain].definedSymbolList
res4.asInstanceOf[scala.tools.nsc.interpreter.IMain].importHandlers
val x = res4.asInstanceOf[scala.tools.nsc.interpreter.IMain]
x.definedSymbolList
val replClassloader = Thread.currentThread().getContextClassLoader
val outerField = replClassloader.getClass.getFields.head
val interpreter = outerField.get(replClassloader).asInstanceOf[scala.tools.nsc.interpreter.IMain]
interpreter.definedSymbols
interpreter.definedSymbolList
trait Foo[A] { def m[B >: A](x: B): B }
val t = weakTypeOf[Foo[Int]]
val m = t.member(newTermName("m")).asMethod
val mt = m.typeSignatureIn(t)
val TypeBounds(lo, hi) = m.typeParams.head.typeSignatureIn(t)
showRaw(mt)
case class Foo(x: Int)
trait X
new { val x = 2 } with X
trait X extends { val x = 2 } with AnyRef
trait X extends { val x = 2 }
exit
def foo: List[T] = Nil
def foo[T]: List[T] = Nil
foo
def foo[T]: Comparator[T] = Nil
def foo[T]: Comparable[T] = Nil
def foo[T]: Comparable[T] = ???
foo
def foo[T]: Comparable[T] = null
foo
def foo[T]: List[T] = null
foo
def bar[T]: Comparable[T] = null
bar
class C[+T]
def foo[T]: C[T] = null
class D[-T]
def bar[T]: D[T] = null
bar
typeOf[List[Int]]
typeOf[Int]
typeOf[String]
typeOf[T forSome { type T <: Int }]
typeOf[{def x: Int; type T <: Int}]
val x = 5
val replClassloader = Thread.currentThread().getContextClassLoader
val outerField = replClassloader.getClass.getFields.head
val interpreter = outerField.get(replClassloader).asInstanceOf[scala.tools.nsc.interpreter.IMain]
interpreter.definedSymbolList
res0(0)
res0(0).fullName
res0(0).fullNameString
res0.owner
res2.owner
res1.owner
res1.owner.owner
res1.owner.owner.owner
.owner
val x = 2
x
val x = 2
val y = x
interpreter.originalPath
interpreter.fullPath
interpreter.global
interpreter.global.exitingTyper
interpreter.global.exitingPhase
interpreter.global.afterPhase
interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)
interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)(res1.fullName)
interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)(res1.fullNameString)
res1.javaClassName
interpreter.handlers
interpreter.prevRequests
interpreter.prevRequestList
interpreter.prevRequestList.takeRight(5)
interpreter.allHandlers
interpreter.allHandlers.takeRight(10)
interpreter.allHandlers foreach println
interpreter.allHandlers.reverse(10)
res27.definesTerm
interpreter.prevRequestList.takeRight(5)
val replClassloader = Thread.currentThread().getContextClassLoader
val outerField = replClassloader.getClass.getFields.head
val interpreter = outerField.get(replClassloader).asInstanceOf[scala.tools.nsc.interpreter.IMain]
val handlers = interpreter.prevRequestList
val reqs = interpreter.prevRequestList
reqs.flatMap(_.definedNames)
val replClassloader = Thread.currentThread().getContextClassLoader
val outerField = replClassloader.getClass.getFields.head
val replClassloader = Thread.currentThread().getContextClassLoader
val interpreter = outerField.get(replClassloader).asInstanceOf[scala.tools.nsc.interpreter.IMain]
val reqs = interpreter.prevRequestList
reqs.flatMap(_.definedNames.asInstanceOf[List[Any]])
val replClassloader = Thread.currentThread().getContextClassLoader
val outerField = replClassloader.getClass.getFields.head
val interpreter = outerField.get(replClassloader).asInstanceOf[scala.tools.nsc.interpreter.IMain]
val reqs = interpreter.prevRequestList
val fullPaths = reqs.flatMap(req => req.definedNames.map(name => req.fullPath(name)))
reqs(0)
res2.definedNames
res1.definedNames.asInstanceOf[Any]
res1.definedNames.asInstanceOf[List[_]]
res1.definedNames.map(_.toString)
res1.fullPath(res4(0))
res1.line
res1.lineRep
res1.lineRep.readPath
res1.accessPath
val fullPaths = reqs.flatMap(req => req.definedNames.map(name => s"${req.lineRep.readPath}${req.accessPath}.`$name`"))
reqs(0).lineRep
reqs(0).lineRep.readPath
reqs(0).definedName
reqs(0).definedNames
reqs(0).definedNames.asInstanceOf[Any]
interpreter
val fullPaths = reqs.map(req => req.lineRep.readPath)
val fullPaths = reqs.flatMap(req => req.definedNames.map(name => s"${req.lineRep.readPath}${req.accessPath}.`$name`"))
val fullPaths = reqs.flatMap(req => req.definedNames.map(name => req.lineRep.readPath))
val fullPaths = reqs.flatMap(req => req.definedNames.map(name => req.lineRep.readPath + req.accessPath))
val readPaths = reqs.flatMap(req => req.definedNames.map(_ => req.lineRep.readPath))
val accessPaths = reqs.flatMap(req => req.definedNames.map(_ => req.accessPath))
val names = reqs.flatMap(req => req.definedNames.map(name => "." + name.toString))
def mineInfoFromReqs(fn: (interpreter.Request, String) => String): List[String] = ???
def mineInfoFromReqs(fn: (interpreter.Request, String) => String): List[String] = reqs.flatMap(req => req.definedNames.map(name => fn(req, name)))
def mineInfoFromReqs(fn: (interpreter.Request, String) => String): List[String] = reqs.flatMap(req => req.definedNames.map(name => fn(req, name.toString)))
def getInfoFromReqs(fn: (interpreter.Request, String) => String): List[String] = reqs.flatMap(req => req.definedNames.map(name => fn(req, name.toString)))
def mapDefinedNames[T](fn: (interpreter.Request, String) => T): List[T] = reqs.flatMap(req => req.definedNames.map(name => fn(req, name.toString)))
val fullPaths = mapDefinedNames((_, _) => "")
val fullPaths = ListBuffer(mapDefinedNames((_, _) => ""))
val fullPaths = scala.collection.mutable.ListBuffer(mapDefinedNames((_, _) => ""))
val fullPaths = scala.collection.mutable.ListBuffer[String]() ++ mapDefinedNames((_, _) => "")
def mapDefinedNames[T](fn: (interpreter.Request, String) => T): List[T] = reqs.flatMap(req => req.definedNames.map(name => fn(req, name.toString)))
val parts = List(mapDefinedNames((req, _) => req.lineRep.readPath), mapDefinedNames((req, _) => req.accessPath), mapDefinedNames((_, name) => "." + name))
parts.transpose.map(_.mkString)
parts.transpose
List("1", "2").mkString
parts.transpose(0).mkString
res7(0).mkString
res7(0)
res7(1)
res7(2)
res7(0)(0)
res7(0)(1)
res7(0)(2)
res7(0)(0) + res7(0)(1) + res7(0)(2)
(res7(0)(0) + res7(0)(1) + res7(0)(2)).length
println(res7(0)(0) + res7(0)(1) + res7(0)(2))
val replClassloader = Thread.currentThread().getContextClassLoader
val outerField = replClassloader.getClass.getFields.head
val interpreter = outerField.get(replClassloader).asInstanceOf[scala.tools.nsc.interpreter.IMain]
interpreter.definedSymbolList
interpreter.definedSymbolList foreach (sym => println(sym.fullNameString))
interpreter.definedSymbolList foreach (sym => println(interpreter.global.afterPhase(interpreter.global.typerPhase)(sym.fullNameString))
)
interpreter.definedSymbolList foreach (sym => println(interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)(sym.fullNameString)))
interpreter.definedSymbolList foreach (sym => println(interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)(sym.fullName)))
interpreter.definedSymbolList foreach (sym => interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)(sym.fullName))
"$line2.$read"
"$line2.$read" + ".$iw"
"$line2.$read" + ".$iw.$iw"
"$line2.$read" + ".$iw.$iw.cm"
interpreter.definedSymbolList map (sym => interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)(sym.fullName))
def impl(c: Context): c.Expr[Int] = c.universe.Ident(c.universe.TermName("$qmark$qmark$qmark"))
def impl(c: Context): c.Expr[Int] = c.Expr(c.universe.Ident(c.universe.TermName("$qmark$qmark$qmark")))
def foo = macro impl
def x: String = foo
val x: String = foo
typeTag[List[Int]] <:< typeTag[List[Any]]
typeTag[List[Int]].tpe <:< typeTag[List[Any]].tpe
abstract class AbsIterator extends AnyRef 
trait RichIterator extends AbsIterator
class StringIterator extends AbsIterator
class Iter extends StringIterator with RichIterator
typeOf[Iter].baseClasses
typeOf[Iter].typeSymbol.baseClasses
typeOf[Iter].typeSymbol.asClass.baseClasses
new { def x = 2 }
trait Foo[T] { implicit def contextBound: Bar[T] }
class Bar[T]
trait Foo[T] { implicit def contextBound: Bar[T] }
class C[T: Bar] extends Foo[T]
class C[T: Bar] extends Foo[T] { override def contextBound = implicitly[Bar[T]] }
implicit object BarInt extends Bar[Int]
new C[Int]
new C[Int]().contextBound
{ def foo
class C { def foo(x: Int) = x; def foo(y: String = "") = y }
class C { def foo(x: Int) = x; def foo(y: String = "") = y; def foo(z: Double = 0) = z }
class C { def foo(x: Int, y: String) = 1; def foo(x: Int, y: Int) = 2 }
new C().foo(x = 2)
class C { def foo(x: Int, y: String) = 1; def foo(x: Int) = 2 }
class C { def foo(x: Int, y: String = "") = 1; def foo(x: Int) = 2 }
new C().foo(x = 2)
class C { def foo(x: Int, y: String = "") = x; def foo(x: Int) = x }
new C().foo(x = 2)
class C { def foo(x: Int, y: String = "") = x; def foo(x: Int) = x }
new C().foo(x = 2)
class C { def foo(x: Int, y: Int)(z: Int, w: Int) = x }
new C().foo(y = 2, x = 3)(w = 4, z = 5)
class D { def foo(x: Int = 2) = x }
new D().foo()
List(1, 2).toMap
List((1, 2)).toMap
List(1, 2, 3).init
List().collectNot
???
val a = 1; val s =f"$a%s%n$a%s"
f"%n"
class Foo { def this(x: Int, y: Int) = macro impl }
class C
class D
type X = C with D
new X
class C
def impl(c: Context) = {
import c.universe._
Ident(c.typeOf[C].typeSymbol)
}
type X = macro impl
class D
type Y = D with X
new Y
List(1, 2).view
List(1, 2).view match { case x :: _ => x }
List(1, 2).view match { case x #:: _ => x }
List(1, 2).view match { case x :+ _ => x }
List(1, 2).view match { case x :+ _ => x.toList }
List(1, 2).view match { case x +: _ => x }
List(1, 2).view.flatMap{ case x if x == 1 => x; case _ => ??? } match { case x +: _ => x }
List(1, 2).view.flatMap{ case x if x == 1 => Some(x); case _ => ??? } match { case x +: _ => x }
class C(x: Int)
def foo(x: Int) = { println("ho ho ho"); new C(x) }
def tryFoo(x: Int) = { println("ho ho ho"); Some(new C(x)) }
List(1, 2, 3).view.flatMap(tryFoo) match { case C(x) => println("boo!") }
case class C(x: Int)
def tryFoo(x: Int) = { println("ho ho ho"); Some(C(x)) }
List(1, 2, 3).view.flatMap(tryFoo) match { case C(x) => println("boo!") }
List(1, 2, 3).view.flatMap(tryFoo) match { case C(x) +: _ => println("boo!") }
case class C(x: Int)
def tryFoo(x: Int) = { println("ho ho ho"); Some(C(x)) }
List(1, 2, 3).view.flatMap(tryFoo) match { case C(x) +: _ => println("boo!") }
exit
typeOf[Int].baseClasses
implicit class HasWhere(val exp : _) {}
    implicit class HasWhere(val exp : _) {
    def where(block : Unit) = macro whereInfix
    }
implicit class HasWhere(val exp : _) {
def where(block : Unit) = macro whereInfix
}
def impl(c: Context)(block: c.Tree) = c.literalUnit
implicit class HasWhere(val exp : _) {
def where(block : Unit) = macro impl
}
c where {}
typeOf[List[Int] { type X = Int }]
exit
typeOf[scala.reflect.pickling.Pickler[String] { type PickleType = scala.reflect.pickling.json.JSONPickle }]
typeOf[scala.pickling.Pickler[String] { type PickleType = scala.pickling.json.JSONPickle }]
null.asInstanceOf[String]
null.asInstanceOf[2]
null.asInstanceOf[Int]
def foo[T] = null.asInstanceOf[T]
foo[Int]
foo[String]
showRaw(typeOf[List[Int]{}])
showRaw(null.asInstanceOf[List[Int]{}])
showRaw(reify(null.asInstanceOf[List[Int]{}]))
reify{ val x: List[Int]{} = ??? }
showRaw(reify{ val x: List[Int]{} = ??? })
ListMap(Map(1 -> 2))
scala.collection.immutable.ListMap(Map(1 -> 2))
scala.collection.immutable.ListMap() ++ Map(1 -> 2)
2.asInstanceOf[Short]
100000.asInstanceOf[Byte]
val tpe = typeOf[Int]
tpe match { case tpe if tpe =:= typeOf[Int] => tpe }
import scala.collection.immutable.ListMap
sealed class UnpickleIR
case class ValueIR(value: Any) extends UnpickleIR
case class ObjectIR(tpe: Type, fields: ListMap[String, UnpickleIR]) extends UnpickleIR
import scala.collection.immutable.ListMap
sealed class UnpickleIR;case class ValueIR(value: Any) extends UnpickleIR;case class ObjectIR(tpe: Type, fields: ListMap[String, UnpickleIR]) extends UnpickleIR
val x: UnpickleIR = null
x match {
case ir @ ObjectIR(tpe, _) => null
case ir @ ValueIR(_) => null
}
x match {
case ir @ ObjectIR(tpe, _) => null
case ir @ ValueIR(_) => null
case _ => null
}
import scala.reflect.runtime.universe._ // underscore import is important in order not to get erasure warnings
reify((x: Int, y: Int) => x + 2)
showRaw(res0)
val Function(params, body) = res0.tree
val paramNames = params map (_.name)
new Traverser { override def traverse(tree: Tree) = tree match {
case Ident(name) if paramNames contains name => println(s"got $name")
case _ => super.traverse(tree)
} }.traverse(body)
// this was unreliable, because in a body of a function one could well define another variable named x or y, so you might get wrong results
// scalac binds definitions and their usages using symbols
// to get the reified tree attributed (i.e. have its symbols and types assigned), use a toolbox
import scala.tools.reflect.ToolBox
val cm = scala.reflect.runtime.currentMirror
val tb = cm.mkToolBox()
tb.typeCheck(res0.tree)
showRaw(res3)
showRaw(res3, printIds = true)
// note the #(\d)+ things in the last printout - they denote symbols
val Function(params, body) = res3.tree
val Function(params, body) = res3
val paramSymbols = params map (_.symbol)
new Traverser { override def traverse(tree: Tree) = tree match {
case ident: Ident if paramSymbols contains ident.symbol => println(s"got ${ident.symbol.name}")
case _ => super.traverse(tree)
} }.traverse(body)
def foo[T](x: T) = tb.eval(reify(x))
def foo[T](x: T) = tb.eval(reify(x).tree)
foo(2)
def foo[T](y: T) = tb.eval(reify({ val y: T = x; y }).tree)
def foo[T](x: T) = tb.eval(reify({ val y: T = x; y }).tree)
foo(2)
def foo[T: TypeTag](x: T) = tb.eval(reify({ val y: T = x; y }).tree)
foo(2)
val x = reify(2)
q"$x"
val x = reify(2)
q"$x"
val x = reify(2)
q"$x"
val it
=
staticClass("scala.collection.Iterable")
val iterableClass = cm.staticClass("scala.collection.Iterable")
iterableClass.toType
existentialAbstraction(iterableClass.toType)
showRaw(res0)
iterableClass.toType.asInstanceOf[TypeRef]
res3.args
existentialAbstraction(res3.args, res3)
existentialAbstraction(res3.args map (_.typeSymbol), res3)
q"case foo => bar"
val cdef = CaseDef(Ident(nme.WILDCARD), EmptyTree, q"???")
q"x match { $cdef }"
class X
object D extends X
typeOf[D.type]
typeOf[D.type].sourceModule
typeOf[D.type].typeSymbol
res2.sourceModule
res2.companion
res2.companionSymbol
res2 eq res5
res5.typeSignature.baseClasses
res2.typeSignature.baseClasses
Predef.Triple
object Foo
typeOf[Foo.type].typeSymbol
res0.isModule
res0.isClass
object Foo { object Bar }
typeOf[Foo.type].typeSignature
typeOf[Foo.type].members
typeOf[Foo.type].members.toList.head
res5.isModule
res5.asModule.moduleClass
res5.asModule.moduleClass.asClass.baseClasses
Predef$Triple$
IntClass.isSealed
IntClass.isFinal
cm.reflect[Boolean](true)(ClassTag.Boolean).symbol.asType.toType
showRaw(res0)
typeof[::[_]]
typeoOf[::[_]]
typeOf[::[_]]
res2.typeSymbol
res2.name
res3.name
res3.name.decoded
typeOf[List[Int]]
typeOf[::[_]].typeSymbol.typeSignature
typeOf[::[_]].typeSymbol.asType.toType
typeOf[List[Int]]
typeOf[::[_]].typeSymbol.asType.toType
res5.typeSignatureIn(res4)
res5.typeSymbol.typeSignatureIn(res4)
res5.asSeenFrom(NoPrefix, res4)
res5.asSeenFrom(NoPrefix, res4.typeSymbol)
res5.asSeenFrom(res4, res4.typeSymbol)
def qwe[T: TypeTag]: ::[T] = { println(typeOf[T]); Nil }
def qwe[T: TypeTag]: ::[T] = { println(typeOf[T]); ::(1, Nil).asInstanceOf[::[T]] }
val qqq: List[Int] = qwe
def foo(xx: List[Int]) = ()
foo(qwe)
l3.CL3ToCPSTranslator
CL3ToCPSTranslator
l3.CL3ToCPSTranslator
Some[_](1)
q"{case x => }"
q"case x =>"
def impl(c: Context)(x: c.Tree) = {
import c.universe._
x match {
case Bind(name, tree) => Bind(TermName(name.toString + name.toString), tree_
object Macros { def apply(x: Int) = x }
Macros(2)
null.asInstanceOf[Null]
val cc: List[CaseDef] = Nil
q"2 match { ..$cc }"
"a.b".split(".")
"a.b".split('.')
"a".split('.')
"a".split('.').map(_.capitalize)
class C(val x: Int)
typeOf[C].declarations
val ctor = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten
typeOf[C].declarations.toList
res1(0) == ctor(0)
res1(0) == ctor(1)
res1(0) == ctor(0)
res1(1) == ctor(0)
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten(0)
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten().apply(0)
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten.apply(0)
val x1 = typeOf[C].declarations.toList().apply(0)
val x1 = typeOf[C].declarations.toList(0)
val x2 = typeOf[C].declarations.toList(1)
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten.apply(0)
x1.isMethod
x2.isMethod
ctorx.isMethod
val x1 = typeOf[C].declarations.toList(0).asTerm
val x2 = typeOf[C].declarations.toList(1).asTerm
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten.apply(0).asTerm
x1.accessed
x2.accessed
x2.accessor
val x1 = typeOf[C].declarations.toList(0).asTerm
val x2 = typeOf[C].declarations.toList(1).asTerm
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten.apply(0).asTerm
x1.isParamAccessor
x2.isParamAccessor
ctorx.isParamAccessor
ctorx.isParameter
x1.isParameter
x2.isParameter
ctorx.isPublic
x1.isPublic
x2.isPublic
class C(x: Int)
val x1 = typeOf[C].declarations.toList(0).asTerm
val x2 = typeOf[C].declarations.toList(1).asTerm
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten.apply(0).asTerm
ctorx.isPublic
x1.isPublic
x1.isParamAccessor
x1.isAccessor
new String("X")
q""
val x = Nil
q"1; ..$x; 1"
class C(x: Int)(y: Int)
object D
val mc = typeOf[D.type].typeSymbol
mc.isModuleClass
mc.isFinal
def foo[T <: Singleton] = 1
class C
object C
classC; object C
class C; object C 
foo[C]
foo[C.type]
val x = 1
foo[x.type]
val x = "1"
foo[x.type]
scala.misc.Unsafe
sun.misc.Unsafe
sun.misc.Unsafe.instance
sun.misc.Unsafe.getUnsafe
val ann = q"new ann"
q"@$ann val x = 2"
val ann2 = q"@ann"
val ann3 = tq"ann"
q"@$ann3 val x = 2"
val ann3 = List(tq"ann")
q"@..$ann3 val x = 2"
class MPair[A, B](val left: A, val right: B)
val tpe = typeOf[
val tpe = typeOf[MPir[Int, String]]
val tpe = typeOf[MqPir[Int, String]]
val tpe = typeOf[MPair[Int, String]]
val tpe = typeOf[MPair[Int, String]]
tpe.declarations.collect{ case meth: MethodSymbol if meth.isParamAccessor => meth }
tpe.declarations.collect{ case meth: MethodSymbol if meth.isParamAccessor => meth }.toList(0)
val sym = tpe.declarations.collect{ case meth: MethodSymbol if meth.isParamAccessor => meth }.toList(0)
sym.typeSignature
sym.typeSignatureIn(tpe)
val tpe = typeOf[MPair[Int, String]]
val sym = tpe.declarations.collect{ case meth: MethodSymbol if meth.isParamAccessor => meth }.toList(0)
sym.typeSignature
sym.typeSignatureIn(tpe)
tpe.declarations
class MPair[A, B](val left: A, val right: B)
val tpe = typeOf[MPair[Int, String]].typeSymbol.asType.toType
showRaw(tpe)
val sym = typeOf[MPair[Int, String]].typeSymbol.asClass
sym.typeParams
sym.typeParams(0).asType.toType
sym.typeParams(0).asType.toType.erasure
class Foo[T: TypeTag](x: Int)
typeOf[Foo].declarations
typeOf[Foo[_]].declarations
classOf[Foo[_]].getMethods
classOf[Foo[_]].getDeclaedMethods
classOf[Foo[_]].getDeclaredMethods
typeOf[Int].baseClasses
implicitly[CanBuildFrom[List[_], _, List[_]]]
implicitly[scala.collection.generic.CanBuildFrom[List[_], _, List[_]]]
exit
List(1, 2).max
1 to 5
"1" * 10
"1".substring(1)
typeOf[List[Int]].erasure
import scala.pickling._
import json._
List(1, 2).pickle
val cons = classOf[scala.collection.immutable.::[_]]
cons.getDeclaredFields
cons.getDeclaredMethods
val x = Map(1 -> 2)
x(null)
val x = Map("1" -> 2)
x(null)
System.getEnv.toMap
System.getenv.toMap
System.getenv
System.getenv.toList
System.getenv.asScalaMap
WrapAsScala.asScalaMap(System.getenv)
scala.collection.convert.WrapAsScala.asScalaMap(System.getenv)
scala.collection.convert.WrapAsScala.mapAsScalaMap(System.getenv)
System.getEnv.getKeys
System.getenv.getKeys
System.getenv.keys
System.getenv.keySet
System.getProperties
System.getProperties.keys
System.getProperties.keys.toList
scala.collection.convert.WrapAsScala.enumerationAsScalaIterator(System.getProperties.keys)
scala.collection.convert.WrapAsScala.enumerationAsScalaIterator(System.getProperties.keys).toList
scala.collection.convert.WrapAsScala.enumerationAsScalaIterator(System.getProperties.keys).toList foreach println
typeOf[Object].toString
object C
typeOf[C.type].toString
classOf[Int] match { case classOf[Int] => 1 }
"""(.*?)\[(.*?)\]""".r
res0.match
res0.matches
res0.findAllIn("C[Int]")
res0.findAllIn("C[Int]").toList
res0.findFirstIn("C[Int]")
"""(.*?)\[(.*?)\]""".r
val tper """(.*?)(\[(.*?)\])?""".r
val tper = """(.*?)(\[(.*?)\])?""".r
tper.unapplySeq("C[Int]")
tper.unapplySeq("C")
tper.unapplySeq("")
tper.unapplySeq("C[Int, Int]")
val tper = """^(.*?)(\[(.*?)\])?$""".r
tper.unapplySeq("C[Int, Int]")
tper.unapplySeq("")
case class X(x: Int, private y: => Int)
case class X(x: Int, private val y: => Int)
case class C(arr: Array[Int])
typeOf[C].declarations
typeOf[C].declarations.toList.take(2)
res1(0).typeSignature
res1(1).typeSignature
class C[T]
typeOf[C[Any]].typeSymbol.asType.toTypeConstructor
List("x") == List("x")
import scala.collection.generic._
import scala.collection.immutable.::
type X = CanBuildFrom[::[Int], Int, ::[Int]]
implicitly[X]
implicitly[CanBuildFrom[::[Int], Int, ::[Int]]]
implicitly[CanBuildFrom[::[_], Int, ::[Int]]]
implicitly[CanBuildFrom[List[_], Int, List[Int]]]
implicitly[CanBuildFrom[::[_], Int, List[Int]]]
implicitly[CanBuildFrom[::[_], Int, ::[Int]]]
import scala.pickling._
import json._
5.pickle
case class C(x: Int)
C(2).pickle
exit
typeOf[::[_]]
res0.typeSymbol.flags
res0.typeSymbol.typeSignature
res0.typeSymbol.flags
typeOf[Some[_]].flags
typeOf[Some[_]].typeSignature
typeOf[::[_]].isFinal
typeOf[::[_]].typeSymbol.isFinal
'!'.toInt
class C
typeOf[C].typeSymbol.typeSignature
typeOf[C].typeSymbol.typeSignature.typeSymbol
typeOf[Option[_]].typeSymbol.typeSignature
res0.typeSymbol.toType
res0.typeSymbol.asType.toType
System.currentTimeMillis
needsMacroExpansion
def foo(x: Int, y: Int) = x + y
def bar(fn: (Int, Int) => Int) = fn(40, 2)
bar(foo)
val x = Character.isWhitespace
val x = Character.isWhitespace _
def impl(c: Context)(args: c.Tree*) = c.literalUnit
def foo(args: _*) = macro impl
foo(qwe = 1, qqq = 2)
def impl(c: Context)(args: c.Tree*) = c.literal(args.toString)
def foo(args: _*) = macro impl
foo(qwe = 1, qqq = 2)
scala> def impl(c: Context)(args: c.Tree*) = c.literal(args.toString)
impl: (c: scala.reflect.macros.Context)(args: c.Tree*)c.Expr[String]
scala> def foo(args: _*) = macro impl
defined term macro foo: (args: _*)String
scala> foo(qwe = 1, qqq = 2)
class A
(ru: api.Universe).typeTag[A]
(ru: scala.reflect.api.Universe).typeTag[A]
(ru: scala.reflect.api.Universe).weakTypeTag[A]
typeTag[Int]
(ru: scala.reflect.api.JavaUniverse).weakTypeTag[A]
class A
(ru: scala.reflect.api.Universe).weakTypeTag[A]
class A
(ru: scala.reflect.api.Universe).weakTypeTag[A]
import reflect._
class A
import reflect._
runtime.universe: api.Universe
res0.typeTag[A]
res0.typeTag[A].in(currentMirror)
res0.typeTag[A].in(cm)
res0.typeTag[A].in(scala.reflect.runtime.currentMirror)
"%.2f%"
"%.2f%".format(0)
"%.2f x%".format(0)
"%.2f".format(0)
"%.2f".format(0f)
"%.2f".format(0.0)
f"${0}2f"
f"${0}%2f"
f"${0}%.2f"
object C
val c = classOf[C]
val cm = scala.reflect.runtime.currentMirror
cm.classSymbol(c)
c.companionSymbol
res0.companionSymbol
c.typeSignature
class C; object C
val cm = scala.reflect.runtime.currentMirror
class C; object C
import scala.reflect.runtime.{currentMirror => cm}
cm.classSymbol(classOf[C]).companionSymbol
cm.reflectModule(res0).instance
cm.reflectModule(res0.asModule).instance
q""
val as = List(q"1", q"2")
val sum = q"..$as.sum"
"%%".format()
reify(f"%%")
reify(manifest[Some[_]])
tb.parse("2").pos
tb.parse("x")
val tb = cm.mkToolBox()
tb.parse("x").pos
ru.reify{type X = List[T] forSome {type T} }
val s = Seq[Int](1,2,3)
val m = runtimeMirror(this.getClass.getClassLoader)
m.reflect(s).symbol.asType.toType
m.reflect(s).symbol.typeSignature
m.reflect(s).symbol.asType.toType <:< typeOf[Seq[Int]]
def foo(implicit x: Int) = x
foo
{ def x = 2; def y = z; def z = x }
def foo(x: AnyRef) = x
foo(2)
:power
:vals
typer
typer.typedTYpe
typer.typedType
typer.typedType(TypeTree(IntTpe))
TypeTree(IntTpe).original
object A{def p= println("hi")}
reify(A.p)
shwoRaw(res0, printIds = true)
showRaw(res0, printIds = true)
import scala.tools.reflect.ToolBox
val tb = scala.reflect.runtime.currentMirror.mkToolBox
val tb = scala.reflect.runtime.currentMirror.mkToolBox()
tb.typeCheck(res0.tree)
showRaw(res3, printIds = true)
Set(1) intersect Set(1, 2)
Set(1) * Set(1, 2)
Map(1 -> 2) - 1
Map(1 -> 2) -- List(1)
Map(1 -> 2) ++ Map(1 -> 3)
f"%n"
f"%"
f"%n"
f"%"
"%".format()
f"${0}%.2f%"
f"${0}%.2f"
"".substring(0, 1)
"%%".format()
f"%n"
f"${0}%n"
exit
f"${0}%n"
f"%n%n%n%n"
s"aaa$"
List(Array(0), Array(0L)).map(x => x)
lub
lub(typeOf[Array[String]], typeOf[Array[Nothing]])
lub(List(typeOf[Array[String]], typeOf[Array[Nothing]]))
if (false) Array("qwe") else Array()
if (false) Array("qwe") else Array[Nothing]()
1 to 10
2 / 3
case class Foo(i: Int, s: String, b: Boolean)
def foo[C, L](c: C)(implicit iso: Iso[C, L]): L = iso.to(c)
def foo[C, L](c: C)(implicit iso: Iso[C, L]): L = println(iso.to(c))
def foo[C, L](c: C)(implicit iso: Iso[C, L]) = println(iso.to(c))
case class Foo(i: Int, s: String, b: Boolean)
foo(Foo(23, "foo", true))
Array()
def foo(arr: Array[Char]) = arr
foo(Array())
q"x"
ilem
 import language.experimental._, reflect.macros.Context
object GrabContext {
  def lastContext = Option(System.getProperties.get("lastContext")
    .asInstanceOf[reflect.macros.runtime.Context])
  // System.properties lets you stash true globals (unlike statics which are classloader scoped)
  def impl(c: Context)() = { System.getProperties.put("lastContext", c); c.literalUnit }
  def grab() = macro impl 
}
object Test { class C(implicit a: Any) { GrabContext.grab } }
GrabContext.lastContext.get.callsiteTyper.context.implicitss
object Test1 { class C(implicit a: Any) { GrabContext.grab } }
 import language.experimental._, reflect.macros.Context
object GrabContext {
  def lastContext = Option(System.getProperties.get("lastContext")
    .asInstanceOf[reflect.macros.runtime.Context])
  // System.properties lets you stash true globals (unlike statics which are classloader scoped)
  def impl(c: Context)() = { System.getProperties.put("lastContext", c); c.literalUnit }
  def grab() = macro impl 
}
object Test { class C(implicit a: Any) { GrabContext.grab; GrabContext.grab } }
 import language.experimental._, reflect.macros.Context
object GrabContext {
  def lastContext = Option(System.getProperties.get("lastContext")
    .asInstanceOf[reflect.macros.runtime.Context])
  // System.properties lets you stash true globals (unlike statics which are classloader scoped)
  def impl(c: Context)() = { System.getProperties.put("lastContext", c); c.literalUnit }
  def grab() = macro impl 
}
object Test { class C(implicit a: Any) { GrabContext.grab } }
import language.experimental._, reflect.macros.Context
object GrabContext {
  def lastContext = Option(System.getProperties.get("lastContext")
    .asInstanceOf[reflect.macros.runtime.Context])
  // System.properties lets you stash true globals (unlike statics which are classloader scoped)
  def impl(c: Context)() = { System.getProperties.put("lastContext", c); c.literalUnit }
  def grab() = macro impl 
}
object Test { class C(implicit a: Any) { GrabContext.grab } }
import language.experimental._, reflect.macros.Context
object GrabContext {
  def lastContext = Option(System.getProperties.get("lastContext")
    .asInstanceOf[reflect.macros.runtime.Context])
  // System.properties lets you stash true globals (unlike statics which are classloader scoped)
  def impl(c: Context)() = { System.getProperties.put("lastContext", c); c.literalUnit }
  def grab() = macro impl 
}
object Test { class C(implicit a: Any) { GrabContext.grab } }
    import scala.collection.JavaConverters._
val iterator: Iterator[(Object, Object)] = System.getProperties.asScala.iterator
iterator.collect{ case (k: String, v: String) => (k, v) }
iterator.collect{ case (k: String, v: String) => (k, v) }.toMap
val l = List(1,2,3)
def getTypeTag[T: ru.TypeTag](obj: T) = ru.typeTag[T]
val theType = getTypeTag(l).tpe
:t getTypeTag(l).tpe _
import foo._
exit
showRaw(reify(2))
class SomeClass(val intValue:Int) 
class MyClass[T <: SomeClass](val myValue:T) 
def f3[T](i: MyClass[T]) = ???
  reify({ case class R(id: Int); val lb = new ListBuffer[R](); lb
+= R(1)  })
})
  reify({ case class R(id: Int); val lb = new ListBuffer[R](); lb
+= R(1)  })
import scala.collection.mutable.ListBuffer
  reify({ case class R(id: Int); val lb = new ListBuffer[R](); lb
+= R(1)  })
reify({ case class R(id: Int); val lb = new ListBuffer[R](); lb += R(1) })
reify({ case class R(id: Int); val lb = new ListBuffer[R](); lb += R(1); () })
val build = scala.reflect.runtime.universe.build
val x = build.setTypeSignature(build.newFreeTerm("x", 2), typeOf[Int])
def foo(x: Double) = { println(2 + 1 / x); foo(2 + 1 / x) }
def foo(x: Double): Double = { println(2 + 1 / x); foo(2 + 1 / x) }
foo(2.5)
def foo(x: Double): Double = { println(1 + 1 / x); foo(1 + 1 / x) }
foo(2)
(Math.sqrt(5) + 1) / 2
class C1(val n: Int) extends AnyVal 
type T1 = C1
typeOf[T1]
typeOf[T1].erasure
typeOf[C1].erasure
typeOf[T1].typeSymbol
typeOf[C1].typeSymbol
exit
val tpe = weakTypeOf[Int]
showRaw(tq"$tpe")
q"new {()}"
showRaw(res0)
exit
q"x"
tq"X"
q"return x"
val tree = q"x"
q"return $tree"
exit
class A(val aparam: String)
class B(bparam: String) extends A(bparam)
ru.typeTag[B].tpe.declarations
println(scala.reflect.runtime.universe.typeTag[B].tpe.declarations)
ru.typeTag[B].tpe.members
val bparam = ru.typeTag[B].tpe.members.toList(1)
val aparam = ru.typeTag[B].tpe.members.toList(2)
val bparam = ru.typeTag[B].tpe.members.toList(1).asTerm
val aparam = ru.typeTag[B].tpe.members.toList(2).asTerm
aparam.isParamAccessor
bparam.isParamAccessor
bparam.isParam
bparam.isVal
aparam.isVal
val b = new B("hello")
val mirror = runtimeMirror(b.getClass.getClassLoader)
val alltypes = mirror.reflect(b).symbol.typeSignature.baseClasses.filter(c => c.isClass).map(c => c.asClass.typeSignature)
val vars: Seq[TermSymbol] = alltypes.flatMap(t => t.members.filter(m => m.isTerm && (m.asTerm.isVal || m.asTerm.isVar)).map(x => x.asTerm))
vars
val a = vars(1)
val b = vars(2)
val b = vars(0)
a
b
a.isParamAccessor
b.isParamAccessor
a.isVal
b.isVal
a.isPrivate
b.isPrivate
a.asInstanceOf[scala.reflect.internal.Symbols#Symbol].flags
b.asInstanceOf[scala.reflect.internal.Symbols#Symbol].flags
a.owner
b.owner
val vars: Seq[TermSymbol] = alltypes.flatMap(t => t.members.filter(m => m.isTerm && (m.asTerm.isMethod)).map(x => x.asTerm))
val vars: Seq[TermSymbol] = alltypes.flatMap(t => t.members.filter(m => m.isTerm && (m.asTerm.isMethod && m.asTerm.isParamAccessor)).map(x => x.asTerm))
a.accessor
a.getter
b.getter
val vars: Seq[TermSymbol] = alltypes.flatMap(t => t.members.filter(m => m.isTerm && (m.asTerm.isVal || m.asTerm.isVar)).map(x => x.asTerm))
val aparam = vars(1)
val bparam = vars(0)
aparam.getter
bparam.getter
val Apply(fun, args) = q"f(x)"
case class Foo(x: Int, y: Int)
class C { lazy val C(x, y) = C(2, 3) }
class C { lazy val Foo(x, y) = Foo(2, 3) }
exit
val i = 3val j = 3
val j = 3
val i = 3
(for (x = Option(i); if x == j) yield 42) toList
type F = List[F, Int]
type F = Map[F, Int]
exit
val Long = 1
Long
List(100, 200).zipWithIndex
List(100, 200).zipWithIndex.map{ case(x, i) => x + i }
case class C(x: Int)
typeOf[C].fields
typeOf[C].declarations
typeOf[C].declarations.collect{ case x: MethodSymbol if x.isAccessor => x }
typeOf[C].declarations.collect{ case x: MethodSymbol if x.isParamAccessor => x }
case class C[T](x: T)
val T = typeOf[C[Int]]
T match { case PolyType(_, _) => println("polymorphic entities are not supported"); case _ => }
T.typeSymbol.asType.typeParams
T.typeSymbol.asType.isCaseClass
T.typeSymbol.asClass.isCaseClass
((x: Int) => x)(2)
exit
new C().foo
exit
classOf[C].getConstructors
class C(x: Int)
classOf[C].getConstructors
exit
type T = Int
class C { def foo(x: T*) = ??? }
typeOf[C].declarations
typeOf[C].declarations.toList(1)
typeOf[C].declarations.toList(1).asMethod.paramss.flatten
typeOf[C].declarations.toList(1).asMethod.paramss.flatten(0).typeSignature
typeOf[C].declarations.toList(1).asMethod.paramss.flatten().apply(0).typeSignature
typeOf[C].declarations.toList(1).asMethod.paramss.flatten.apply(0).typeSignature
typeOf[C].declarations.toList(1).asMethod.paramss.flatten.apply(0).typeSignature.dealias
typeOf[C].declarations.toList(1).asMethod.paramss.flatten.apply(0).typeSignature.normalize
typeOf[C].declarations.toList(1).asMethod.paramss.flatten.apply(0).typeSignature.asInstanceOf[scala.reflect.internal.Types#Type]
res8.dealiasWiden
type T = Int
class C { def foo(x: T*) = ??? }
val tstar = typeOf[C].declarations.toList(1).asMethod.paramss.flatten().apply(0).typeSignature
val tstar = typeOf[C].declarations.toList(1).asMethod.paramss.flatten.apply(0).typeSignature
val tstar = typeOf[C].declarations.toList(1).asMethod.paramss.flatten.apply(0).typeSignature.asInstanceOf[scala.reflect.internal.Types#Type]
tstar.dealias
tstar.dealiasWiden
exit
class C[T] { type T = Int }
class Foo(x: Int) extends AnyVal
class Foo(val x: Int) extends AnyVal
val x: Foo = new Foo(2)
(x: Any) match { case x: Foo => x }
val x: List[Foo] = List(new Foo(2))
x(0) match { case x: Foo => x }
val payload = Map[String, Any]("x" -> List(new Foo(2)))
payload match { case (k, List(v: Fingerprint)) => v }
payload(0) match { case (k, List(v: Fingerprint)) => v }
payload.toList(0) match { case (k, List(v: Fingerprint)) => v }
payload.toList(0) match { case (k, List(v: Foo)) => v }
classOf[scala.Double].isAssignableFrom
classOf[scala.Double].isAssignableFrom(classOf[java.lang.Double])
new java.lang.Double(2)
new java.lang.Double(2).asInstanceOf[scala.Double]
classOf[scala.Double].cast(new java.lang.Double(2))
classOf[Double].isInstance(2)
classOf[Double].isInstance(new java.lang.Double(2))
classOf[Unit]
class X(val x: Int) extends AnyVal
classOf[X]
classOf[java.lang.Double].isAssignableFrom(classOf[java.lang.Double])
cm.reflect(null)
class C { def foo = 2 }
cm.reflect(null).reflectMethod(typeOf[C].declarations.head)
cm.reflect(null).reflectMethod(typeOf[C].declarations.head.asMethod)
class C { def foo = 2 }
cm.asInstanceOf[{ def methodToJava(sym: Any): java.lang.reflect.Method }]
class C { def foo = 2 }
val foo = typeOf[C].declarations.head.asMethod
val foo = typeOf[C].declarations.toList.apply(1).asMethod
class C { def foo = 2 }
val foo = typeOf[C].declarations.toList.apply(1).asMethod
val cmx = cm.asInstanceOf[{ def methodToJava(sym: Any): java.lang.reflect.Method }]
cmx.methodToJava(foo)
val cmx = cm.asInstanceOf[{ def methodToJava(sym: scala.reflect.internal.Symbols#MethodSymbol): java.lang.reflect.Method }]
cmx.methodToJava(foo)
cmx.methodToJava(foo.asInstanceOf[scala.reflect.internal.Symbols#MethodSymbol])
val cmx = cm.asInstanceOf[{ def methodToJava(sym: scala.reflect.api.Symbols#MethodSymbol): java.lang.reflect.Method }]
class C { def foo = 2 }
val foo = typeOf[C].declarations.toList.apply(1).asMethod
val cmx = cm.asInstanceOf[{ def methodToJava(sym: scala.reflect.internal.Symbols#MethodSymbol): java.lang.reflect.Method }]
cmx.methodToJava(foo.asInstanceOf[scala.reflect.internal.Symbols#MethodSymbol])
trait C { def foo: Int; def bar = 2 }
typeOf[C].declarations.toList.apply(1)
typeOf[C].declarations.toList.apply(2)
def isDeferred(sym: Symbol) = sym.asInstanceOf[scala.reflect.internal.Symbols#Symbol].hasFlag(scala.reflect.internal.Flags.DEFERRED)
isDeferred(res0)
isDeferred(res1)
class C
type T = C
new T
List[T]()

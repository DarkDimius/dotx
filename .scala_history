typeOf[String]
class C { def foo(x: Int) = println(2) }
trait X { def foo(x: Int) = println(3) }
class D extends C with X
trait X { override def foo(x: Int) = println(3) }
trait X extends C { override def foo(x: Int) = println(3) }
class D extends C with X
new D().foo
new D().foo(2)
class C { def foo = println(2) }
class D extends C { override def foo = println(3) }
trait X extends C { override def foo = println(100500) }
class C1 extends C with X
new C1().foo
class D1 extends D with X
new D1().foo
cm.staticClass("scala.reflect.runtime.JavaMirrors")
res0.isInitialized
res0.asInstanceOf[scala.reflect.internal.Symbols#Symbol]
res0.asInstanceOf[scala.reflect.internal.Symbols#Symbol].isInitialized
res0.associatedFIle
res0.associatedFile
exit 
false && 22 
false && 2 == 2
trait Foo extends Macro
trait Foo extends scala.reflect.Macros.Macro 
trait Foo extends scala.reflect.macros.Macro 
trait Foo extends scala.reflect.macros.Macro { 
class C
class D { self: C => }
List(2, 1).sorted
class C(val x: Int) extends AnyVal
typeOf[C].declarations
typeOf[C].declarations.collect{ case ts: TermSymbol if ts.isParamAccessor => ts }
typeOf[C].declarations.collect{ case ts: TermSymbol if ts.isParamAccessor && ts.isVal => ts }
typeOf[C].declarations.collect{ case ts: TermSymbol if ts.isParamAccessor && ts.isMethod => ts }
res4.toList(0)
res5.name
res5.name.length
res5.name.toString.length
class C { def foo(xs: Int*) = println(xs) }
cm.reflect(new C)
res0.reflectMethod(typeOf[C].declaration(newTermName("foo")))
res0.reflectMethod(typeOf[C].declaration(newTermName("foo")).asMethod)
res2(1)
class C { def foo(xs: String*) = println(xs) }
cm.reflect(new C)
res0.reflectMethod(typeOf[C].declaration(newTermName("foo")).asMethod)
res4.reflectMethod(typeOf[C].declaration(newTermName("foo")).asMethod)
res4("a")
res6("a")
class C { def fooi1(x: Int, xs: Int*) = (x, xs) }
classOf[C].getDeclaredMethod("fooi1")
classOf[C].getMethods()
classOf[C].getMethods().first
classOf[C].getMethods().toList.head
res3.invoke(new C, 1, 2)
res3.invoke(new C, 1.asInstanceOf[Any], 2.asInstanceOf[Any])
res3.invoke(new C, 1.asInstanceOf[AnyRef], 2.asInstanceOf[AnyRef])
class C { def fooi1(x: String, xs: String*) = (x, xs) }
classOf[C].getMethods().toList.head
res3.invoke(new C, "x", "y")
res7.invoke(new C, "x", "y")
res7.invoke(new C, "x", "y", "z")
class C { def foo(x: String, xs: String*) = (x, xs) }
val foo = classOf[C].getMethods().toList.head
foo.invoke(new C, "1", "2")
typeOf[java.lang.reflect.Method]
typeOf[java.lang.reflect.Method].declaration(newTermName("invoke"))
cm.reflect(foo)
res14.reflectMethod(res13.asMethod)
res15(new C, "1")
class C { def foo(x: String) = (x) }
val foo = classOf[C].getMethods().toList.head
foo.invoke(new C, "1"))
foo.invoke(new C, "1")
val invoke = typeOf[java.lang.reflect.Method].declaration(newTermName("invoke"))
cm.reflect(foo).reflectMethod(invoke.asMethod)(new C, "1")
classOf[java.lang.Method].getMethods
classOf[java.lang.reflect.Method].getMethods
classOf[java.lang.reflect.Method].getMethods.toList.head
val invoke = classOf[java.lang.reflect.Method].getMethods.toList.head
invoke.invoke(foo, new C, "1")
class C { def foo = 1 }
classOf[C].getMethods.head
res0.invoke(new C, 1)
res0.invoke(new C, "1")
List.fill(0)(1)
typeOf[List[Int]]
exit
typeOf[List[Int]]
{ class C { def x = 2 }; typeOf[C] }
{ class C { def x = 2 }; weakTypeOf[C] }
typeOf[String]
List(1, 2, 3, 4).permutations
List(1, 2, 3, 4).permutations.toList
typeOf[String]
typeOf[scala.reflect.api.TypeTags].typeSymbol
res0.thisSym
res0.thisPrefix
res0.asClass.selfType
typeOf[List[T] forSome { type T }]
typeOf[List[Any]]
res0 <:< res1
res0 <:< res0
res1 <:< res0
typeOf[List[Any]] <:< typeOf[List[T] forSome { type T }]
val lany = typeOf[List[Any]]
val lt = typeOf[List[T] forSome { type T }]
lany <:< lt
val lany = typeOf[List[Any]]
val lt = typeOf[List[T] forSome { type T }]
lany <:< lt
val lany = typeOf[List[Any]]
val lt = typeOf[List[T] forSome { type T }]
lany <:< lt
typeOf[Types].declarations.sorted foreach println
typeOf[scala.reflect.internal.Types].declarations.sorted foreach println
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(_.isValue).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(_.isVal).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(_.isVal).filter(!_.name.toString.contains("TypeTag")).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(_.isVal).filter(!_.name.toString.endsWith("Tag")).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(_.isVal).filter(!_.name.toString.strip.endsWith("Tag")).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(_.isVal).filter(!_.name.toString.trim.endsWith("Tag")).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(sym => sym.isVal || sym.isVar).filter(!_.name.toString.trim.endsWith("Tag")).foreach(println)
typeOf[scala.reflect.internal.Types].declarations.sorted.collect{case ts: TermSymbol => ts}.filter(sym => sym.isVal || sym.isVar || sym.isLazy).filter(!_.name.toString.trim.endsWith("Tag")).foreach(println)
new ThreadLocal[Int]()
new ThreadLocal(1)
class C { def foo(x: Int) = x }
classOf[C].getDeclaredMethod("foo", classOf[Int])
res0.invoke(new C, null)
class C { def foo[T](x: T, y: T) = () }
cm.reflect(new C).reflectMethod(typeOf[C].declaration(newTermName("foo")).asMethod)
res0(1, "1")
class C { def foo[T](x: T, y: T) = () }
class C { def foo[T <: U](x: T, y: U) = () }
class C { def foo[T, U <: T](x: T, y: U) = () }
cm.reflect(new C).reflectMethod(typeOf[C].declaration(newTermName("foo")).asMethod)
class C { def foo[T <: Int, U <: T](x: T, y: U) = () }
cm.reflect(new C).reflectMethod(typeOf[C].declaration(newTermName("foo")).asMethod)
res3(1, "1")
scala.collection.mutable.ArrayBuffer[Int](1, 2)
typeOf[Int]
typeOf[String]
case class Shop(store: String, item: String, cost: Int) { def this() = this(null, null, 0) }
val t = typeOf[Shop]
val m = runtimeMirror(getClass.getClassLoader)
val cls = t.typeSymbol.asClass
val cm = m.reflectClass(cls)
val alts = t.declaration(nme.CONSTRUCTOR).asTerm.alternatives
val noargCtor = alts.collect{ case ms: MethodSymbol if ms.paramss => ms }.head
val noargCtor = alts.collect{ case ms: MethodSymbol if ms.paramss == List() => ms }.head
val noargCtor = alts.collect{ case ms: MethodSymbol if ms.paramss == List(List()) => ms }.head
cm.reflectConstructor(noargCtor)()
import scala.reflect.runtime.universe._
trait Foo
object Bar {
  def apply[A]()(implicit tpe: TypeTag[A]): Bar[A] = ???
}
trait Bar[A]
class test {
  type A = Foo
  implicit val foo = typeOf[A]
  def test = Bar[A]()                                                 
}
newTermName("Test") eq newTermName("Test")
newTermName("Test") == newTermName("Test")
case class Foo(a: Int, b: Int); object Foo { def apply(a: Int) = Foo(a, 0) }
case class Foo(a: Int, b: Int); object Foo { def apply(a: Int): Foo = Foo(a, 0) }
abstract class Applyable[T] { def apply(a: Int): T = apply(a, 0); def apply(a: Int, b: Int): T }
case class Foo(a: Int, b: Int); object Foo extends Applyable[Foo]
def foo(implicit i: Int) = i
foo
object M { def foo = 2 }
typeOf[M].declaration(newTermName("foo"))
typeOf[M.type].declaration(newTermName("foo"))
res1.owner
res1.owner.asModule
object C
:javap -v C
class C1 { object D }
:javap C1
:javap -v -p C1
class Foo(x: => Int)
import scala.reflect.runtime.{universe => ru}
reify(ru).eval
typeOf[String]
class C
typeOf[C]
class C { def c: C = this }
typeOf[C]
abstract class PrimitiveTC[X:TypeTag]
{ def is[T:TypeTag]: Boolean = typeOf[X] <:< typeOf[T] } 
abstract class PrimitiveTC[X:TypeTag] {
   def is[T:TypeTag]: Boolean = typeOf[X] <:< typeOf[T]
}
object StringTypeTag extends PrimitiveTC[String]
StringTypeTag
class A[X](implicit val tt: TypeTag[X]) {println(tt)}
object Obj { val x = { object InVal extends A[String]; InVal; 5 } }
Obj
exit
scala.reflect.runtime.universe.forInteractive
"1\n2".split("\n")
"1\n2".split("\n").map("  " + _)
"1\n2".split("\n").map("  " + _).mkString
"1\n2".split("\n").map("  " + _).mkString("\n")
"1".split("\n")
" ".strip
" ".trim
" ".trimLeft
def impl(c: Context)(x: c.Expr[Int]) = c.Ident(TypeName("C"))
def impl(c: Context)(x: c.Expr[Int]) = { import c.universe._; Ident(TypeName("C")) }
class C
type TM(x: Int) = macro impl
class C extends AnyRef with TM(2)
class D extends AnyRef with TM(2)
trait C
def tm(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = c.universe.Ident(c.universe.TypeName("C"))
def tm(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = c.universe.Ident(c.weakTypeOf[C].typeSymbol)
type TM(x: Int)(y: Int) = macro Impls.tm
type TM(x: Int)(y: Int) = macro tm
trait X extends TM(2)(3)
reify{ new Object().getClass }
reify(manifest[Some[_]])
reify{ new Object().getClass }
reify(manifest[Some[_]])
Thread.currentThread().getContextClassLoader
res0.getClass.getFields
res1.length
val outerField = res0.getClass.getFields.head
outerField.setAccessible(true)
outerField.get(res0)
res4.asInstanceOf[IMain].definedSymbolList
res4.asInstanceOf[scala.tools.nsc.interpreter.IMain].definedSymbolList
res4.asInstanceOf[scala.tools.nsc.interpreter.IMain].importHandlers
val x = res4.asInstanceOf[scala.tools.nsc.interpreter.IMain]
x.definedSymbolList
val replClassloader = Thread.currentThread().getContextClassLoader
val outerField = replClassloader.getClass.getFields.head
val interpreter = outerField.get(replClassloader).asInstanceOf[scala.tools.nsc.interpreter.IMain]
interpreter.definedSymbols
interpreter.definedSymbolList
trait Foo[A] { def m[B >: A](x: B): B }
val t = weakTypeOf[Foo[Int]]
val m = t.member(newTermName("m")).asMethod
val mt = m.typeSignatureIn(t)
val TypeBounds(lo, hi) = m.typeParams.head.typeSignatureIn(t)
showRaw(mt)
case class Foo(x: Int)
trait X
new { val x = 2 } with X
trait X extends { val x = 2 } with AnyRef
trait X extends { val x = 2 }
exit
def foo: List[T] = Nil
def foo[T]: List[T] = Nil
foo
def foo[T]: Comparator[T] = Nil
def foo[T]: Comparable[T] = Nil
def foo[T]: Comparable[T] = ???
foo
def foo[T]: Comparable[T] = null
foo
def foo[T]: List[T] = null
foo
def bar[T]: Comparable[T] = null
bar
class C[+T]
def foo[T]: C[T] = null
class D[-T]
def bar[T]: D[T] = null
bar
typeOf[List[Int]]
typeOf[Int]
typeOf[String]
typeOf[T forSome { type T <: Int }]
typeOf[{def x: Int; type T <: Int}]
val x = 5
val replClassloader = Thread.currentThread().getContextClassLoader
val outerField = replClassloader.getClass.getFields.head
val interpreter = outerField.get(replClassloader).asInstanceOf[scala.tools.nsc.interpreter.IMain]
interpreter.definedSymbolList
res0(0)
res0(0).fullName
res0(0).fullNameString
res0.owner
res2.owner
res1.owner
res1.owner.owner
res1.owner.owner.owner
.owner
val x = 2
x
val x = 2
val y = x
interpreter.originalPath
interpreter.fullPath
interpreter.global
interpreter.global.exitingTyper
interpreter.global.exitingPhase
interpreter.global.afterPhase
interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)
interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)(res1.fullName)
interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)(res1.fullNameString)
res1.javaClassName
interpreter.handlers
interpreter.prevRequests
interpreter.prevRequestList
interpreter.prevRequestList.takeRight(5)
interpreter.allHandlers
interpreter.allHandlers.takeRight(10)
interpreter.allHandlers foreach println
interpreter.allHandlers.reverse(10)
res27.definesTerm
interpreter.prevRequestList.takeRight(5)
val replClassloader = Thread.currentThread().getContextClassLoader
val outerField = replClassloader.getClass.getFields.head
val interpreter = outerField.get(replClassloader).asInstanceOf[scala.tools.nsc.interpreter.IMain]
val handlers = interpreter.prevRequestList
val reqs = interpreter.prevRequestList
reqs.flatMap(_.definedNames)
val replClassloader = Thread.currentThread().getContextClassLoader
val outerField = replClassloader.getClass.getFields.head
val replClassloader = Thread.currentThread().getContextClassLoader
val interpreter = outerField.get(replClassloader).asInstanceOf[scala.tools.nsc.interpreter.IMain]
val reqs = interpreter.prevRequestList
reqs.flatMap(_.definedNames.asInstanceOf[List[Any]])
val replClassloader = Thread.currentThread().getContextClassLoader
val outerField = replClassloader.getClass.getFields.head
val interpreter = outerField.get(replClassloader).asInstanceOf[scala.tools.nsc.interpreter.IMain]
val reqs = interpreter.prevRequestList
val fullPaths = reqs.flatMap(req => req.definedNames.map(name => req.fullPath(name)))
reqs(0)
res2.definedNames
res1.definedNames.asInstanceOf[Any]
res1.definedNames.asInstanceOf[List[_]]
res1.definedNames.map(_.toString)
res1.fullPath(res4(0))
res1.line
res1.lineRep
res1.lineRep.readPath
res1.accessPath
val fullPaths = reqs.flatMap(req => req.definedNames.map(name => s"${req.lineRep.readPath}${req.accessPath}.`$name`"))
reqs(0).lineRep
reqs(0).lineRep.readPath
reqs(0).definedName
reqs(0).definedNames
reqs(0).definedNames.asInstanceOf[Any]
interpreter
val fullPaths = reqs.map(req => req.lineRep.readPath)
val fullPaths = reqs.flatMap(req => req.definedNames.map(name => s"${req.lineRep.readPath}${req.accessPath}.`$name`"))
val fullPaths = reqs.flatMap(req => req.definedNames.map(name => req.lineRep.readPath))
val fullPaths = reqs.flatMap(req => req.definedNames.map(name => req.lineRep.readPath + req.accessPath))
val readPaths = reqs.flatMap(req => req.definedNames.map(_ => req.lineRep.readPath))
val accessPaths = reqs.flatMap(req => req.definedNames.map(_ => req.accessPath))
val names = reqs.flatMap(req => req.definedNames.map(name => "." + name.toString))
def mineInfoFromReqs(fn: (interpreter.Request, String) => String): List[String] = ???
def mineInfoFromReqs(fn: (interpreter.Request, String) => String): List[String] = reqs.flatMap(req => req.definedNames.map(name => fn(req, name)))
def mineInfoFromReqs(fn: (interpreter.Request, String) => String): List[String] = reqs.flatMap(req => req.definedNames.map(name => fn(req, name.toString)))
def getInfoFromReqs(fn: (interpreter.Request, String) => String): List[String] = reqs.flatMap(req => req.definedNames.map(name => fn(req, name.toString)))
def mapDefinedNames[T](fn: (interpreter.Request, String) => T): List[T] = reqs.flatMap(req => req.definedNames.map(name => fn(req, name.toString)))
val fullPaths = mapDefinedNames((_, _) => "")
val fullPaths = ListBuffer(mapDefinedNames((_, _) => ""))
val fullPaths = scala.collection.mutable.ListBuffer(mapDefinedNames((_, _) => ""))
val fullPaths = scala.collection.mutable.ListBuffer[String]() ++ mapDefinedNames((_, _) => "")
def mapDefinedNames[T](fn: (interpreter.Request, String) => T): List[T] = reqs.flatMap(req => req.definedNames.map(name => fn(req, name.toString)))
val parts = List(mapDefinedNames((req, _) => req.lineRep.readPath), mapDefinedNames((req, _) => req.accessPath), mapDefinedNames((_, name) => "." + name))
parts.transpose.map(_.mkString)
parts.transpose
List("1", "2").mkString
parts.transpose(0).mkString
res7(0).mkString
res7(0)
res7(1)
res7(2)
res7(0)(0)
res7(0)(1)
res7(0)(2)
res7(0)(0) + res7(0)(1) + res7(0)(2)
(res7(0)(0) + res7(0)(1) + res7(0)(2)).length
println(res7(0)(0) + res7(0)(1) + res7(0)(2))
val replClassloader = Thread.currentThread().getContextClassLoader
val outerField = replClassloader.getClass.getFields.head
val interpreter = outerField.get(replClassloader).asInstanceOf[scala.tools.nsc.interpreter.IMain]
interpreter.definedSymbolList
interpreter.definedSymbolList foreach (sym => println(sym.fullNameString))
interpreter.definedSymbolList foreach (sym => println(interpreter.global.afterPhase(interpreter.global.typerPhase)(sym.fullNameString))
)
interpreter.definedSymbolList foreach (sym => println(interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)(sym.fullNameString)))
interpreter.definedSymbolList foreach (sym => println(interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)(sym.fullName)))
interpreter.definedSymbolList foreach (sym => interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)(sym.fullName))
"$line2.$read"
"$line2.$read" + ".$iw"
"$line2.$read" + ".$iw.$iw"
"$line2.$read" + ".$iw.$iw.cm"
interpreter.definedSymbolList map (sym => interpreter.global.afterPhase(interpreter.global.currentRun.typerPhase)(sym.fullName))
def impl(c: Context): c.Expr[Int] = c.universe.Ident(c.universe.TermName("$qmark$qmark$qmark"))
def impl(c: Context): c.Expr[Int] = c.Expr(c.universe.Ident(c.universe.TermName("$qmark$qmark$qmark")))
def foo = macro impl
def x: String = foo
val x: String = foo
typeTag[List[Int]] <:< typeTag[List[Any]]
typeTag[List[Int]].tpe <:< typeTag[List[Any]].tpe
abstract class AbsIterator extends AnyRef 
trait RichIterator extends AbsIterator
class StringIterator extends AbsIterator
class Iter extends StringIterator with RichIterator
typeOf[Iter].baseClasses
typeOf[Iter].typeSymbol.baseClasses
typeOf[Iter].typeSymbol.asClass.baseClasses
new { def x = 2 }
trait Foo[T] { implicit def contextBound: Bar[T] }
class Bar[T]
trait Foo[T] { implicit def contextBound: Bar[T] }
class C[T: Bar] extends Foo[T]
class C[T: Bar] extends Foo[T] { override def contextBound = implicitly[Bar[T]] }
implicit object BarInt extends Bar[Int]
new C[Int]
new C[Int]().contextBound
{ def foo
class C { def foo(x: Int) = x; def foo(y: String = "") = y }
class C { def foo(x: Int) = x; def foo(y: String = "") = y; def foo(z: Double = 0) = z }
class C { def foo(x: Int, y: String) = 1; def foo(x: Int, y: Int) = 2 }
new C().foo(x = 2)
class C { def foo(x: Int, y: String) = 1; def foo(x: Int) = 2 }
class C { def foo(x: Int, y: String = "") = 1; def foo(x: Int) = 2 }
new C().foo(x = 2)
class C { def foo(x: Int, y: String = "") = x; def foo(x: Int) = x }
new C().foo(x = 2)
class C { def foo(x: Int, y: String = "") = x; def foo(x: Int) = x }
new C().foo(x = 2)
class C { def foo(x: Int, y: Int)(z: Int, w: Int) = x }
new C().foo(y = 2, x = 3)(w = 4, z = 5)
class D { def foo(x: Int = 2) = x }
new D().foo()
List(1, 2).toMap
List((1, 2)).toMap
List(1, 2, 3).init
List().collectNot
???
val a = 1; val s =f"$a%s%n$a%s"
f"%n"
class Foo { def this(x: Int, y: Int) = macro impl }
class C
class D
type X = C with D
new X
class C
def impl(c: Context) = {
import c.universe._
Ident(c.typeOf[C].typeSymbol)
}
type X = macro impl
class D
type Y = D with X
new Y
List(1, 2).view
List(1, 2).view match { case x :: _ => x }
List(1, 2).view match { case x #:: _ => x }
List(1, 2).view match { case x :+ _ => x }
List(1, 2).view match { case x :+ _ => x.toList }
List(1, 2).view match { case x +: _ => x }
List(1, 2).view.flatMap{ case x if x == 1 => x; case _ => ??? } match { case x +: _ => x }
List(1, 2).view.flatMap{ case x if x == 1 => Some(x); case _ => ??? } match { case x +: _ => x }
class C(x: Int)
def foo(x: Int) = { println("ho ho ho"); new C(x) }
def tryFoo(x: Int) = { println("ho ho ho"); Some(new C(x)) }
List(1, 2, 3).view.flatMap(tryFoo) match { case C(x) => println("boo!") }
case class C(x: Int)
def tryFoo(x: Int) = { println("ho ho ho"); Some(C(x)) }
List(1, 2, 3).view.flatMap(tryFoo) match { case C(x) => println("boo!") }
List(1, 2, 3).view.flatMap(tryFoo) match { case C(x) +: _ => println("boo!") }
case class C(x: Int)
def tryFoo(x: Int) = { println("ho ho ho"); Some(C(x)) }
List(1, 2, 3).view.flatMap(tryFoo) match { case C(x) +: _ => println("boo!") }
exit
typeOf[Int].baseClasses
implicit class HasWhere(val exp : _) {}
    implicit class HasWhere(val exp : _) {
    def where(block : Unit) = macro whereInfix
    }
implicit class HasWhere(val exp : _) {
def where(block : Unit) = macro whereInfix
}
def impl(c: Context)(block: c.Tree) = c.literalUnit
implicit class HasWhere(val exp : _) {
def where(block : Unit) = macro impl
}
c where {}
typeOf[List[Int] { type X = Int }]
exit
typeOf[scala.reflect.pickling.Pickler[String] { type PickleType = scala.reflect.pickling.json.JSONPickle }]
typeOf[scala.pickling.Pickler[String] { type PickleType = scala.pickling.json.JSONPickle }]
null.asInstanceOf[String]
null.asInstanceOf[2]
null.asInstanceOf[Int]
def foo[T] = null.asInstanceOf[T]
foo[Int]
foo[String]
showRaw(typeOf[List[Int]{}])
showRaw(null.asInstanceOf[List[Int]{}])
showRaw(reify(null.asInstanceOf[List[Int]{}]))
reify{ val x: List[Int]{} = ??? }
showRaw(reify{ val x: List[Int]{} = ??? })
ListMap(Map(1 -> 2))
scala.collection.immutable.ListMap(Map(1 -> 2))
scala.collection.immutable.ListMap() ++ Map(1 -> 2)
2.asInstanceOf[Short]
100000.asInstanceOf[Byte]
val tpe = typeOf[Int]
tpe match { case tpe if tpe =:= typeOf[Int] => tpe }
import scala.collection.immutable.ListMap
sealed class UnpickleIR
case class ValueIR(value: Any) extends UnpickleIR
case class ObjectIR(tpe: Type, fields: ListMap[String, UnpickleIR]) extends UnpickleIR
import scala.collection.immutable.ListMap
sealed class UnpickleIR;case class ValueIR(value: Any) extends UnpickleIR;case class ObjectIR(tpe: Type, fields: ListMap[String, UnpickleIR]) extends UnpickleIR
val x: UnpickleIR = null
x match {
case ir @ ObjectIR(tpe, _) => null
case ir @ ValueIR(_) => null
}
x match {
case ir @ ObjectIR(tpe, _) => null
case ir @ ValueIR(_) => null
case _ => null
}
import scala.reflect.runtime.universe._ // underscore import is important in order not to get erasure warnings
reify((x: Int, y: Int) => x + 2)
showRaw(res0)
val Function(params, body) = res0.tree
val paramNames = params map (_.name)
new Traverser { override def traverse(tree: Tree) = tree match {
case Ident(name) if paramNames contains name => println(s"got $name")
case _ => super.traverse(tree)
} }.traverse(body)
// this was unreliable, because in a body of a function one could well define another variable named x or y, so you might get wrong results
// scalac binds definitions and their usages using symbols
// to get the reified tree attributed (i.e. have its symbols and types assigned), use a toolbox
import scala.tools.reflect.ToolBox
val cm = scala.reflect.runtime.currentMirror
val tb = cm.mkToolBox()
tb.typeCheck(res0.tree)
showRaw(res3)
showRaw(res3, printIds = true)
// note the #(\d)+ things in the last printout - they denote symbols
val Function(params, body) = res3.tree
val Function(params, body) = res3
val paramSymbols = params map (_.symbol)
new Traverser { override def traverse(tree: Tree) = tree match {
case ident: Ident if paramSymbols contains ident.symbol => println(s"got ${ident.symbol.name}")
case _ => super.traverse(tree)
} }.traverse(body)
def foo[T](x: T) = tb.eval(reify(x))
def foo[T](x: T) = tb.eval(reify(x).tree)
foo(2)
def foo[T](y: T) = tb.eval(reify({ val y: T = x; y }).tree)
def foo[T](x: T) = tb.eval(reify({ val y: T = x; y }).tree)
foo(2)
def foo[T: TypeTag](x: T) = tb.eval(reify({ val y: T = x; y }).tree)
foo(2)
val x = reify(2)
q"$x"
val x = reify(2)
q"$x"
val x = reify(2)
q"$x"
val it
=
staticClass("scala.collection.Iterable")
val iterableClass = cm.staticClass("scala.collection.Iterable")
iterableClass.toType
existentialAbstraction(iterableClass.toType)
showRaw(res0)
iterableClass.toType.asInstanceOf[TypeRef]
res3.args
existentialAbstraction(res3.args, res3)
existentialAbstraction(res3.args map (_.typeSymbol), res3)
q"case foo => bar"
val cdef = CaseDef(Ident(nme.WILDCARD), EmptyTree, q"???")
q"x match { $cdef }"
class X
object D extends X
typeOf[D.type]
typeOf[D.type].sourceModule
typeOf[D.type].typeSymbol
res2.sourceModule
res2.companion
res2.companionSymbol
res2 eq res5
res5.typeSignature.baseClasses
res2.typeSignature.baseClasses
Predef.Triple
object Foo
typeOf[Foo.type].typeSymbol
res0.isModule
res0.isClass
object Foo { object Bar }
typeOf[Foo.type].typeSignature
typeOf[Foo.type].members
typeOf[Foo.type].members.toList.head
res5.isModule
res5.asModule.moduleClass
res5.asModule.moduleClass.asClass.baseClasses
Predef$Triple$
IntClass.isSealed
IntClass.isFinal
cm.reflect[Boolean](true)(ClassTag.Boolean).symbol.asType.toType
showRaw(res0)
typeof[::[_]]
typeoOf[::[_]]
typeOf[::[_]]
res2.typeSymbol
res2.name
res3.name
res3.name.decoded
typeOf[List[Int]]
typeOf[::[_]].typeSymbol.typeSignature
typeOf[::[_]].typeSymbol.asType.toType
typeOf[List[Int]]
typeOf[::[_]].typeSymbol.asType.toType
res5.typeSignatureIn(res4)
res5.typeSymbol.typeSignatureIn(res4)
res5.asSeenFrom(NoPrefix, res4)
res5.asSeenFrom(NoPrefix, res4.typeSymbol)
res5.asSeenFrom(res4, res4.typeSymbol)
def qwe[T: TypeTag]: ::[T] = { println(typeOf[T]); Nil }
def qwe[T: TypeTag]: ::[T] = { println(typeOf[T]); ::(1, Nil).asInstanceOf[::[T]] }
val qqq: List[Int] = qwe
def foo(xx: List[Int]) = ()
foo(qwe)
l3.CL3ToCPSTranslator
CL3ToCPSTranslator
l3.CL3ToCPSTranslator
Some[_](1)
q"{case x => }"
q"case x =>"
def impl(c: Context)(x: c.Tree) = {
import c.universe._
x match {
case Bind(name, tree) => Bind(TermName(name.toString + name.toString), tree_
object Macros { def apply(x: Int) = x }
Macros(2)
null.asInstanceOf[Null]
val cc: List[CaseDef] = Nil
q"2 match { ..$cc }"
"a.b".split(".")
"a.b".split('.')
"a".split('.')
"a".split('.').map(_.capitalize)
class C(val x: Int)
typeOf[C].declarations
val ctor = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten
typeOf[C].declarations.toList
res1(0) == ctor(0)
res1(0) == ctor(1)
res1(0) == ctor(0)
res1(1) == ctor(0)
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten(0)
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten().apply(0)
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten.apply(0)
val x1 = typeOf[C].declarations.toList().apply(0)
val x1 = typeOf[C].declarations.toList(0)
val x2 = typeOf[C].declarations.toList(1)
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten.apply(0)
x1.isMethod
x2.isMethod
ctorx.isMethod
val x1 = typeOf[C].declarations.toList(0).asTerm
val x2 = typeOf[C].declarations.toList(1).asTerm
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten.apply(0).asTerm
x1.accessed
x2.accessed
x2.accessor
val x1 = typeOf[C].declarations.toList(0).asTerm
val x2 = typeOf[C].declarations.toList(1).asTerm
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten.apply(0).asTerm
x1.isParamAccessor
x2.isParamAccessor
ctorx.isParamAccessor
ctorx.isParameter
x1.isParameter
x2.isParameter
ctorx.isPublic
x1.isPublic
x2.isPublic
class C(x: Int)
val x1 = typeOf[C].declarations.toList(0).asTerm
val x2 = typeOf[C].declarations.toList(1).asTerm
val ctorx = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod.paramss.flatten.apply(0).asTerm
ctorx.isPublic
x1.isPublic
x1.isParamAccessor
x1.isAccessor
new String("X")
q""
val x = Nil
q"1; ..$x; 1"
class C(x: Int)(y: Int)
object D
val mc = typeOf[D.type].typeSymbol
mc.isModuleClass
mc.isFinal
def foo[T <: Singleton] = 1
class C
object C
classC; object C
class C; object C 
foo[C]
foo[C.type]
val x = 1
foo[x.type]
val x = "1"
foo[x.type]
scala.misc.Unsafe
sun.misc.Unsafe
sun.misc.Unsafe.instance
sun.misc.Unsafe.getUnsafe
val ann = q"new ann"
q"@$ann val x = 2"
val ann2 = q"@ann"
val ann3 = tq"ann"
q"@$ann3 val x = 2"
val ann3 = List(tq"ann")
q"@..$ann3 val x = 2"
class MPair[A, B](val left: A, val right: B)
val tpe = typeOf[
val tpe = typeOf[MPir[Int, String]]
val tpe = typeOf[MqPir[Int, String]]
val tpe = typeOf[MPair[Int, String]]
tpe.declarations.collect{ case meth: MethodSymbol if meth.isParamAccessor => meth }
tpe.declarations.collect{ case meth: MethodSymbol if meth.isParamAccessor => meth }.toList(0)
val sym = tpe.declarations.collect{ case meth: MethodSymbol if meth.isParamAccessor => meth }.toList(0)
sym.typeSignature
sym.typeSignatureIn(tpe)
val tpe = typeOf[MPair[Int, String]]
val sym = tpe.declarations.collect{ case meth: MethodSymbol if meth.isParamAccessor => meth }.toList(0)
sym.typeSignature
sym.typeSignatureIn(tpe)
tpe.declarations
class MPair[A, B](val left: A, val right: B)
val tpe = typeOf[MPair[Int, String]].typeSymbol.asType.toType
showRaw(tpe)
val sym = typeOf[MPair[Int, String]].typeSymbol.asClass
sym.typeParams
sym.typeParams(0).asType.toType
sym.typeParams(0).asType.toType.erasure
class Foo[T: TypeTag](x: Int)
typeOf[Foo].declarations
typeOf[Foo[_]].declarations
classOf[Foo[_]].getMethods
classOf[Foo[_]].getDeclaedMethods
classOf[Foo[_]].getDeclaredMethods
typeOf[Int].baseClasses
implicitly[CanBuildFrom[List[_], _, List[_]]]
implicitly[scala.collection.generic.CanBuildFrom[List[_], _, List[_]]]
exit
List(1, 2).max
1 to 5
"1" * 10
"1".substring(1)
typeOf[List[Int]].erasure
import scala.pickling._
import json._
List(1, 2).pickle
val cons = classOf[scala.collection.immutable.::[_]]
cons.getDeclaredFields
cons.getDeclaredMethods
val x = Map(1 -> 2)
x(null)
val x = Map("1" -> 2)
x(null)
System.getEnv.toMap
System.getenv.toMap
System.getenv
System.getenv.toList
System.getenv.asScalaMap
WrapAsScala.asScalaMap(System.getenv)
scala.collection.convert.WrapAsScala.asScalaMap(System.getenv)
scala.collection.convert.WrapAsScala.mapAsScalaMap(System.getenv)
System.getEnv.getKeys
System.getenv.getKeys
System.getenv.keys
System.getenv.keySet
System.getProperties
System.getProperties.keys
System.getProperties.keys.toList
scala.collection.convert.WrapAsScala.enumerationAsScalaIterator(System.getProperties.keys)
scala.collection.convert.WrapAsScala.enumerationAsScalaIterator(System.getProperties.keys).toList
scala.collection.convert.WrapAsScala.enumerationAsScalaIterator(System.getProperties.keys).toList foreach println
typeOf[Object].toString
object C
typeOf[C.type].toString
classOf[Int] match { case classOf[Int] => 1 }
"""(.*?)\[(.*?)\]""".r
res0.match
res0.matches
res0.findAllIn("C[Int]")
res0.findAllIn("C[Int]").toList
res0.findFirstIn("C[Int]")
"""(.*?)\[(.*?)\]""".r
val tper """(.*?)(\[(.*?)\])?""".r
val tper = """(.*?)(\[(.*?)\])?""".r
tper.unapplySeq("C[Int]")
tper.unapplySeq("C")
tper.unapplySeq("")
tper.unapplySeq("C[Int, Int]")
val tper = """^(.*?)(\[(.*?)\])?$""".r
tper.unapplySeq("C[Int, Int]")
tper.unapplySeq("")
case class X(x: Int, private y: => Int)
case class X(x: Int, private val y: => Int)
case class C(arr: Array[Int])
typeOf[C].declarations
typeOf[C].declarations.toList.take(2)
res1(0).typeSignature
res1(1).typeSignature
class C[T]
typeOf[C[Any]].typeSymbol.asType.toTypeConstructor
List("x") == List("x")
import scala.collection.generic._
import scala.collection.immutable.::
type X = CanBuildFrom[::[Int], Int, ::[Int]]
implicitly[X]
implicitly[CanBuildFrom[::[Int], Int, ::[Int]]]
implicitly[CanBuildFrom[::[_], Int, ::[Int]]]
implicitly[CanBuildFrom[List[_], Int, List[Int]]]
implicitly[CanBuildFrom[::[_], Int, List[Int]]]
implicitly[CanBuildFrom[::[_], Int, ::[Int]]]
import scala.pickling._
import json._
5.pickle
case class C(x: Int)
C(2).pickle
exit
typeOf[::[_]]
res0.typeSymbol.flags
res0.typeSymbol.typeSignature
res0.typeSymbol.flags
typeOf[Some[_]].flags
typeOf[Some[_]].typeSignature
typeOf[::[_]].isFinal
typeOf[::[_]].typeSymbol.isFinal
'!'.toInt
class C
typeOf[C].typeSymbol.typeSignature
typeOf[C].typeSymbol.typeSignature.typeSymbol
typeOf[Option[_]].typeSymbol.typeSignature
res0.typeSymbol.toType
res0.typeSymbol.asType.toType
System.currentTimeMillis
needsMacroExpansion
def foo(x: Int, y: Int) = x + y
def bar(fn: (Int, Int) => Int) = fn(40, 2)
bar(foo)
val x = Character.isWhitespace
val x = Character.isWhitespace _
def impl(c: Context)(args: c.Tree*) = c.literalUnit
def foo(args: _*) = macro impl
foo(qwe = 1, qqq = 2)
def impl(c: Context)(args: c.Tree*) = c.literal(args.toString)
def foo(args: _*) = macro impl
foo(qwe = 1, qqq = 2)
scala> def impl(c: Context)(args: c.Tree*) = c.literal(args.toString)
impl: (c: scala.reflect.macros.Context)(args: c.Tree*)c.Expr[String]
scala> def foo(args: _*) = macro impl
defined term macro foo: (args: _*)String
scala> foo(qwe = 1, qqq = 2)
class A
(ru: api.Universe).typeTag[A]
(ru: scala.reflect.api.Universe).typeTag[A]
(ru: scala.reflect.api.Universe).weakTypeTag[A]
typeTag[Int]
(ru: scala.reflect.api.JavaUniverse).weakTypeTag[A]
class A
(ru: scala.reflect.api.Universe).weakTypeTag[A]
class A
(ru: scala.reflect.api.Universe).weakTypeTag[A]
import reflect._
class A
import reflect._
runtime.universe: api.Universe
res0.typeTag[A]
res0.typeTag[A].in(currentMirror)
res0.typeTag[A].in(cm)
res0.typeTag[A].in(scala.reflect.runtime.currentMirror)
"%.2f%"
"%.2f%".format(0)
"%.2f x%".format(0)
"%.2f".format(0)
"%.2f".format(0f)
"%.2f".format(0.0)
f"${0}2f"
f"${0}%2f"
f"${0}%.2f"
object C
val c = classOf[C]
val cm = scala.reflect.runtime.currentMirror
cm.classSymbol(c)
c.companionSymbol
res0.companionSymbol
c.typeSignature
class C; object C
val cm = scala.reflect.runtime.currentMirror
class C; object C
import scala.reflect.runtime.{currentMirror => cm}
cm.classSymbol(classOf[C]).companionSymbol
cm.reflectModule(res0).instance
cm.reflectModule(res0.asModule).instance
q""
val as = List(q"1", q"2")
val sum = q"..$as.sum"
"%%".format()
reify(f"%%")
reify(manifest[Some[_]])
tb.parse("2").pos
tb.parse("x")
val tb = cm.mkToolBox()
tb.parse("x").pos
ru.reify{type X = List[T] forSome {type T} }
val s = Seq[Int](1,2,3)
val m = runtimeMirror(this.getClass.getClassLoader)
m.reflect(s).symbol.asType.toType
m.reflect(s).symbol.typeSignature
m.reflect(s).symbol.asType.toType <:< typeOf[Seq[Int]]
def foo(implicit x: Int) = x
foo
{ def x = 2; def y = z; def z = x }
def foo(x: AnyRef) = x
foo(2)
:power
:vals
typer
typer.typedTYpe
typer.typedType
typer.typedType(TypeTree(IntTpe))
TypeTree(IntTpe).original
object A{def p= println("hi")}
reify(A.p)
shwoRaw(res0, printIds = true)
showRaw(res0, printIds = true)
import scala.tools.reflect.ToolBox
val tb = scala.reflect.runtime.currentMirror.mkToolBox
val tb = scala.reflect.runtime.currentMirror.mkToolBox()
tb.typeCheck(res0.tree)
showRaw(res3, printIds = true)
Set(1) intersect Set(1, 2)
Set(1) * Set(1, 2)
Map(1 -> 2) - 1
Map(1 -> 2) -- List(1)
Map(1 -> 2) ++ Map(1 -> 3)
f"%n"
f"%"
f"%n"
f"%"
"%".format()
f"${0}%.2f%"
f"${0}%.2f"
"".substring(0, 1)
"%%".format()
f"%n"
f"${0}%n"
exit
f"${0}%n"
f"%n%n%n%n"
s"aaa$"
List(Array(0), Array(0L)).map(x => x)
lub
lub(typeOf[Array[String]], typeOf[Array[Nothing]])
lub(List(typeOf[Array[String]], typeOf[Array[Nothing]]))
if (false) Array("qwe") else Array()
if (false) Array("qwe") else Array[Nothing]()
1 to 10
2 / 3
case class Foo(i: Int, s: String, b: Boolean)
def foo[C, L](c: C)(implicit iso: Iso[C, L]): L = iso.to(c)
def foo[C, L](c: C)(implicit iso: Iso[C, L]): L = println(iso.to(c))
def foo[C, L](c: C)(implicit iso: Iso[C, L]) = println(iso.to(c))
case class Foo(i: Int, s: String, b: Boolean)
foo(Foo(23, "foo", true))
Array()
def foo(arr: Array[Char]) = arr
foo(Array())
q"x"
ilem
 import language.experimental._, reflect.macros.Context
object GrabContext {
  def lastContext = Option(System.getProperties.get("lastContext")
    .asInstanceOf[reflect.macros.runtime.Context])
  // System.properties lets you stash true globals (unlike statics which are classloader scoped)
  def impl(c: Context)() = { System.getProperties.put("lastContext", c); c.literalUnit }
  def grab() = macro impl 
}
object Test { class C(implicit a: Any) { GrabContext.grab } }
GrabContext.lastContext.get.callsiteTyper.context.implicitss
object Test1 { class C(implicit a: Any) { GrabContext.grab } }
 import language.experimental._, reflect.macros.Context
object GrabContext {
  def lastContext = Option(System.getProperties.get("lastContext")
    .asInstanceOf[reflect.macros.runtime.Context])
  // System.properties lets you stash true globals (unlike statics which are classloader scoped)
  def impl(c: Context)() = { System.getProperties.put("lastContext", c); c.literalUnit }
  def grab() = macro impl 
}
object Test { class C(implicit a: Any) { GrabContext.grab; GrabContext.grab } }
 import language.experimental._, reflect.macros.Context
object GrabContext {
  def lastContext = Option(System.getProperties.get("lastContext")
    .asInstanceOf[reflect.macros.runtime.Context])
  // System.properties lets you stash true globals (unlike statics which are classloader scoped)
  def impl(c: Context)() = { System.getProperties.put("lastContext", c); c.literalUnit }
  def grab() = macro impl 
}
object Test { class C(implicit a: Any) { GrabContext.grab } }
import language.experimental._, reflect.macros.Context
object GrabContext {
  def lastContext = Option(System.getProperties.get("lastContext")
    .asInstanceOf[reflect.macros.runtime.Context])
  // System.properties lets you stash true globals (unlike statics which are classloader scoped)
  def impl(c: Context)() = { System.getProperties.put("lastContext", c); c.literalUnit }
  def grab() = macro impl 
}
object Test { class C(implicit a: Any) { GrabContext.grab } }
import language.experimental._, reflect.macros.Context
object GrabContext {
  def lastContext = Option(System.getProperties.get("lastContext")
    .asInstanceOf[reflect.macros.runtime.Context])
  // System.properties lets you stash true globals (unlike statics which are classloader scoped)
  def impl(c: Context)() = { System.getProperties.put("lastContext", c); c.literalUnit }
  def grab() = macro impl 
}
object Test { class C(implicit a: Any) { GrabContext.grab } }
    import scala.collection.JavaConverters._
val iterator: Iterator[(Object, Object)] = System.getProperties.asScala.iterator
iterator.collect{ case (k: String, v: String) => (k, v) }
iterator.collect{ case (k: String, v: String) => (k, v) }.toMap
val l = List(1,2,3)
def getTypeTag[T: ru.TypeTag](obj: T) = ru.typeTag[T]
val theType = getTypeTag(l).tpe
:t getTypeTag(l).tpe _
import foo._
exit
showRaw(reify(2))
class SomeClass(val intValue:Int) 
class MyClass[T <: SomeClass](val myValue:T) 
def f3[T](i: MyClass[T]) = ???
  reify({ case class R(id: Int); val lb = new ListBuffer[R](); lb
+= R(1)  })
})
  reify({ case class R(id: Int); val lb = new ListBuffer[R](); lb
+= R(1)  })
import scala.collection.mutable.ListBuffer
  reify({ case class R(id: Int); val lb = new ListBuffer[R](); lb
+= R(1)  })
reify({ case class R(id: Int); val lb = new ListBuffer[R](); lb += R(1) })
reify({ case class R(id: Int); val lb = new ListBuffer[R](); lb += R(1); () })
val build = scala.reflect.runtime.universe.build
val x = build.setTypeSignature(build.newFreeTerm("x", 2), typeOf[Int])
def foo(x: Double) = { println(2 + 1 / x); foo(2 + 1 / x) }
def foo(x: Double): Double = { println(2 + 1 / x); foo(2 + 1 / x) }
foo(2.5)
def foo(x: Double): Double = { println(1 + 1 / x); foo(1 + 1 / x) }
foo(2)
(Math.sqrt(5) + 1) / 2
class C1(val n: Int) extends AnyVal 
type T1 = C1
typeOf[T1]
typeOf[T1].erasure
typeOf[C1].erasure
typeOf[T1].typeSymbol
typeOf[C1].typeSymbol
exit
val tpe = weakTypeOf[Int]
showRaw(tq"$tpe")
q"new {()}"
showRaw(res0)
exit
q"x"
tq"X"
q"return x"
val tree = q"x"
q"return $tree"
exit
class A(val aparam: String)
class B(bparam: String) extends A(bparam)
ru.typeTag[B].tpe.declarations
println(scala.reflect.runtime.universe.typeTag[B].tpe.declarations)
ru.typeTag[B].tpe.members
val bparam = ru.typeTag[B].tpe.members.toList(1)
val aparam = ru.typeTag[B].tpe.members.toList(2)
val bparam = ru.typeTag[B].tpe.members.toList(1).asTerm
val aparam = ru.typeTag[B].tpe.members.toList(2).asTerm
aparam.isParamAccessor
bparam.isParamAccessor
bparam.isParam
bparam.isVal
aparam.isVal
val b = new B("hello")
val mirror = runtimeMirror(b.getClass.getClassLoader)
val alltypes = mirror.reflect(b).symbol.typeSignature.baseClasses.filter(c => c.isClass).map(c => c.asClass.typeSignature)
val vars: Seq[TermSymbol] = alltypes.flatMap(t => t.members.filter(m => m.isTerm && (m.asTerm.isVal || m.asTerm.isVar)).map(x => x.asTerm))
vars
val a = vars(1)
val b = vars(2)
val b = vars(0)
a
b
a.isParamAccessor
b.isParamAccessor
a.isVal
b.isVal
a.isPrivate
b.isPrivate
a.asInstanceOf[scala.reflect.internal.Symbols#Symbol].flags
b.asInstanceOf[scala.reflect.internal.Symbols#Symbol].flags
a.owner
b.owner
val vars: Seq[TermSymbol] = alltypes.flatMap(t => t.members.filter(m => m.isTerm && (m.asTerm.isMethod)).map(x => x.asTerm))
val vars: Seq[TermSymbol] = alltypes.flatMap(t => t.members.filter(m => m.isTerm && (m.asTerm.isMethod && m.asTerm.isParamAccessor)).map(x => x.asTerm))
a.accessor
a.getter
b.getter
val vars: Seq[TermSymbol] = alltypes.flatMap(t => t.members.filter(m => m.isTerm && (m.asTerm.isVal || m.asTerm.isVar)).map(x => x.asTerm))
val aparam = vars(1)
val bparam = vars(0)
aparam.getter
bparam.getter
val Apply(fun, args) = q"f(x)"
case class Foo(x: Int, y: Int)
class C { lazy val C(x, y) = C(2, 3) }
class C { lazy val Foo(x, y) = Foo(2, 3) }
exit
val i = 3val j = 3
val j = 3
val i = 3
(for (x = Option(i); if x == j) yield 42) toList
type F = List[F, Int]
type F = Map[F, Int]
exit
val Long = 1
Long
List(100, 200).zipWithIndex
List(100, 200).zipWithIndex.map{ case(x, i) => x + i }
case class C(x: Int)
typeOf[C].fields
typeOf[C].declarations
typeOf[C].declarations.collect{ case x: MethodSymbol if x.isAccessor => x }
typeOf[C].declarations.collect{ case x: MethodSymbol if x.isParamAccessor => x }
case class C[T](x: T)
val T = typeOf[C[Int]]
T match { case PolyType(_, _) => println("polymorphic entities are not supported"); case _ => }
T.typeSymbol.asType.typeParams
T.typeSymbol.asType.isCaseClass
T.typeSymbol.asClass.isCaseClass
((x: Int) => x)(2)
exit
new C().foo
exit
classOf[C].getConstructors
class C(x: Int)
classOf[C].getConstructors
exit
type T = Int
class C { def foo(x: T*) = ??? }
typeOf[C].declarations
typeOf[C].declarations.toList(1)
typeOf[C].declarations.toList(1).asMethod.paramss.flatten
typeOf[C].declarations.toList(1).asMethod.paramss.flatten(0).typeSignature
typeOf[C].declarations.toList(1).asMethod.paramss.flatten().apply(0).typeSignature
typeOf[C].declarations.toList(1).asMethod.paramss.flatten.apply(0).typeSignature
typeOf[C].declarations.toList(1).asMethod.paramss.flatten.apply(0).typeSignature.dealias
typeOf[C].declarations.toList(1).asMethod.paramss.flatten.apply(0).typeSignature.normalize
typeOf[C].declarations.toList(1).asMethod.paramss.flatten.apply(0).typeSignature.asInstanceOf[scala.reflect.internal.Types#Type]
res8.dealiasWiden
type T = Int
class C { def foo(x: T*) = ??? }
val tstar = typeOf[C].declarations.toList(1).asMethod.paramss.flatten().apply(0).typeSignature
val tstar = typeOf[C].declarations.toList(1).asMethod.paramss.flatten.apply(0).typeSignature
val tstar = typeOf[C].declarations.toList(1).asMethod.paramss.flatten.apply(0).typeSignature.asInstanceOf[scala.reflect.internal.Types#Type]
tstar.dealias
tstar.dealiasWiden
exit
class C[T] { type T = Int }
class Foo(x: Int) extends AnyVal
class Foo(val x: Int) extends AnyVal
val x: Foo = new Foo(2)
(x: Any) match { case x: Foo => x }
val x: List[Foo] = List(new Foo(2))
x(0) match { case x: Foo => x }
val payload = Map[String, Any]("x" -> List(new Foo(2)))
payload match { case (k, List(v: Fingerprint)) => v }
payload(0) match { case (k, List(v: Fingerprint)) => v }
payload.toList(0) match { case (k, List(v: Fingerprint)) => v }
payload.toList(0) match { case (k, List(v: Foo)) => v }
classOf[scala.Double].isAssignableFrom
classOf[scala.Double].isAssignableFrom(classOf[java.lang.Double])
new java.lang.Double(2)
new java.lang.Double(2).asInstanceOf[scala.Double]
classOf[scala.Double].cast(new java.lang.Double(2))
classOf[Double].isInstance(2)
classOf[Double].isInstance(new java.lang.Double(2))
classOf[Unit]
class X(val x: Int) extends AnyVal
classOf[X]
classOf[java.lang.Double].isAssignableFrom(classOf[java.lang.Double])
cm.reflect(null)
class C { def foo = 2 }
cm.reflect(null).reflectMethod(typeOf[C].declarations.head)
cm.reflect(null).reflectMethod(typeOf[C].declarations.head.asMethod)
class C { def foo = 2 }
cm.asInstanceOf[{ def methodToJava(sym: Any): java.lang.reflect.Method }]
class C { def foo = 2 }
val foo = typeOf[C].declarations.head.asMethod
val foo = typeOf[C].declarations.toList.apply(1).asMethod
class C { def foo = 2 }
val foo = typeOf[C].declarations.toList.apply(1).asMethod
val cmx = cm.asInstanceOf[{ def methodToJava(sym: Any): java.lang.reflect.Method }]
cmx.methodToJava(foo)
val cmx = cm.asInstanceOf[{ def methodToJava(sym: scala.reflect.internal.Symbols#MethodSymbol): java.lang.reflect.Method }]
cmx.methodToJava(foo)
cmx.methodToJava(foo.asInstanceOf[scala.reflect.internal.Symbols#MethodSymbol])
val cmx = cm.asInstanceOf[{ def methodToJava(sym: scala.reflect.api.Symbols#MethodSymbol): java.lang.reflect.Method }]
class C { def foo = 2 }
val foo = typeOf[C].declarations.toList.apply(1).asMethod
val cmx = cm.asInstanceOf[{ def methodToJava(sym: scala.reflect.internal.Symbols#MethodSymbol): java.lang.reflect.Method }]
cmx.methodToJava(foo.asInstanceOf[scala.reflect.internal.Symbols#MethodSymbol])
trait C { def foo: Int; def bar = 2 }
typeOf[C].declarations.toList.apply(1)
typeOf[C].declarations.toList.apply(2)
def isDeferred(sym: Symbol) = sym.asInstanceOf[scala.reflect.internal.Symbols#Symbol].hasFlag(scala.reflect.internal.Flags.DEFERRED)
isDeferred(res0)
isDeferred(res1)
class C
type T = C
new T
List[T]()
val q = FINAL
q"$q val x = 2"
().pickle
import scala.pickling._
().pickle
import json._
().pickle
res2.unpickle
res2.unpickle[Unit]
res2.unpickle
exit
import scala.pickling._
import json._
"x".pickle.unpickle
"x".pickle.unpickle[String]
12.pickle.unpickle[String]
12.pickle.unpickle[Int]
List(12).pickle.unpickle[List[Int]]
exit
import scala.pickling._
import json._
List(12).pickle.unpickle[List[Int]]
Array(12).pickle.unpickle[Array[Int]]
List(12).pickle
Array(12).pickle
import scala.pickling._
import json._
Array(12).pickle
import scala.pickling._; import json._
case class C1(x: Array[Int])
C(Array(1)).pickle
C1(Array(1)).pickle
res1.unpickle[C1]
import scala.pickling._
import json._
class C(x: Int)
new C(2).pickle
class C(val x: Int)
new C(2).pickle
res1.unpickle[C]
exit
java.io.File.pathSeparatorChar
trait Foo extends scala.reflect.macros.Macro { def foo(x: c.Tree) = x }
def foo = macro Foo.foo
import scala.language.experimental.macros
def foo = macro Foo.foo
trait Foo extends scala.reflect.macros.Macro { def foo(x: c.Tree) = x }
def foo = macro Foo.foo
import scala.reflect.macros.Macros
import scala.reflect.macros.Macro
trait Foo extends Macro { def foo(x: c.Tree) = x }
def foo = macro Foo.foo
object Foo { def unapply(x: Int): Boolean = x == 2 }
2 match { case Foo(_) => ??? }
def foo(c: Context)(x: c.Tree) = x
def bar(x: Int) = macro foo
bar(2)
val x = 2
x
y
class C { lazy val x = 2 }
class D extends C { override lazy val x = 3 }
new D().x
def foo(c: Context)(x: c.Tree) = x
def bar(x: Int) = macro foo
bar(2)
def foo(c: Context)(x: c.Tree) = x
def bar(x: Int) = macro foo
bar(2)
exit
def makeList_impl(c: Context)(clazz: c.Expr[Class[_]]): c.Expr[Any] = {
import c.universe._
val TypeRef(_, _, arg :: Nil) = clazz.tpe
q"List[$arg]()"
}
def makeList_impl(c: Context)(clazz: c.Expr[Class[_]]): c.Expr[Any] = {
import c.universe._
val TypeRef(_, _, arg :: Nil) = clazz.tree.tpe
c.Expr[Any](q"List[$arg]")
}
def makeList(clazz: Class[_]): Any = macro makeList_impl
makeList(classOf[Int])
def makeList_impl(c: Context)(clazz: c.Expr[Class[_]]): c.Expr[Any] = {
import c.universe._
val ConstantType(Constant(tpe)) = clazz.tree.tpe
c.Expr[Any](q"List[$arg]")
}
def makeList_impl(c: Context)(clazz: c.Expr[Class[_]]): c.Expr[Any] = {
import c.universe._
val ConstantType(Constant(tpe)) = clazz.tree.tpe
c.Expr[Any](q"List[$tpe]")
}
def makeList_impl(c: Context)(clazz: c.Expr[Class[_]]): c.Expr[Any] = {
import c.universe._
val ConstantType(Constant(tpe: Type)) = clazz.tree.tpe
c.Expr[Any](q"List[$tpe]")
}
def makeList(clazz: Class[_]): Any = macro makeList_impl
makeList(classOf[Int])
def makeList_impl(c: Context)(clazz: c.Expr[Class[_]]): c.Expr[Any] = {
import c.universe._
val ConstantType(Constant(tpe: Type)) = clazz.tree.tpe
c.Expr[Any](q"List[$tpe]()")
}
def makeList(clazz: Class[_]): Any = macro makeList_impl
makeList(classOf[Int])
makeList(classOf[String])
1
exit
context(option) { 2 }
import workflow._
context(option) { 2 }
def foo(x: Int) = x
context { f(2) }
context { foo(2) }
context(option) { foo(2) }
context(option) { $(foo(2)) }
context(option) { $(foo(Some(2))) }
def foo(x: Int, y: Int, z: Int) = x
context(option) { $(foo(Some(2), Some(3), Some(4))) }
{ def impl(c: Context) = c.literalUnit; def foo = macro impl; foo }
Ident(newTermName("foo"))
res0.symbol
object Macros { def impl(c: Context) = c.literalUnit }; def foo = macro impl; foo
object Macros { def impl(c: Context) = c.literalUnit }; def foo = macro Macros.impl; foo
object Macros { def impl(c: Context) = c.literalUnit }; def foo = macro impl; foo
object Macros { def impl(c: Context) = c.literalUnit }; def foo = macro Macros.impl; foo
object Macros { def impl(c: scala.reflect.macros.Context) = c.literalUnit }; def foo = macro Macros.impl; foo
object Macros { def impl(c: scala.reflect.macros.Context): c.Expr[Unit] = c.literalUnit }; def foo = macro Macros.impl; foo
object Macros { def impl(c: scala.reflect.macros.Context): c.Expr[Unit] = c.reify(println("hello!") }; def foo = macro Macros.impl; foo
object Macros { def impl(c: scala.reflect.macros.Context): c.Expr[Unit] = c.reify(println("hello!")) }; def foo = macro Macros.impl; foo
object Macros { def impl(c: scala.reflect.macros.Context): c.Expr[Unit] = c.universe.reify(println("hello!")) }; def foo = macro Macros.impl; foo
import scala.pickling._
import binary._
List(1, 2, 3).pickle
res0.unpickle
 reflect.runtime.universe.typeOf[java.util.Calendar].declaration(newTermName("getZone")).asMethod
 reflect.runtime.universe.typeOf[java.util.Calendar].declaration(TermName("getZone")).asMethod
res0.isPublic
res0.privateWithin
case class C(x: Int, y: Int)
typeOf[C].declarations
typeOf[C].declarations.collect { case x: TermSymbol => x }
typeOf[C].declarations.collect { case x: MethodSymbol if x.isGetter => x }
typeOf[C].declarations.collect(case x: MethodSymbol if x.isGetter => x)
val c = C(1, 2)
val m = currentMirror.reflect(c)
cm
val m = cm.reflect(c)
m.reflectMethod(res2.toList.apply(0))
res4
res4()
List(1, 2).foldLeft
List(1, 2).fold
List(1, 2).fold(1)(_ + _)
import scala.pickling._
import json._
2.pickle
exit
Some(2).toList
None.toList
def foo(implicit x: Int) = x
foo
trait Reads[T]
def foo[T](implicit x: Reads[T]) = x
foo
foo[Int]
q""
q"trait ${"foo"}"
q"""trait ${"foo"}"""
q"""trait ${"foo"} {}"""
tb.eval(tb.parse("trait T{def m = 0}; classOf[T]"))
tb.eval(tb.parse("trait T{def m = 0}; typeOf[T]"))
tb.eval(tb.parse("trait T{def m = 0}; scala.reflect.runtime.universe.typeOf[T]"))
tb.eval(tb.parse("trait T{def m = 0}; scala.reflect.runtime.universe.weakTypeOf[T]"))
inspect version
type Id[T] = T
reify { List[Id[Int]]() }
typeOf[Exception].typeSymbol.asClass.baseClasses
def foo(x: Int => Int) = x
foo{ val c = 2; x => c }
exit
"foo".T
"foo".type
type x = "foo".type
type T = { type U }
def foo: T = ???
foo.U
def foo: { type U } = ???
foo.A
foo.U
type q = foo.U
def foo(s: Singleton) = s
case class Foo
case class Foo()
foo(Foo)
foo(new Foo)
val x = Foo
foo(x)
val y: x.type = y
val y: x.type = x
foo(y)
val z = "zzz"
val q: z.type = z
foo(q)
class C
new C().foo
val x = 1 +
val x = 1 + _
class C { def +(c: C) = this }
val x = new C +
val x = new C() +
val x = new C() + _
213.getClass
def foo[M[_]: List]
= ???
def foo[M[_]] = ???
OptionType
OptionClass
OptionClass.toType
exit
{ def foo[T](x: Int) = x
val x = foo[Int]
x }
exit
case class Foo(x: Int); object Foo { def unapply(foo: Foo): Boolean = true }
abstract class C
class Foo(implicit x: Int)
"".isEmpty
List("x", "").flatMap(Predef.identity)
List("x", "").filter(_.nonEmpty)
List("x", "").filter(_.nonEmpty).mkString(" or ")
List("x", "y").filter(_.nonEmpty).mkString(" or ")
trait A { type B }
val a = new A{}
typeOf[a.B]
showRaw(res0)
"x" -> 2
exit
q"foo(2)"
q"foo[Int](2)"
val q"$x($y)" = res1
q"foo.bar[Int](2)"
val q"$x($y)" = res2
val q"$x.$y($z)" = res2
1 -> 2
1 ->[Int] 2
typeOf[Nil.type] <:< typeOf[Traversable[_]]
case class C(x: C)
case class C(var x: C)
val c = C(null)
c.x = c
case class C(var x: C) { override def toString = "C" }
val c = C(null)
c.x = c
c.getHashCode
c.getHashcode
c.hashcode
c.hashCode
def createArray[T: ClassTag](size: Int, el: T) = {
val a = new Array[T](size)
for (i <- 0 until size) a(i) = f(i)
}
def createArray[T: ClassTag](size: Int, el: T) = {
val a = new Array[T](size)
for (i <- 0 until size) a(i) = el
}
createArray[Int](10, 1)
def createArray[T: ClassTag](size: Int, el: T) = {
val a = new Array[T](size)
for (i <- 0 until size) a(i) = el
a
}
createArray[Int](10, 1)
def createArray[@specialized T: ClassTag](size: Int, el: T) = ???
val db = { trait Db { case class Coffee(name: String, price: Int, sales: Int); object Coffees { def insert(name: String, price: Int, sales: Int) = ???; def all: List[Coffee] = ??? } }; new Db{} }
db.coffees
val db = { trait Db { case class Coffee(name: String, price: Int, sales: Int); object Coffees { def insert(name: String, price: Int, sales: Int) = ???; def all: List[Coffee] = ??? } }; new Db{} }
db.Coffees
exit
val db = { trait Db { case class Coffee(name: String, price: Int, sales: Int); object Coffees { def insert(name: String, price: Int, sales: Int) = ???; def all: List[Coffee] = ??? } }; new Db{} }
db.Coffees.all
val db = { trait Db { case class Coffee(name: String, price: Int, sales: Int); object Coffees { def insert(name: String, price: Int, sales: Int) = ???; def all: List[Coffee] = List(Coffee("Brazilian", 99, 0)) } }; new Db{} }
db.Coffees.all
def impl(c: Context)(x: c.Tree) = ???
def foo(x: => Int) = macro impl
exit
val db = { trait Db { case class Coffee(name: String, price: Int, sales: Int); object Coffees { def insert(name: String, price: Int, sales: Int) = ???; def all: List[Coffee] = List(Coffee("Brazilian", 99, 0)) } }; new Db{} }
val db = { trait Db { case class Coffee(name: String, price: Int, sales: Int); val Coffees: List[Coffee] = List(Coffee("Brazilian", 99, 0)) }; new Db{} }
import scala.pickling._
import binary._
2.0.pickle
res0.unpickle
res0.unpickle[Double]
exit
val db = { case class Coffee(name: String, price: Int, sales: Int); trait Db { val Coffees: List[Coffee] = List(Coffee("Brazilian", 99, 0)) }; new Db{} }
val db = { trait Db { case class Coffee(name: String, price: Int, sales: Int); val Coffees: List[Coffee] = List(Coffee("Brazilian", 99, 0)) }; new Db{} }
db.Coffees.head
db.Coffees.head.name
typeOf[db.Coffees.head]
typeOf(db.Coffees.head)
val ttt[T: WeakTypeTag](x: T) = weakTypeOf[T]
def ttt[T: WeakTypeTag](x: T) = weakTypeOf[T]
ttt(db.Coffees.head)
def impl(c: Context) = ???
val db = { trait Db { case class Coffee(name: String, price: Int, sales: Int) { def foo = macro impl }; val Coffees: List[Coffee] = List(Coffee("Brazilian", 99, 0)) }; new Db{} }
EmptyTree
EmptyTree.tpe
EmptyTree.tpe <:< typeOf[Int]
EmptyTree.tpe <:< typeOf[Any]
"a".hashCode()
import scala.pickling._
import binary._
Array(1).pickle
exit
typeOf[Array[String]]
import scala.pickling._
import binary._
(Array(1): Any).pickle
case class C(x: Array[Int])
(C(Array(1)): Any).pickle
{ import json._; (C(Array(1)): Any).pickle }
exit
import scala.pickling._; import binary._
case class C(x: Array[Int])
(C(Array(1)): Any).pickle
classOf[Int].getComponentType()
exit
import scala.pickling._; import binary._
case class C(x: Array[Int])
(C(Array(1)): Any).pickle
res0.unpickle[C]
res1.x.toList
exit
def fold[A, B](els: List[A], b: B, f: (B, A) => B): B = ???
fold(List(1, 2, 3), 0.0, _ * _)
{ implicit val foo = 2; { implicit val foo = 3 { implicitly[Int] } } }
{ implicit val foo = 2; { implicit val foo = 3; { implicitly[Int] } } }
typeOf[List[_]].typeSymbol
res0.asClass
res1.typeSignature
res1.toType
val TypeRef(_, _, args) = res3
args.head.typeSymbol
existentialAbstraction(List(ress4), res3)
existentialAbstraction(List(res4), res3)
def impl[T](c: Context) = ???
def foo[T] = macro impl[T]
def foo[T <: Int] = macro impl[T]
def impl[T <: String](c: Context) = ???
def foo[T <: Int] = macro impl[T]
System.getenv("foo")
System.getenv()
System.getenv().keys
System.getenv().getKeys
System.getenv().getKey
System.getenv().keys
exit
System.getenv("PARADISE211_HOME")
import scala.pickling._
import binary._
val x = Array[Double](1)
x.pickle
import scala.pickling._
import json._
Array[Long](1, 2)
res0.pickle
res1.unpickle[Array[Long]]
Array[Float](1, 2)
res3.pickle
res4.unpickle[Array[Float]]
exit
import scala.pickling._
import json._
Array(1, 2).pickle
exit
new ArrayBuilder.ofInt
ArrayBuilder.ofInt
scala.collection.mutable.ArrayBuilder.ofInt
new scala.collection.mutable.ArrayBuilder.ofInt
import scala.pickling._
import binary._
scala.collection.mutable.ArrayBuffer[Int]()
res0 ++= List(1, 2)
res0.pickle
typeOf[List[_]].typeSymbol.asType.toType
import scala.collection.generic.CanBuildFrom
CanBuildFrom[Vector, Int, Vector[Int]]
implicitly[CanBuildFrom[Vector, Int, Vector[Int]]]
implicitly[CanBuildFrom[Vector[_], Int, Vector[Int]]]
implicitly[CanBuildFrom[Vector[_], Int, Vector[Int]]].apply
(1 to 10).toVector
clean
implicitly[CanBuildFrom[Vector[_], Int, Vector[Int]]].apply
import scala.collection.generic.CanBuildFrom
implicitly[CanBuildFrom[scala.collection.mutable.ArrayBuffer[_], Int, scala.collection.mutable.ArrayBuffer[Int]]].apply
List(2).getHa
List(2).getHashCode
List(2).getHashcode
List(2).hashCode
2.hashCode
final class Vertex(val label: String, var neighbors: List[Vertex]) extends Serializable
new Vertex("foo", Nil)
List(res4)
res4.hashCode
res5.hashCode

"xxxx".replace("x", "y")
List(1, 2).distinct
List(1, 2, 2).distinct
val p = Some(1)
for { p <- p } yield p
typeOf[Array[_]]
def <-(x: Int) = x
typeOf[scala.collection.mutable.ArrayBuffer[_]]
res0.typeSymbol.name
def test[B[_]](implicit tt: TypeTag[B[_]]) = typeOf[Function1[B, _]]
class Foo[B[_], T]
def test[B[_]](implicit tt: TypeTag[B[_]]) = typeOf[Foo[B, _]]
showRaw(test[Option])
test
test[Option]
def test?[B[_]](implicit tt: TypeTag[B[_]]) = typeOf[Foo[B, _]]
def test[B[_]](implicit tt: TypeTag[B[_]]) = weakTypeOf[Foo[B, _]]
showRaw(test[Option])
weakTypeTag[Option[_]]
showRaw(res4)
exit
trait T1 { def m = "t1" }
trait T2 { def m = "t2" }
new T1 with T2{}.m
trait T1 { override def m = "t1" }
trait T { def m: String }
trait T1 extends T { override def m = "t1" }
trait T2 extends T { override def m = "t2" }
new T1 with T2{}.m
new T2 with T1{}.m
@scala.reflect.internal.compileTimeOnly("foo") class C
@scala.reflect.internal.annotations.compileTimeOnly("foo") class C
new C
@scala.reflect.internal.annotations.compileTimeOnly("foo") class C extends scala.annotation.StaticAnnotation
@C def foo = 2
new C
object M { @scala.reflect.internal.annotations.compileTimeOnly("foo") class C extends scala.annotation.StaticAnnotation }
@??C def foo = 2
@M.C def foo = 2
class C { object X }
typeOf[C].member(newTermName("X"))
class C { def x(sss: Int) = ??? }
typeOf[C].member(newTermName("x"))
class C { def x(sss: Int) = ???; def x(sss: String) = ??? }
typeOf[C].member(newTermName("x"))
res2.asTerm.asInstanceOf[scala.reflect.internal.Symbols#Symbol].defString
class C { def x(sss: Int) = ??? }
typeOf[C].member(newTermName("x")).asInstanceOf[scala.reflect.internal.Symbols#Symbol].defString
typeOf[C].member(newTermName("x")).asInstanceOf[scala.reflect.internal.Symbols#Symbol].defStringSeenAs(NoType)
typeOf[C].member(newTermName("x"))
typeOf[C].member(newTermName("x")).asInstanceOf[scala.reflect.internal.Symbols#Symbol].infoString(NoType)
:power
Symbol_apply
Symbol_apply.infoString
Symbol_apply.defString
StringAdd_
StringAdd_+
StringAdd_+.defString
StringAdd_+.infoString(NoType)
StringAdd_+.infoString(StringAdd_+.info)
StringAdd_+.defStringSeenAs(StringAdd_+.info)
Symbol_apply.defStringSeenAs(StringAdd_+.info)
Symbol_apply.defStringSeenAs(Symbol_apply.info)
class C(x: Int) extends AnyVal
class C(val x: Int) extends AnyVal
class D { class C(val x: Int) extends AnyVal }
typeOf[kase]
typeOf[kase].typeSymbol
object Foo { def x; }
class X { class kase extends scala.annotation.StaticAnnotation }
class Y(@kase val x: Int) extends X
class Y extends X { @kase val x = 2 }
{ object D extends C.X { class X }; object C extends D.X { class X }; }
class ann extends scala.annotation.StaticAnnotation
{ import D._; object C; object D }
{ import D._; object C { def bar = foo }; object D { def foo = 2 } }
object D { def foo = 2 }
{ import d._; println(foo); val d = D }
{ import d._; println(foo); val d: D.type = D }
{ import d._; println(foo); lazy val d: D.type = D }
{ import d._; val d: D.type = D }
{ val d: D.type = D; import d._ }
{ val d: D.type = D; import d._; println(foo) }
object p { val x = 2 }
{ import p.x; val x = 1; println(x) }
{ val x = 1; { import p.x; println(x) } }
class Testpickling(val name: String, val year: Int)
import scala.pickling._
import binary._
val ff = new Testpickling("Jim", 2005)
ff.pickle
{ def foo(x: Int) = x; foo }
{ def foo(x: Int) = x; (foo _)}
List(1, 2) - 1
List(1, 2) diff List(1)
1 #:: Nil
1 #:: Stream.empty
(1 #:: (???: Stream.empty))
(1 #:: (???: Stream[Int]))
(1 #:: (??? : Stream[Int]))
res4.tail
(1 #:: (??? : Stream[Int]))
(1 #:: (??? : Stream[Int])).flatMap(x => Some(x))
List(1, 2).toStream
res7 match { case hd :: _ => hd }
res7 match { case hd #:: _ => hd }
(1 #:: 2 #:: (??? : Stream[Int])).flatMap(x => Some(x))
res11 match { case hd #:: _ => hd }
res4
res4.head
res4.headOption
exit
Some(1) #:: (??? : Stream[Int])
Some(1) #:: (??? : Stream[Option[Int]])
res1
res1.flatMap(x => x)
None #:: Some(1) #:: (??? : Stream[Option[Int]])
res4.flatMap(x => x)
Nil #:: List(1) #:: (??? : Stream[List[Int]])
res6.flatMap(x => x)
Nil #:: List(1, 2) #:: (??? : Stream[List[Int]])
res8.flatMap(x => x)
Nil #:: Some(List(1, 2)) #:: (??? : Stream[Option[List[Int]]])
None #:: Some(List(1, 2)) #:: (??? : Stream[Option[List[Int]]])
res11.flatMap(x => x)
exit
def foo(x: Int, y: Int) = x + y
val x = foo _
foo.tupled
x.tupled
List(1, 2) zip List(3, 4)
List(1, 2) replace 
val x = List(1, 2)
for { y <- x; z = y } yield z
exit
@kase class C(x: Int)
type Foo = List[T] forSome { type T <: Int }
class ann extends scala.annotation.StaticAnnotation
type Foo = List[T] forSome { @nn type T <: Int }
type Foo = List[T] forSome { @ann type T <: Int }
@ann def x = 2
@ann type T = Int
class C
type Qwe = C { def x: Int }
type Qwe = C { @ann def x: Int }
class C { @ann def x: Int }
abstract class C { @ann def x: Int }
for (x <- 1 to 10) { yield i }
for {x <- 1 to 10} yield i
for {x <- 1 to 10} yield x
for {x <- 1 to 10} x
List(2, 3).zipWithIndex
implicit case class Foo(x: Int)
case class Foo(x: => Int)
@kase class C(x: Int)
class C extends Serializable with Serializable
trait T
class C extends T with T
def foo = macro ???
foo
@kase object C
@kase class C(x: Int)
@doubler class C
@doubler object C
@plusOne class C
2
typeOf[Any*]
for { val <- List(1, 2) } { case 1 => 3 }
for(v <- List(1, 2)) { case 1 => 3 }
for(v <- List(1, 2)) { case x => 3 }
exit
val q"$x" = "x"
q"foo"
q"fo["
q"vax x = 1"
q"class class"
System.getenv()
System.getenv("SCALA_HOME")
exit
cq"case x => x"
cq"x => x"
cq"x if x => x"
pq"xs @ (hd :: tl)"
val q"""new $tpe[..$tparams](...$vparamss) { ..$body }""" = q"new Foo {}"
q"class C[..$tparams]" = q"class C"
val q"class C[..$tparams]" = q"class C"
val q"""new $tpe[..$tparams](...$vparamss) { ..$body }""" = q"new Foo {}"
val q"""new $tpe[..$tparams] {}""" = q"new Foo {}"
q"""new C[T] {}"""
reify{ val x = 5; reify(x).splice }
val x = 5; reify{ reify(x).splice }
System.getProperty("user.dir")
import java.net.URL;
import java.net.URLClassLoader
val url = new URL("file:/Users/xeno_by/Projects/6240/build/pack/lib/scala-library.jar")
url.loadClass("scala.Function0")
val cl = new URLClassLoader(Array(url))
cl.loadClass("scala.Function0")
reify(2)
java.io.File.separator
Set(1).exists(_ == 1)
java.io.File.separator
val trees = List(q"call.f", "call.g")
q"..$trees"
val trees = List[Tree](q"call.f", "call.g")
val trees = List[Tree](q"call.f", q"call.g")
q"..$trees"
typeOf[scala.reflect.api.Exprs].declaration(newTypeName("Expr"))
res0.typeSignature.declaration("splice")
res0.typeSignature.declaration(newTermName("splice"))
res2.annotations
val x = "name"
q"$x.y"
showRaw(res0)
q"$x[y]"
tq "$x.y"
tq"$x.y"
cq"1 => 2"
throw new Exception
exit
new Exception
throw res0
throw new Exception
exit
throw new Exception
exit
trait TC2[T, U]
trait S
val x: ({ type L[X] = TC2[S, X] })#L = ???
type Y = ({ type L[X] = TC2[S, X] })#L
trait TC[X[_]]
type T = TC[({ type L[X] = TC2[S, X] })#L]
reify { type T = TC[({ type L[X] = TC2[S, X] })#L] }
throw new Exception()
throw new Exception
reify { val x = 2; reify(x).splice }
throw new Exception
(typeOf[String].normalize.##, typeOf[java.lang.String].normalize.##)
exit
(typeOf[String].normalize.##, typeOf[java.lang.String].normalize.##)
import scala.reflect.runtime.universe._
(typeOf[String].normalize.##, typeOf[java.lang.String].normalize.##)
class C { lazy val x = x }
class C { lazy val x: Int = x }
new C().x
typeOf[scala.tools.nsc.typechecker.Typers#Typers]
typeOf[scala.tools.nsc.typechecker.Typers#Typer]
res1.members
res1.members.filter(_.name.toString.startsWith("typed")).foreach(println)
exit
trait Foo { def foo }
trait Foo2 @foo { def foo }
System.getProperty("foo")
System.getProperty("foo1")
def foo(x: Int => Int) = x
def bar(x: Int) = x
foo(bar(_))
foo(foo(_ + 2))
foo((_))
foo(_)
foo({_})
case class Foo() { val w = Witness({b:Boolean => !b}) }
exit
import Witness._
case class Foo() { val w = Witness({b:Boolean => !b}) }
import Witness._
case class Foo() { val w = Witness({b:Boolean => !b}) }
class foo[T] extends scala.annotation.StaticAnnotation
@foo[Int] def x = 2
Witness({b:Boolean => !b})
val x = Apply(Select(EmptyTree, nme.CONSTRUCTOR), List(EmptyTree))
val q"${_}.${nme.CONSTRUCTOR}($instance)" = x
class C { var x = 2 }
val qq = new C().asInstanceOf[{ var x: Int }]
qq.x 
qq.x = 3
qq.x
q"import scala.language.experimental.macros"
showRaw(res0)
type F = Int => Int
val x: F = { case x => x }
{ val x = 2; { val x = 3; x } }
val x = { case x => x }
def foo(x: Int => Int) = x
foo({ case x => x })
foo{ case x => x }
???
11:29 ~$ parse 'val x: Int => Int = ???'
[[syntax trees at end of parser]]// Scala source: tmp7pDKqZ
package <empty> {
  class wrapper extends scala.AnyRef {
    def <init>() = {
      super.<init>();
      ()
    };
    val x: _root_.scala.Function1[Int, Int] = $qmark$qmark$qmark
  }
type T = Function2[Int, Int, Int]
val f: T = { case (x, y) => ??? }
type U = (String, Int)
val x: U = ???
def x: U = ???
type T = Tuple1[Int]
case class C(x: Int)
C(2)
List(1, 2)
Array(1, 2)
Array(1, 2).toString
C(2)
new C(2)
C.apply(2)
val foo = 2
foo(2)
class C(val x: Int)
new C(2) match { case C(x) => x }
class C(val x: Int)
new C(2) match { case C(x) => x }
def foo[T] = ()
foo[Int]
foo[Int]()
def foo[T]() = ()
foo[Int]()
foo[Int]
foo
foo[Nothing]
type T = AnyRef[String]
2.isInstanceOf
"2".isInstanceOf
null.isInstanceOf
null
null.isInstanceOf[AnyRef]
null.isInstanceOf[Null]
null.isInstanceOf[Nothing]
null.isInstanceOf
"x".isInstanceOf[Nothing]
().isInstanceOf[Unit]
2.isInstanceOf[Unit]
"some".isInstanceOf[Unit]
null.isInstanceOf[Unit]
val x: Unit = 1
"some".asInstanceOf[Unit]
1.asInstanceOf[Unit]
1: Unit
1.asInstanceOf[Int]
1: Int
1: String
 "some": Unit
Some(1)
Some(1).x
class Foo[A]
class Bar extends Foo[Nothing]
val x: Foo[_] = Bar
object Bar extends Foo[Nothing]
class Foo[A]
object Bar extends Foo[Nothing]
val x: Foo[Int] = Bar
val x: Foo[_ <: Int] = Bar
class Foo[+A]
object Bar extends Foo[Nothing]
val x: Foo[_ <: Int] = Bar
val x: Foo[Int] = Bar
class Foo[-A]
object Bar extends Foo[Any]
val x: Foo[Int] = Bar
val f: Int => Int = (x: Nothing) => 1
val f: Int => Int = (x: Int) = ???
val f: Int => Int = (x: Int) => ???
val f: Int => Int = (x: Any) => 0
type A = Int => Int
type B = Any => Int
type C = Int => Nothing
implicitly[A <:< B]
implicitly[B <:< A]
implicitly[C <:< A]
type D = Any => Nothing
implicitly[D <:< A]
res3((x: Any) => ???)
res3(??? : D)
var x : Nothing = _
var x: Nothing = _
var x: Any = _
var x: AnyRef = _
var x: Int = _
var x: Unit = _
class Reference[T] {
  private var x: T = _
  def get: T = x
}
val r = new Reference[Nothing]
r.get
class Reference[T] {
  private var x: T = _
  def get: T = x
}
val r = new Reference[Nothing]
println(r.get)
throw null
"some".isInstanceOf[Object]
implicitly[Object <:< AnyRef]
class C
type D = C
implicitly[C <:< D]
implicitly[D <:< C]
implicitly[Null <:< Object]
implicitly[Object <:< Any]
::(1, 2)
 ::(1, 2)
 ::(1, Nil)
class C(x: Int, y: Int)
2 C 3
2 :: Nil
object ## { def apply(x: Int, y: Int) = x }
object !! { def apply(x: Int, y: Int) = x }
2 !! 3
def foo: List[_] = ???
class C { def foo: List[_] = ??? }
class D extends C { override def foo: List[Int] = ??? }
class E extends D { override def foo: List[_] = ??? }
val A = new { A => def copy(a : A.type) = a }
def o[T] = new { def foo(arg : T) = arg }
def f1[T](x: T) = new { def bar[U](x: U) = x }
@workflow(option) val x = 3
@workflow[Option] val x = 3
@workflow(option) val x = 3
@workflow[Option] val x = 3
val foo = 1
q"$#foo"
typeOf[System]
typeOf[System].typeSymbol.asClass.companionSymbol
typeOf[System].typeSymbol.asClass.companionSymbol.declarations
typeOf[System].typeSymbol.asClass.companionSymbol.asClass.declarations
typeOf[System].typeSymbol.asClass.companionSymbol.typeSignature.declarations
typeOf[System].typeSymbol.companionSymbol.typeSignature.declarations
q"foo $x"
val x = 1
q"foo ..$x"
import scala.reflect.runtime.universe._
val q"class $name extends ..$parents" = q"class Foo extends Bar with Blah"
import spire.syntax.literals._
b"101"
s"""\n"""
s"\n"
s"\0"
s"""\0"""
s"""\ux"""
s"""\."""
raw"""\."""
raw"""\n"""
raw"""\ux"""
raw"""\""""
raw"x\""
raw"x\"y"
class Foo(x: Int) { def bar = (y: Int) => this.x = y; override def toString = x.toString }
class Foo(private[this] var x: Int) { def bar = (y: Int) => this.x = y; override def toString = x.toString }
new Foo(2)
res0.x = 3
class Foo(private[this] var x: Int) { def bar = (y: Int) => this.x = y; override def toString = x.toString }
val foo = new Foo(2)
class Foo(private[this] var z: Int) { def bar = (y: Int) => this.z = y; override def toString = z.toString }
val foo = new Foo(2)
foo.z = 3
foo.bar(3)
foo
trait Foo
class C
class D extends C
type T = Foo { type T <: C }
val x: T = ??? : Foo { type T <: D }
def x: T = ??? : Foo { type T <: D }
class C 
class D extends C
class E extends D
typeOf[E].baseClasses
typeOf[E].parents
typeOf[E].asInstanceOf[scala.reflect.internal.Types#Type].parents
Int Map Int
type T = Int Map Int
type T = Int Map Int]
:power
typeOf[scala.`package`.type]
typeOf[scala.`package`.type].moduleClass
typeOf[scala.`package`.type].typeSymbol.moduleClass
typeOf[scala.`package`.type].termSymbol.moduleClass
res3.flags
def foo = { class X; new X }
def foo = { object X; X }
def foo = { object X { def x = 2 }; X }
def foo = { class X; (x: X) => x }
System.getProperty("os.name")
def foo = { object O { class C }; new O.C }
:power
ErrorType
ErrorType <:< IntTpe
:power
NoSymbol.tpe
IntTpe <:< NoSymbol.tpe
NoSymbol.tpe <:< IntTpe
class C
class D extends C
typeOf[D].baseClasses
class X extends scala.reflect.macros.Macro
abstract class X extends scala.reflect.macros.Macro
typeOf[X].baseClasses
trait Y extends scala.reflect.macros.Macro
abstract class X extends Y
typeOf[X].baseClasses
trait Foo extends Macro { def impl = c.literalUnit }
trait Foo extends scala.reflect.macros.Macro { def impl = c.literalUnit }
def foo = macro Foo.impl
trait Foo extends scala.reflect.macros.Macro { def impl = c.literalUnit }
def foo = macro Foo.impl
class C[T]
class D extends C[_]
class D[T] extends C[?]
class D[T] extends C[T]
import scala.reflect.macros.Macro
trait Foo extends Macro { def impl = c.literalUnit }
def foo = macro Foo.impl
Some(1, 2).lastOption
val option = Some(100500)
option.lastOption
val x: Set[_] = Set(2)
val Seq(x, y) = Set(1, 2)
:power
nme.expandedName(TermName("foo"), MacroContextClass)
:power
EmptyPackage.fullName
EmptyPackage.name
EmptyPackage.fullName('$')
@throws[Exception] def foo: T = ...
@throws[Exception] def foo: T = ???
@throws[Exception] def foo[T]: T = ???
@throws[T] def foo[T]: T = ???
typeOf[List[Int]].typeSymbol.typeSignature
typeOf[List[Int]].typeSymbol.asType.toType
trait Bitness[D, B]
trait Bits32
trait Bits64
trait Bits16
implicit val bitnessShort = new Bitness[Short, Bits16]
implicit val bitnessShort = new Bitness[Short, Bits16] {}
implicit val bitnessInt = new Bitness[Short, Bits32] {}
implicit val bitnessLong = new Bitness[Short, Bits64] {}
def double(x: Int) = 2 * x
def ntimes(f: Int => Int, v: Int): Int = 
def double(x: Int) = 2 * x
def ntimes(f: Int => Int, n: Int, x: Int): Int = 
if (n == 0) x
def ntimes(f: Int => Int, n: Int, x: Int): Int = 
if (n == 0) x else f(ntimes(f, n - 1, x))
ntimes(double, 0, 1)
ntimes(double, 1, 1)
ntimes(double, 2, 1)
def foo() = x
{ def unpickle5() = ???; unpickle5 }
{ def unpickle5() = ???; unpickle5 _ }
typeOf[Int] weak_<:< typeOf[Long]
trait Foo { object X }
trait Bar extends Foo { override object X }
q"yield 1"
class C(x: Int)
type Foo = C
new Foo(2)
def foo: Int
def foo(x: Int) = x
foo 2
2 foo
reify(reify(2))
reify(reify(reify(2)))
reify(reify(reify(reify(2))))
typeOf[{ def x: Int; def y: Int }] <:< typeOf[{ def x: Int }]
typeOf[{ class C { def x: Int = 2 } }]
typeOf[{ type C { def x: Int = 2 } }]
typeOf[{ type C <: { def x: Int = 2 } }]
typeOf[{ type C <: { def x: Int } }]
{ object M { class C { def x = 2 } }; M }
def tpeof[T: TypeTag](x: T) = typeOf[T]
{ object M { class C { def x = 2; def y = 3 } }; M }
tpeof(res4) <:< tpeof(res3)
type T = AnyRef{type C <: AnyRef{def x: Int}}
type U = AnyRef{type C <: AnyRef{def x: Int; def y: Int}}
def foo(x: T) = x
foo(null: U)
class foo[T] extends annotation.StaticAnnotation
@foo[T] def bar[T] = ???
{ class C[T] { def x: T = ??? }; new C[Int] }
def foo[A >: B, B](x: A): B = ???
class C
class D extends C
foo[C, D](null: C)
val foo = new { def unapply(x: Int) = Some(x) }
2 match { case foo(x) => x }
trait Foo[T]
class C
class D
implicit object CFoo extends Foo[C]
implicit object DFoo extends Foo[D]
def foo[T: Foo](xs: List[T]) = ...
def foo[T: Foo](xs: List[T]) = ???
foo(List(C, D))
foo(List(new C, new D))
def impl(c: Context) = c.literalUnit
class C { def foo: Long = ??? }
class D { def foo: Int = ??? }
List(new C, new D)
class D { def foo: Long = ??? }
List(new C, new D)
lub(typeOf[C], typeOf[D])
lub(List(typeOf[C], typeOf[D]))
trait Foo
class C extends Foo { def foo: Long = ??? }
class D extends Foo { def foo: Long = ??? }
lub(List(typeOf[C], typeOf[D]))
lub(List(typeOf[Foo { def foo: Int }], typeOf[Foo { def foo: Int }]))
lub(List(typeOf[Foo { def foo: Int }], typeOf[Foo { def foo: Long }]))
class X { def foo = macro impl }
lub(List(typeOf[Foo { def foo: Int }], typeOf[D]))
lub(List(typeOf[Foo { def foo: Long }], typeOf[D]))
lub(List(typeOf[Foo { def foo: Unit }], typeOf[X]))
class X extends Foo { def foo: Unit = macro impl }
lub(List(typeOf[Foo { def foo: Unit }], typeOf[X]))
def impl(c: Context) = c.literalUnit
class X { def foo: Unit = macro impl }
lub(List(typeOf[AnyRef { def foo: Unit }], typeOf[X]))
class Y { def foo: Int = ??? }
lub(List(typeOf[AnyRef { def foo: Unit }], typeOf[Y]))
def impl(c: Context) = c.literalUnit
class X { def foo: Unit = macro impl }
lub(List(typeOf[AnyRef { def foo: Unit }], typeOf[X]))
class C { def foo: Unit = ??? }
class D extends C { override def foo = macro impl }
:power
typeOf[D].typeSymbol.classBound
class E extends C { override def foo: Unit = ??? }
typeOf[E].typeSymbol.classBound
class D extends C { override def foo: Unit = macro impl }
typeOf[D].typeSymbol.classBound
class D extends C { def x = 2 }
typeOf[D].typeSymbol.classBound
glb
glb(List(typeOf[AnyRef { def x: Int }], typeOf[AnyRef { def y: Int }]))
glb(List(typeOf[AnyRef { def x: Int }], typeOf[AnyRef { def x: Int }]))
glb(List(typeOf[AnyRef { def x: Int }], typeOf[AnyRef { def x: Long }]))
X
new X
glb(List(typeOf[AnyRef { def foo: Unit }], typeOf[X]))
class X { def foo: Unit = ??? }
glb(List(typeOf[AnyRef { def foo: Unit }], typeOf[X]))
lub(List(typeOf[AnyRef { def foo: Unit }], typeOf[X]))
def impl(c: Context) = c.literalUnit
:power
class X { def foo: Unit = macro impl }
glb(List(typeOf[X], typeOf[AnyRef { def foo: Unit }]))
typeOf[X] <:< typeOf[AnyRef { def foo: Unit }]
class C private (x: Int) {}; object C { def apply(x: Int) = new C(x) }
new C(2)
C(2)
class C(x: Int) { def this(x: Int, y: Int) = this(x + y) }
class C(x: Int) { def this(x: Int, y: AnyRef = null) = this(x) }
new C(2)
class C private (x: Int) { def this(x: Int, dummy: AnyRef = null) = this(x) }; object C { def apply(x: Int) = new C(x) }
new C(2)
C(2)
class C(x: Int) { def this(x: Int, y: Int) = this(x + y) }
class D extends C(1, 2)
val xs = List(q"x1", q"x2")
q"..$xs"
q"CREATE TABLE t"my_table_name" (
    c"empno" NUMBER(5) PRIMARY KEY,
    c"empno2" NUMBER(5) PRIMARY KEY,
    PRIMARY KEY(pk"empno", pk"empno2")
  )
q"""CREATE TABLE t"my_table_name" (
    c"empno" NUMBER(5) PRIMARY KEY,
    c"empno2" NUMBER(5) PRIMARY KEY,
    PRIMARY KEY(pk"empno", pk"empno2")
  )"""
class X { def foo: Int = ??? }
class Y { def foo: Long = ??? }
glb(List(typeOf[X], typeOf[Y]))
glb(List(typeOf[AnyRef { def foo: Int }], typeOf[AnyRef { def foo: Long }]))
def foo = typeOf[AnyRef { def foo: Int }]
val x1 = foo
val x2 = foo
x1 eq x2
x1 == x2
x1 =:= x2
object X { def xProvider = new { apply(x: Int) = x } }
object X { def xProvider = new { def apply(x: Int) = x } }
X.xProvider(1)
def impl(c: Context) = q"new { def apply(x: Int) = x }"
def foo = macro impl
def impl(c: Context) = { import c.universe._; q"new { def apply(x: Int) = x }" Ъ
def impl(c: Context) = { import c.universe._; q"new { def apply(x: Int) = x }"
def impl(c: Context) = { import c.universe._; q"new { def apply(x: Int) = x }" }
def foo = macro impl
foo(2)
def impl(c: Context) = { import c.universe._; q"new { def apply(x: Int) = x }" }
def foo = macro impl
foo(2)
def impl(c: Context) = { import c.universe._; q"new { def apply(x: Int) = x }" }
def foo = macro impl
foo
res0(2)
def impl(c: Context) = { import c.universe._; q"class C { def apply(x: Int) = x }; new C {}" }
def foo = macro impl
foo
foo(2)
class C { def foo(x: Int) = x; def foo = 1 }
new C().foo
new C().foo(1)
class C { def foo(x: Int) = x; def foo = new { def apply(x: Int) = x } }
new C().foo(1)
val x = q"""foo; bar"""
x.getClass
q"val x = 2"
q"$res0"
List(q"val x = 2")
q"..res2"
q"..$res2"
{ class C { def x: B = ??? }; class B extends C }
{ class C { class X extends B }; class B extends C }
{ class C { class X extends C }; class B extends C }
case class C private(x: Int)
C(2)
new C(2)
typeOf[Int]
import scala.reflect.runtime.universe
universe.typeOf[Int]
val l1 = List(q"foo")
val l2 = List(q"bar")
q"f(..${l1 ++ l2})"
val l3 = q"baz"
q"f(..${l1 ++ l2}, $l3)"
def h2db[I, O <: I](url: String)(i: I): O
= ???
val xs = List(1, 2)
xs.map(_ + 6)
val xs = List(q"x", q"y")
q"..$xs"
q"f(..$xs)"
class Box[X](val x: X) extends AnyVal {
def map[Y](f: X => Y): Box[Y] =
((bx: Box[X]) => new Box(f(bx.x)))(this)
}
def c: Context = ???
typeOf[c.universe.Tree]
def c: scala.reflect.runtime.Context = ???
def c: scala.reflect.runtime.contexts.Context = ???
def c: scala.macros.runtime.Context = ???
def c: scala.macro.runtime.Context = ???
def c: scala.reflect.macros.Context = ???
def c: scala.reflect.macros.contexts.Context = ???
typeOf[c.universe.Tree]
lazy val c: Context = ???
typeOf[c.universe.Tree]
showRaw(res2)
{ lazy val c: Context = ???; showRaw(typeOf[c.universe.Tree]) }
lazy val c: Context = ???
:power
:type c
:type -v c
:type -v c.Expr[Int]
:type -v (??? : c.Expr[Int])
@demomacroannotation val i = 10
import scala.reflect.macros.Context
import scala.language.experimental.macros
import scala.annotation.StaticAnnotation
def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }
class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro impl }
@foo class X
def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro impl }
@foo class X
consoel
console
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
<
2<3
val q"case class C(...$vparamss)" = q"case class C(x: Int = 42)"
trait Fooable[T]
implicit val intIsFooable = new Fooable[Int] { override def toString = "Int" }
implicit def listIsFooable[T: Fooable]: Fooable[List[T]] = new Fooable[List[T]] { override def toString = "list of " + implicitly[Fooable[T]].toString }
implicitly[Fooable[Int]]
implicitly[Fooable[List[Int]]]
implicitly[Fooable[List[String]]]
???
def impl(c: Context)(x: c.Expr[Int]) = { println(x.tree.tpe); ??? }
def foo(x: Int) = macro impl
foo(2)
build.SyntacticClassDef
build.SyntacticClassDef.unapply(q"class C(x: Int)")
trait Cake { trait Liftable[T]; object Liftable { implicit def intLiftable = new Liftable[Int] {}; }; }
val cake = new Cake
val cake = new Cake {}
implicitly[cake.Liftable[Int]]

q""
val x = Nil
q"1; ..$x; 1"
class C(x: Int)(y: Int)
object D
val mc = typeOf[D.type].typeSymbol
mc.isModuleClass
mc.isFinal
def foo[T <: Singleton] = 1
class C
object C
classC; object C
class C; object C
foo[C]
foo[C.type]
val x = 1
foo[x.type]
val x = "1"
foo[x.type]
scala.misc.Unsafe
sun.misc.Unsafe
sun.misc.Unsafe.instance
sun.misc.Unsafe.getUnsafe
val ann = q"new ann"
q"@$ann val x = 2"
val ann2 = q"@ann"
val ann3 = tq"ann"
q"@$ann3 val x = 2"
val ann3 = List(tq"ann")
q"@..$ann3 val x = 2"
class MPair[A, B](val left: A, val right: B)
val tpe = typeOf[
val tpe = typeOf[MPir[Int, String]]
val tpe = typeOf[MqPir[Int, String]]
val tpe = typeOf[MPair[Int, String]]
tpe.declarations.collect{ case meth: MethodSymbol if meth.isParamAccessor => meth }
tpe.declarations.collect{ case meth: MethodSymbol if meth.isParamAccessor => meth }.toList(0)
val sym = tpe.declarations.collect{ case meth: MethodSymbol if meth.isParamAccessor => meth }.toList(0)
sym.info
sym.infoIn(tpe)
val tpe = typeOf[MPair[Int, String]]
val sym = tpe.declarations.collect{ case meth: MethodSymbol if meth.isParamAccessor => meth }.toList(0)
sym.info
sym.infoIn(tpe)
tpe.declarations
class MPair[A, B](val left: A, val right: B)
val tpe = typeOf[MPair[Int, String]].typeSymbol.asType.toType
showRaw(tpe)
val sym = typeOf[MPair[Int, String]].typeSymbol.asClass
sym.typeParams
sym.typeParams(0).asType.toType
sym.typeParams(0).asType.toType.erasure
class Foo[T: TypeTag](x: Int)
typeOf[Foo].declarations
typeOf[Foo[_]].declarations
classOf[Foo[_]].getMethods
classOf[Foo[_]].getDeclaedMethods
classOf[Foo[_]].getDeclaredMethods
typeOf[Int].baseClasses
implicitly[CanBuildFrom[List[_], _, List[_]]]
implicitly[scala.collection.generic.CanBuildFrom[List[_], _, List[_]]]
exit
List(1, 2).max
1 to 5
"1" * 10
"1".substring(1)
typeOf[List[Int]].erasure
import scala.pickling._
import json._
List(1, 2).pickle
val cons = classOf[scala.collection.immutable.::[_]]
cons.getDeclaredFields
cons.getDeclaredMethods
val x = Map(1 -> 2)
x(null)
val x = Map("1" -> 2)
x(null)
System.getEnv.toMap
System.getenv.toMap
System.getenv
System.getenv.toList
System.getenv.asScalaMap
WrapAsScala.asScalaMap(System.getenv)
scala.collection.convert.WrapAsScala.asScalaMap(System.getenv)
scala.collection.convert.WrapAsScala.mapAsScalaMap(System.getenv)
System.getEnv.getKeys
System.getenv.getKeys
System.getenv.keys
System.getenv.keySet
System.getProperties
System.getProperties.keys
System.getProperties.keys.toList
scala.collection.convert.WrapAsScala.enumerationAsScalaIterator(System.getProperties.keys)
scala.collection.convert.WrapAsScala.enumerationAsScalaIterator(System.getProperties.keys).toList
scala.collection.convert.WrapAsScala.enumerationAsScalaIterator(System.getProperties.keys).toList foreach println
typeOf[Object].toString
object C
typeOf[C.type].toString
classOf[Int] match { case classOf[Int] => 1 }
"""(.*?)\[(.*?)\]""".r
res0.match
res0.matches
res0.findAllIn("C[Int]")
res0.findAllIn("C[Int]").toList
res0.findFirstIn("C[Int]")
"""(.*?)\[(.*?)\]""".r
val tper """(.*?)(\[(.*?)\])?""".r
val tper = """(.*?)(\[(.*?)\])?""".r
tper.unapplySeq("C[Int]")
tper.unapplySeq("C")
tper.unapplySeq("")
tper.unapplySeq("C[Int, Int]")
val tper = """^(.*?)(\[(.*?)\])?$""".r
tper.unapplySeq("C[Int, Int]")
tper.unapplySeq("")
case class X(x: Int, private y: => Int)
case class X(x: Int, private val y: => Int)
case class C(arr: Array[Int])
typeOf[C].declarations
typeOf[C].declarations.toList.take(2)
res1(0).info
res1(1).info
class C[T]
typeOf[C[Any]].typeSymbol.asType.toTypeConstructor
List("x") == List("x")
import scala.collection.generic._
import scala.collection.immutable.::
type X = CanBuildFrom[::[Int], Int, ::[Int]]
implicitly[X]
implicitly[CanBuildFrom[::[Int], Int, ::[Int]]]
implicitly[CanBuildFrom[::[_], Int, ::[Int]]]
implicitly[CanBuildFrom[List[_], Int, List[Int]]]
implicitly[CanBuildFrom[::[_], Int, List[Int]]]
implicitly[CanBuildFrom[::[_], Int, ::[Int]]]
import scala.pickling._
import json._
5.pickle
case class C(x: Int)
C(2).pickle
exit
typeOf[::[_]]
res0.typeSymbol.flags
res0.typeSymbol.info
res0.typeSymbol.flags
typeOf[Some[_]].flags
typeOf[Some[_]].info
typeOf[::[_]].isFinal
typeOf[::[_]].typeSymbol.isFinal
'!'.toInt
class C
typeOf[C].typeSymbol.info
typeOf[C].typeSymbol.info.typeSymbol
typeOf[Option[_]].typeSymbol.info
res0.typeSymbol.toType
res0.typeSymbol.asType.toType
System.currentTimeMillis
needsMacroExpansion
def foo(x: Int, y: Int) = x + y
def bar(fn: (Int, Int) => Int) = fn(40, 2)
bar(foo)
val x = Character.isWhitespace
val x = Character.isWhitespace _
def impl(c: Context)(args: c.Tree*) = c.literalUnit
def foo(args: _*) = macro impl
foo(qwe = 1, qqq = 2)
def impl(c: Context)(args: c.Tree*) = c.literal(args.toString)
def foo(args: _*) = macro impl
foo(qwe = 1, qqq = 2)
scala> def impl(c: Context)(args: c.Tree*) = c.literal(args.toString)
impl: (c: scala.reflect.macros.Context)(args: c.Tree*)c.Expr[String]
scala> def foo(args: _*) = macro impl
defined term macro foo: (args: _*)String
scala> foo(qwe = 1, qqq = 2)
class A
(ru: api.Universe).typeTag[A]
(ru: scala.reflect.api.Universe).typeTag[A]
(ru: scala.reflect.api.Universe).weakTypeTag[A]
typeTag[Int]
(ru: scala.reflect.api.JavaUniverse).weakTypeTag[A]
class A
(ru: scala.reflect.api.Universe).weakTypeTag[A]
class A
(ru: scala.reflect.api.Universe).weakTypeTag[A]
import reflect._
class A
import reflect._
runtime.universe: api.Universe
res0.typeTag[A]
res0.typeTag[A].in(currentMirror)
res0.typeTag[A].in(cm)
res0.typeTag[A].in(scala.reflect.runtime.currentMirror)
"%.2f%"
"%.2f%".format(0)
"%.2f x%".format(0)
"%.2f".format(0)
"%.2f".format(0f)
"%.2f".format(0.0)
f"${0}2f"
f"${0}%2f"
f"${0}%.2f"
object C
val c = classOf[C]
val cm = scala.reflect.runtime.currentMirror
cm.classSymbol(c)
c.companionSymbol
res0.companionSymbol
c.info
class C; object C
val cm = scala.reflect.runtime.currentMirror
class C; object C
import scala.reflect.runtime.{currentMirror => cm}
cm.classSymbol(classOf[C]).companionSymbol
cm.reflectModule(res0).instance
cm.reflectModule(res0.asModule).instance
q""
val as = List(q"1", q"2")
val sum = q"..$as.sum"
"%%".format()
reify(f"%%")
reify(manifest[Some[_]])
tb.parse("2").pos
tb.parse("x")
val tb = cm.mkToolBox()
tb.parse("x").pos
ru.reify{type X = List[T] forSome {type T} }
val s = Seq[Int](1,2,3)
val m = runtimeMirror(this.getClass.getClassLoader)
m.reflect(s).symbol.asType.toType
m.reflect(s).symbol.info
m.reflect(s).symbol.asType.toType <:< typeOf[Seq[Int]]
def foo(implicit x: Int) = x
foo
{ def x = 2; def y = z; def z = x }
def foo(x: AnyRef) = x
foo(2)
:power
:vals
typer
typer.typedTYpe
typer.typedType
typer.typedType(TypeTree(IntTpe))
TypeTree(IntTpe).original
object A{def p= println("hi")}
reify(A.p)
shwoRaw(res0, printIds = true)
showRaw(res0, printIds = true)
import scala.tools.reflect.ToolBox
val tb = scala.reflect.runtime.currentMirror.mkToolBox
val tb = scala.reflect.runtime.currentMirror.mkToolBox()
tb.typeCheck(res0.tree)
showRaw(res3, printIds = true)
Set(1) intersect Set(1, 2)
Set(1) * Set(1, 2)
Map(1 -> 2) - 1
Map(1 -> 2) -- List(1)
Map(1 -> 2) ++ Map(1 -> 3)
f"%n"
f"%"
f"%n"
f"%"
"%".format()
f"${0}%.2f%"
f"${0}%.2f"
"".substring(0, 1)
"%%".format()
f"%n"
f"${0}%n"
exit
f"${0}%n"
f"%n%n%n%n"
s"aaa$"
List(Array(0), Array(0L)).map(x => x)
lub
lub(typeOf[Array[String]], typeOf[Array[Nothing]])
lub(List(typeOf[Array[String]], typeOf[Array[Nothing]]))
if (false) Array("qwe") else Array()
if (false) Array("qwe") else Array[Nothing]()
1 to 10
2 / 3
case class Foo(i: Int, s: String, b: Boolean)
def foo[C, L](c: C)(implicit iso: Iso[C, L]): L = iso.to(c)
def foo[C, L](c: C)(implicit iso: Iso[C, L]): L = println(iso.to(c))
def foo[C, L](c: C)(implicit iso: Iso[C, L]) = println(iso.to(c))
case class Foo(i: Int, s: String, b: Boolean)
foo(Foo(23, "foo", true))
Array()
def foo(arr: Array[Char]) = arr
foo(Array())
q"x"
ilem
 import language.experimental._, reflect.macros.Context
object GrabContext {
  def lastContext = Option(System.getProperties.get("lastContext")
    .asInstanceOf[reflect.macros.runtime.Context])
  // System.properties lets you stash true globals (unlike statics which are classloader scoped)
  def impl(c: Context)() = { System.getProperties.put("lastContext", c); c.literalUnit }
  def grab() = macro impl
}
object Test { class C(implicit a: Any) { GrabContext.grab } }
GrabContext.lastContext.get.callsiteTyper.context.implicitss
object Test1 { class C(implicit a: Any) { GrabContext.grab } }
 import language.experimental._, reflect.macros.Context
object GrabContext {
  def lastContext = Option(System.getProperties.get("lastContext")
    .asInstanceOf[reflect.macros.runtime.Context])
  // System.properties lets you stash true globals (unlike statics which are classloader scoped)
  def impl(c: Context)() = { System.getProperties.put("lastContext", c); c.literalUnit }
  def grab() = macro impl
}
object Test { class C(implicit a: Any) { GrabContext.grab; GrabContext.grab } }
 import language.experimental._, reflect.macros.Context
object GrabContext {
  def lastContext = Option(System.getProperties.get("lastContext")
    .asInstanceOf[reflect.macros.runtime.Context])
  // System.properties lets you stash true globals (unlike statics which are classloader scoped)
  def impl(c: Context)() = { System.getProperties.put("lastContext", c); c.literalUnit }
  def grab() = macro impl
}
object Test { class C(implicit a: Any) { GrabContext.grab } }
import language.experimental._, reflect.macros.Context
object GrabContext {
  def lastContext = Option(System.getProperties.get("lastContext")
    .asInstanceOf[reflect.macros.runtime.Context])
  // System.properties lets you stash true globals (unlike statics which are classloader scoped)
  def impl(c: Context)() = { System.getProperties.put("lastContext", c); c.literalUnit }
  def grab() = macro impl
}
object Test { class C(implicit a: Any) { GrabContext.grab } }
import language.experimental._, reflect.macros.Context
object GrabContext {
  def lastContext = Option(System.getProperties.get("lastContext")
    .asInstanceOf[reflect.macros.runtime.Context])
  // System.properties lets you stash true globals (unlike statics which are classloader scoped)
  def impl(c: Context)() = { System.getProperties.put("lastContext", c); c.literalUnit }
  def grab() = macro impl
}
object Test { class C(implicit a: Any) { GrabContext.grab } }
    import scala.collection.JavaConverters._
val iterator: Iterator[(Object, Object)] = System.getProperties.asScala.iterator
iterator.collect{ case (k: String, v: String) => (k, v) }
iterator.collect{ case (k: String, v: String) => (k, v) }.toMap
val l = List(1,2,3)
def getTypeTag[T: ru.TypeTag](obj: T) = ru.typeTag[T]
val theType = getTypeTag(l).tpe
:t getTypeTag(l).tpe _
import foo._
exit
showRaw(reify(2))
class SomeClass(val intValue:Int)
class MyClass[T <: SomeClass](val myValue:T)
def f3[T](i: MyClass[T]) = ???
  reify({ case class R(id: Int); val lb = new ListBuffer[R](); lb
+= R(1)  })
})
  reify({ case class R(id: Int); val lb = new ListBuffer[R](); lb
+= R(1)  })
import scala.collection.mutable.ListBuffer
  reify({ case class R(id: Int); val lb = new ListBuffer[R](); lb
+= R(1)  })
reify({ case class R(id: Int); val lb = new ListBuffer[R](); lb += R(1) })
reify({ case class R(id: Int); val lb = new ListBuffer[R](); lb += R(1); () })
val build = scala.reflect.runtime.universe.build
val x = build.setinfo(build.newFreeTerm("x", 2), typeOf[Int])
def foo(x: Double) = { println(2 + 1 / x); foo(2 + 1 / x) }
def foo(x: Double): Double = { println(2 + 1 / x); foo(2 + 1 / x) }
foo(2.5)
def foo(x: Double): Double = { println(1 + 1 / x); foo(1 + 1 / x) }
foo(2)
(Math.sqrt(5) + 1) / 2
class C1(val n: Int) extends AnyVal
type T1 = C1
typeOf[T1]
typeOf[T1].erasure
typeOf[C1].erasure
typeOf[T1].typeSymbol
typeOf[C1].typeSymbol
exit
val tpe = weakTypeOf[Int]
showRaw(tq"$tpe")
q"new {()}"
showRaw(res0)
exit
q"x"
tq"X"
q"return x"
val tree = q"x"
q"return $tree"
exit
class A(val aparam: String)
class B(bparam: String) extends A(bparam)
ru.typeTag[B].tpe.declarations
println(scala.reflect.runtime.universe.typeTag[B].tpe.declarations)
ru.typeTag[B].tpe.members
val bparam = ru.typeTag[B].tpe.members.toList(1)
val aparam = ru.typeTag[B].tpe.members.toList(2)
val bparam = ru.typeTag[B].tpe.members.toList(1).asTerm
val aparam = ru.typeTag[B].tpe.members.toList(2).asTerm
aparam.isParamAccessor
bparam.isParamAccessor
bparam.isParam
bparam.isVal
aparam.isVal
val b = new B("hello")
val mirror = runtimeMirror(b.getClass.getClassLoader)
val alltypes = mirror.reflect(b).symbol.info.baseClasses.filter(c => c.isClass).map(c => c.asClass.info)
val vars: Seq[TermSymbol] = alltypes.flatMap(t => t.members.filter(m => m.isTerm && (m.asTerm.isVal || m.asTerm.isVar)).map(x => x.asTerm))
vars
val a = vars(1)
val b = vars(2)
val b = vars(0)
a
b
a.isParamAccessor
b.isParamAccessor
a.isVal
b.isVal
a.isPrivate
b.isPrivate
a.asInstanceOf[scala.reflect.internal.Symbols#Symbol].flags
b.asInstanceOf[scala.reflect.internal.Symbols#Symbol].flags
a.owner
b.owner
val vars: Seq[TermSymbol] = alltypes.flatMap(t => t.members.filter(m => m.isTerm && (m.asTerm.isMethod)).map(x => x.asTerm))
val vars: Seq[TermSymbol] = alltypes.flatMap(t => t.members.filter(m => m.isTerm && (m.asTerm.isMethod && m.asTerm.isParamAccessor)).map(x => x.asTerm))
a.accessor
a.getter
b.getter
val vars: Seq[TermSymbol] = alltypes.flatMap(t => t.members.filter(m => m.isTerm && (m.asTerm.isVal || m.asTerm.isVar)).map(x => x.asTerm))
val aparam = vars(1)
val bparam = vars(0)
aparam.getter
bparam.getter
val Apply(fun, args) = q"f(x)"
case class Foo(x: Int, y: Int)
class C { lazy val C(x, y) = C(2, 3) }
class C { lazy val Foo(x, y) = Foo(2, 3) }
exit
val i = 3val j = 3
val j = 3
val i = 3
(for (x = Option(i); if x == j) yield 42) toList
type F = List[F, Int]
type F = Map[F, Int]
exit
val Long = 1
Long
List(100, 200).zipWithIndex
List(100, 200).zipWithIndex.map{ case(x, i) => x + i }
case class C(x: Int)
typeOf[C].fields
typeOf[C].declarations
typeOf[C].declarations.collect{ case x: MethodSymbol if x.isAccessor => x }
typeOf[C].declarations.collect{ case x: MethodSymbol if x.isParamAccessor => x }
case class C[T](x: T)
val T = typeOf[C[Int]]
T match { case PolyType(_, _) => println("polymorphic entities are not supported"); case _ => }
T.typeSymbol.asType.typeParams
T.typeSymbol.asType.isCaseClass
T.typeSymbol.asClass.isCaseClass
((x: Int) => x)(2)
exit
new C().foo
exit
classOf[C].getConstructors
class C(x: Int)
classOf[C].getConstructors
exit
type T = Int
class C { def foo(x: T*) = ??? }
typeOf[C].declarations
typeOf[C].declarations.toList(1)
typeOf[C].declarations.toList(1).asMethod.paramss.flatten
typeOf[C].declarations.toList(1).asMethod.paramss.flatten(0).info
typeOf[C].declarations.toList(1).asMethod.paramss.flatten().apply(0).info
typeOf[C].declarations.toList(1).asMethod.paramss.flatten.apply(0).info
typeOf[C].declarations.toList(1).asMethod.paramss.flatten.apply(0).info.dealias
typeOf[C].declarations.toList(1).asMethod.paramss.flatten.apply(0).info.normalize
typeOf[C].declarations.toList(1).asMethod.paramss.flatten.apply(0).info.asInstanceOf[scala.reflect.internal.Types#Type]
res8.dealiasWiden
type T = Int
class C { def foo(x: T*) = ??? }
val tstar = typeOf[C].declarations.toList(1).asMethod.paramss.flatten().apply(0).info
val tstar = typeOf[C].declarations.toList(1).asMethod.paramss.flatten.apply(0).info
val tstar = typeOf[C].declarations.toList(1).asMethod.paramss.flatten.apply(0).info.asInstanceOf[scala.reflect.internal.Types#Type]
tstar.dealias
tstar.dealiasWiden
exit
class C[T] { type T = Int }
class Foo(x: Int) extends AnyVal
class Foo(val x: Int) extends AnyVal
val x: Foo = new Foo(2)
(x: Any) match { case x: Foo => x }
val x: List[Foo] = List(new Foo(2))
x(0) match { case x: Foo => x }
val payload = Map[String, Any]("x" -> List(new Foo(2)))
payload match { case (k, List(v: Fingerprint)) => v }
payload(0) match { case (k, List(v: Fingerprint)) => v }
payload.toList(0) match { case (k, List(v: Fingerprint)) => v }
payload.toList(0) match { case (k, List(v: Foo)) => v }
classOf[scala.Double].isAssignableFrom
classOf[scala.Double].isAssignableFrom(classOf[java.lang.Double])
new java.lang.Double(2)
new java.lang.Double(2).asInstanceOf[scala.Double]
classOf[scala.Double].cast(new java.lang.Double(2))
classOf[Double].isInstance(2)
classOf[Double].isInstance(new java.lang.Double(2))
classOf[Unit]
class X(val x: Int) extends AnyVal
classOf[X]
classOf[java.lang.Double].isAssignableFrom(classOf[java.lang.Double])
cm.reflect(null)
class C { def foo = 2 }
cm.reflect(null).reflectMethod(typeOf[C].declarations.head)
cm.reflect(null).reflectMethod(typeOf[C].declarations.head.asMethod)
class C { def foo = 2 }
cm.asInstanceOf[{ def methodToJava(sym: Any): java.lang.reflect.Method }]
class C { def foo = 2 }
val foo = typeOf[C].declarations.head.asMethod
val foo = typeOf[C].declarations.toList.apply(1).asMethod
class C { def foo = 2 }
val foo = typeOf[C].declarations.toList.apply(1).asMethod
val cmx = cm.asInstanceOf[{ def methodToJava(sym: Any): java.lang.reflect.Method }]
cmx.methodToJava(foo)
val cmx = cm.asInstanceOf[{ def methodToJava(sym: scala.reflect.internal.Symbols#MethodSymbol): java.lang.reflect.Method }]
cmx.methodToJava(foo)
cmx.methodToJava(foo.asInstanceOf[scala.reflect.internal.Symbols#MethodSymbol])
val cmx = cm.asInstanceOf[{ def methodToJava(sym: scala.reflect.api.Symbols#MethodSymbol): java.lang.reflect.Method }]
class C { def foo = 2 }
val foo = typeOf[C].declarations.toList.apply(1).asMethod
val cmx = cm.asInstanceOf[{ def methodToJava(sym: scala.reflect.internal.Symbols#MethodSymbol): java.lang.reflect.Method }]
cmx.methodToJava(foo.asInstanceOf[scala.reflect.internal.Symbols#MethodSymbol])
trait C { def foo: Int; def bar = 2 }
typeOf[C].declarations.toList.apply(1)
typeOf[C].declarations.toList.apply(2)
def isDeferred(sym: Symbol) = sym.asInstanceOf[scala.reflect.internal.Symbols#Symbol].hasFlag(scala.reflect.internal.Flags.DEFERRED)
isDeferred(res0)
isDeferred(res1)
class C
type T = C
new T
List[T]()
val q = FINAL
q"$q val x = 2"
().pickle
import scala.pickling._
().pickle
import json._
().pickle
res2.unpickle
res2.unpickle[Unit]
res2.unpickle
exit
import scala.pickling._
import json._
"x".pickle.unpickle
"x".pickle.unpickle[String]
12.pickle.unpickle[String]
12.pickle.unpickle[Int]
List(12).pickle.unpickle[List[Int]]
exit
import scala.pickling._
import json._
List(12).pickle.unpickle[List[Int]]
Array(12).pickle.unpickle[Array[Int]]
List(12).pickle
Array(12).pickle
import scala.pickling._
import json._
Array(12).pickle
import scala.pickling._; import json._
case class C1(x: Array[Int])
C(Array(1)).pickle
C1(Array(1)).pickle
res1.unpickle[C1]
import scala.pickling._
import json._
class C(x: Int)
new C(2).pickle
class C(val x: Int)
new C(2).pickle
res1.unpickle[C]
exit
java.io.File.pathSeparatorChar
trait Foo extends scala.reflect.macros.Macro { def foo(x: c.Tree) = x }
def foo = macro Foo.foo
import scala.language.experimental.macros
def foo = macro Foo.foo
trait Foo extends scala.reflect.macros.Macro { def foo(x: c.Tree) = x }
def foo = macro Foo.foo
import scala.reflect.macros.Macros
import scala.reflect.macros.Macro
trait Foo extends Macro { def foo(x: c.Tree) = x }
def foo = macro Foo.foo
object Foo { def unapply(x: Int): Boolean = x == 2 }
2 match { case Foo(_) => ??? }
def foo(c: Context)(x: c.Tree) = x
def bar(x: Int) = macro foo
bar(2)
val x = 2
x
y
class C { lazy val x = 2 }
class D extends C { override lazy val x = 3 }
new D().x
def foo(c: Context)(x: c.Tree) = x
def bar(x: Int) = macro foo
bar(2)
def foo(c: Context)(x: c.Tree) = x
def bar(x: Int) = macro foo
bar(2)
exit
def makeList_impl(c: Context)(clazz: c.Expr[Class[_]]): c.Expr[Any] = {
import c.universe._
val TypeRef(_, _, arg :: Nil) = clazz.tpe
q"List[$arg]()"
}
def makeList_impl(c: Context)(clazz: c.Expr[Class[_]]): c.Expr[Any] = {
import c.universe._
val TypeRef(_, _, arg :: Nil) = clazz.tree.tpe
c.Expr[Any](q"List[$arg]")
}
def makeList(clazz: Class[_]): Any = macro makeList_impl
makeList(classOf[Int])
def makeList_impl(c: Context)(clazz: c.Expr[Class[_]]): c.Expr[Any] = {
import c.universe._
val ConstantType(Constant(tpe)) = clazz.tree.tpe
c.Expr[Any](q"List[$arg]")
}
def makeList_impl(c: Context)(clazz: c.Expr[Class[_]]): c.Expr[Any] = {
import c.universe._
val ConstantType(Constant(tpe)) = clazz.tree.tpe
c.Expr[Any](q"List[$tpe]")
}
def makeList_impl(c: Context)(clazz: c.Expr[Class[_]]): c.Expr[Any] = {
import c.universe._
val ConstantType(Constant(tpe: Type)) = clazz.tree.tpe
c.Expr[Any](q"List[$tpe]")
}
def makeList(clazz: Class[_]): Any = macro makeList_impl
makeList(classOf[Int])
def makeList_impl(c: Context)(clazz: c.Expr[Class[_]]): c.Expr[Any] = {
import c.universe._
val ConstantType(Constant(tpe: Type)) = clazz.tree.tpe
c.Expr[Any](q"List[$tpe]()")
}
def makeList(clazz: Class[_]): Any = macro makeList_impl
makeList(classOf[Int])
makeList(classOf[String])
1
exit
context(option) { 2 }
import workflow._
context(option) { 2 }
def foo(x: Int) = x
context { f(2) }
context { foo(2) }
context(option) { foo(2) }
context(option) { $(foo(2)) }
context(option) { $(foo(Some(2))) }
def foo(x: Int, y: Int, z: Int) = x
context(option) { $(foo(Some(2), Some(3), Some(4))) }
{ def impl(c: Context) = c.literalUnit; def foo = macro impl; foo }
Ident(newTermName("foo"))
res0.symbol
object Macros { def impl(c: Context) = c.literalUnit }; def foo = macro impl; foo
object Macros { def impl(c: Context) = c.literalUnit }; def foo = macro Macros.impl; foo
object Macros { def impl(c: Context) = c.literalUnit }; def foo = macro impl; foo
object Macros { def impl(c: Context) = c.literalUnit }; def foo = macro Macros.impl; foo
object Macros { def impl(c: scala.reflect.macros.Context) = c.literalUnit }; def foo = macro Macros.impl; foo
object Macros { def impl(c: scala.reflect.macros.Context): c.Expr[Unit] = c.literalUnit }; def foo = macro Macros.impl; foo
object Macros { def impl(c: scala.reflect.macros.Context): c.Expr[Unit] = c.reify(println("hello!") }; def foo = macro Macros.impl; foo
object Macros { def impl(c: scala.reflect.macros.Context): c.Expr[Unit] = c.reify(println("hello!")) }; def foo = macro Macros.impl; foo
object Macros { def impl(c: scala.reflect.macros.Context): c.Expr[Unit] = c.universe.reify(println("hello!")) }; def foo = macro Macros.impl; foo
import scala.pickling._
import binary._
List(1, 2, 3).pickle
res0.unpickle
 reflect.runtime.universe.typeOf[java.util.Calendar].declaration(newTermName("getZone")).asMethod
 reflect.runtime.universe.typeOf[java.util.Calendar].declaration(TermName("getZone")).asMethod
res0.isPublic
res0.privateWithin
case class C(x: Int, y: Int)
typeOf[C].declarations
typeOf[C].declarations.collect { case x: TermSymbol => x }
typeOf[C].declarations.collect { case x: MethodSymbol if x.isGetter => x }
typeOf[C].declarations.collect(case x: MethodSymbol if x.isGetter => x)
val c = C(1, 2)
val m = currentMirror.reflect(c)
cm
val m = cm.reflect(c)
m.reflectMethod(res2.toList.apply(0))
res4
res4()
List(1, 2).foldLeft
List(1, 2).fold
List(1, 2).fold(1)(_ + _)
import scala.pickling._
import json._
2.pickle
exit
Some(2).toList
None.toList
def foo(implicit x: Int) = x
foo
trait Reads[T]
def foo[T](implicit x: Reads[T]) = x
foo
foo[Int]
q""
q"trait ${"foo"}"
q"""trait ${"foo"}"""
q"""trait ${"foo"} {}"""
tb.eval(tb.parse("trait T{def m = 0}; classOf[T]"))
tb.eval(tb.parse("trait T{def m = 0}; typeOf[T]"))
tb.eval(tb.parse("trait T{def m = 0}; scala.reflect.runtime.universe.typeOf[T]"))
tb.eval(tb.parse("trait T{def m = 0}; scala.reflect.runtime.universe.weakTypeOf[T]"))
inspect version
type Id[T] = T
reify { List[Id[Int]]() }
typeOf[Exception].typeSymbol.asClass.baseClasses
def foo(x: Int => Int) = x
foo{ val c = 2; x => c }
exit
"foo".T
"foo".type
type x = "foo".type
type T = { type U }
def foo: T = ???
foo.U
def foo: { type U } = ???
foo.A
foo.U
type q = foo.U
def foo(s: Singleton) = s
case class Foo
case class Foo()
foo(Foo)
foo(new Foo)
val x = Foo
foo(x)
val y: x.type = y
val y: x.type = x
foo(y)
val z = "zzz"
val q: z.type = z
foo(q)
class C
new C().foo
val x = 1 +
val x = 1 + _
class C { def +(c: C) = this }
val x = new C +
val x = new C() +
val x = new C() + _
213.getClass
def foo[M[_]: List]
= ???
def foo[M[_]] = ???
OptionType
OptionClass
OptionClass.toType
exit
{ def foo[T](x: Int) = x
val x = foo[Int]
x }
exit
case class Foo(x: Int); object Foo { def unapply(foo: Foo): Boolean = true }
abstract class C
class Foo(implicit x: Int)
"".isEmpty
List("x", "").flatMap(Predef.identity)
List("x", "").filter(_.nonEmpty)
List("x", "").filter(_.nonEmpty).mkString(" or ")
List("x", "y").filter(_.nonEmpty).mkString(" or ")
trait A { type B }
val a = new A{}
typeOf[a.B]
showRaw(res0)
"x" -> 2
exit
q"foo(2)"
q"foo[Int](2)"
val q"$x($y)" = res1
q"foo.bar[Int](2)"
val q"$x($y)" = res2
val q"$x.$y($z)" = res2
1 -> 2
1 ->[Int] 2
typeOf[Nil.type] <:< typeOf[Traversable[_]]
case class C(x: C)
case class C(var x: C)
val c = C(null)
c.x = c
case class C(var x: C) { override def toString = "C" }
val c = C(null)
c.x = c
c.getHashCode
c.getHashcode
c.hashcode
c.hashCode
def createArray[T: ClassTag](size: Int, el: T) = {
val a = new Array[T](size)
for (i <- 0 until size) a(i) = f(i)
}
def createArray[T: ClassTag](size: Int, el: T) = {
val a = new Array[T](size)
for (i <- 0 until size) a(i) = el
}
createArray[Int](10, 1)
def createArray[T: ClassTag](size: Int, el: T) = {
val a = new Array[T](size)
for (i <- 0 until size) a(i) = el
a
}
createArray[Int](10, 1)
def createArray[@specialized T: ClassTag](size: Int, el: T) = ???
val db = { trait Db { case class Coffee(name: String, price: Int, sales: Int); object Coffees { def insert(name: String, price: Int, sales: Int) = ???; def all: List[Coffee] = ??? } }; new Db{} }
db.coffees
val db = { trait Db { case class Coffee(name: String, price: Int, sales: Int); object Coffees { def insert(name: String, price: Int, sales: Int) = ???; def all: List[Coffee] = ??? } }; new Db{} }
db.Coffees
exit
val db = { trait Db { case class Coffee(name: String, price: Int, sales: Int); object Coffees { def insert(name: String, price: Int, sales: Int) = ???; def all: List[Coffee] = ??? } }; new Db{} }
db.Coffees.all
val db = { trait Db { case class Coffee(name: String, price: Int, sales: Int); object Coffees { def insert(name: String, price: Int, sales: Int) = ???; def all: List[Coffee] = List(Coffee("Brazilian", 99, 0)) } }; new Db{} }
db.Coffees.all
def impl(c: Context)(x: c.Tree) = ???
def foo(x: => Int) = macro impl
exit
val db = { trait Db { case class Coffee(name: String, price: Int, sales: Int); object Coffees { def insert(name: String, price: Int, sales: Int) = ???; def all: List[Coffee] = List(Coffee("Brazilian", 99, 0)) } }; new Db{} }
val db = { trait Db { case class Coffee(name: String, price: Int, sales: Int); val Coffees: List[Coffee] = List(Coffee("Brazilian", 99, 0)) }; new Db{} }
import scala.pickling._
import binary._
2.0.pickle
res0.unpickle
res0.unpickle[Double]
exit
val db = { case class Coffee(name: String, price: Int, sales: Int); trait Db { val Coffees: List[Coffee] = List(Coffee("Brazilian", 99, 0)) }; new Db{} }
val db = { trait Db { case class Coffee(name: String, price: Int, sales: Int); val Coffees: List[Coffee] = List(Coffee("Brazilian", 99, 0)) }; new Db{} }
db.Coffees.head
db.Coffees.head.name
typeOf[db.Coffees.head]
typeOf(db.Coffees.head)
val ttt[T: WeakTypeTag](x: T) = weakTypeOf[T]
def ttt[T: WeakTypeTag](x: T) = weakTypeOf[T]
ttt(db.Coffees.head)
def impl(c: Context) = ???
val db = { trait Db { case class Coffee(name: String, price: Int, sales: Int) { def foo = macro impl }; val Coffees: List[Coffee] = List(Coffee("Brazilian", 99, 0)) }; new Db{} }
EmptyTree
EmptyTree.tpe
EmptyTree.tpe <:< typeOf[Int]
EmptyTree.tpe <:< typeOf[Any]
"a".hashCode()
import scala.pickling._
import binary._
Array(1).pickle
exit
typeOf[Array[String]]
import scala.pickling._
import binary._
(Array(1): Any).pickle
case class C(x: Array[Int])
(C(Array(1)): Any).pickle
{ import json._; (C(Array(1)): Any).pickle }
exit
import scala.pickling._; import binary._
case class C(x: Array[Int])
(C(Array(1)): Any).pickle
classOf[Int].getComponentType()
exit
import scala.pickling._; import binary._
case class C(x: Array[Int])
(C(Array(1)): Any).pickle
res0.unpickle[C]
res1.x.toList
exit
def fold[A, B](els: List[A], b: B, f: (B, A) => B): B = ???
fold(List(1, 2, 3), 0.0, _ * _)
{ implicit val foo = 2; { implicit val foo = 3 { implicitly[Int] } } }
{ implicit val foo = 2; { implicit val foo = 3; { implicitly[Int] } } }
typeOf[List[_]].typeSymbol
res0.asClass
res1.info
res1.toType
val TypeRef(_, _, args) = res3
args.head.typeSymbol
existentialAbstraction(List(ress4), res3)
existentialAbstraction(List(res4), res3)
def impl[T](c: Context) = ???
def foo[T] = macro impl[T]
def foo[T <: Int] = macro impl[T]
def impl[T <: String](c: Context) = ???
def foo[T <: Int] = macro impl[T]
System.getenv("foo")
System.getenv()
System.getenv().keys
System.getenv().getKeys
System.getenv().getKey
System.getenv().keys
exit
System.getenv("PARADISE211_HOME")
import scala.pickling._
import binary._
val x = Array[Double](1)
x.pickle
import scala.pickling._
import json._
Array[Long](1, 2)
res0.pickle
res1.unpickle[Array[Long]]
Array[Float](1, 2)
res3.pickle
res4.unpickle[Array[Float]]
exit
import scala.pickling._
import json._
Array(1, 2).pickle
exit
new ArrayBuilder.ofInt
ArrayBuilder.ofInt
scala.collection.mutable.ArrayBuilder.ofInt
new scala.collection.mutable.ArrayBuilder.ofInt
import scala.pickling._
import binary._
scala.collection.mutable.ArrayBuffer[Int]()
res0 ++= List(1, 2)
res0.pickle
typeOf[List[_]].typeSymbol.asType.toType
import scala.collection.generic.CanBuildFrom
CanBuildFrom[Vector, Int, Vector[Int]]
implicitly[CanBuildFrom[Vector, Int, Vector[Int]]]
implicitly[CanBuildFrom[Vector[_], Int, Vector[Int]]]
implicitly[CanBuildFrom[Vector[_], Int, Vector[Int]]].apply
(1 to 10).toVector
clean
implicitly[CanBuildFrom[Vector[_], Int, Vector[Int]]].apply
import scala.collection.generic.CanBuildFrom
implicitly[CanBuildFrom[scala.collection.mutable.ArrayBuffer[_], Int, scala.collection.mutable.ArrayBuffer[Int]]].apply
List(2).getHa
List(2).getHashCode
List(2).getHashcode
List(2).hashCode
2.hashCode
final class Vertex(val label: String, var neighbors: List[Vertex]) extends Serializable
new Vertex("foo", Nil)
List(res4)
res4.hashCode
res5.hashCode

"xxxx".replace("x", "y")
List(1, 2).distinct
List(1, 2, 2).distinct
val p = Some(1)
for { p <- p } yield p
typeOf[Array[_]]
def <-(x: Int) = x
typeOf[scala.collection.mutable.ArrayBuffer[_]]
res0.typeSymbol.name
def test[B[_]](implicit tt: TypeTag[B[_]]) = typeOf[Function1[B, _]]
class Foo[B[_], T]
def test[B[_]](implicit tt: TypeTag[B[_]]) = typeOf[Foo[B, _]]
showRaw(test[Option])
test
test[Option]
def test?[B[_]](implicit tt: TypeTag[B[_]]) = typeOf[Foo[B, _]]
def test[B[_]](implicit tt: TypeTag[B[_]]) = weakTypeOf[Foo[B, _]]
showRaw(test[Option])
weakTypeTag[Option[_]]
showRaw(res4)
exit
trait T1 { def m = "t1" }
trait T2 { def m = "t2" }
new T1 with T2{}.m
trait T1 { override def m = "t1" }
trait T { def m: String }
trait T1 extends T { override def m = "t1" }
trait T2 extends T { override def m = "t2" }
new T1 with T2{}.m
new T2 with T1{}.m
@scala.reflect.internal.compileTimeOnly("foo") class C
@scala.reflect.internal.annotations.compileTimeOnly("foo") class C
new C
@scala.reflect.internal.annotations.compileTimeOnly("foo") class C extends scala.annotation.StaticAnnotation
@C def foo = 2
new C
object M { @scala.reflect.internal.annotations.compileTimeOnly("foo") class C extends scala.annotation.StaticAnnotation }
@??C def foo = 2
@M.C def foo = 2
class C { object X }
typeOf[C].member(newTermName("X"))
class C { def x(sss: Int) = ??? }
typeOf[C].member(newTermName("x"))
class C { def x(sss: Int) = ???; def x(sss: String) = ??? }
typeOf[C].member(newTermName("x"))
res2.asTerm.asInstanceOf[scala.reflect.internal.Symbols#Symbol].defString
class C { def x(sss: Int) = ??? }
typeOf[C].member(newTermName("x")).asInstanceOf[scala.reflect.internal.Symbols#Symbol].defString
typeOf[C].member(newTermName("x")).asInstanceOf[scala.reflect.internal.Symbols#Symbol].defStringSeenAs(NoType)
typeOf[C].member(newTermName("x"))
typeOf[C].member(newTermName("x")).asInstanceOf[scala.reflect.internal.Symbols#Symbol].infoString(NoType)
:power
Symbol_apply
Symbol_apply.infoString
Symbol_apply.defString
StringAdd_
StringAdd_+
StringAdd_+.defString
StringAdd_+.infoString(NoType)
StringAdd_+.infoString(StringAdd_+.info)
StringAdd_+.defStringSeenAs(StringAdd_+.info)
Symbol_apply.defStringSeenAs(StringAdd_+.info)
Symbol_apply.defStringSeenAs(Symbol_apply.info)
class C(x: Int) extends AnyVal
class C(val x: Int) extends AnyVal
class D { class C(val x: Int) extends AnyVal }
typeOf[kase]
typeOf[kase].typeSymbol
object Foo { def x; }
class X { class kase extends scala.annotation.StaticAnnotation }
class Y(@kase val x: Int) extends X
class Y extends X { @kase val x = 2 }
{ object D extends C.X { class X }; object C extends D.X { class X }; }
class ann extends scala.annotation.StaticAnnotation
{ import D._; object C; object D }
{ import D._; object C { def bar = foo }; object D { def foo = 2 } }
object D { def foo = 2 }
{ import d._; println(foo); val d = D }
{ import d._; println(foo); val d: D.type = D }
{ import d._; println(foo); lazy val d: D.type = D }
{ import d._; val d: D.type = D }
{ val d: D.type = D; import d._ }
{ val d: D.type = D; import d._; println(foo) }
object p { val x = 2 }
{ import p.x; val x = 1; println(x) }
{ val x = 1; { import p.x; println(x) } }
class Testpickling(val name: String, val year: Int)
import scala.pickling._
import binary._
val ff = new Testpickling("Jim", 2005)
ff.pickle
{ def foo(x: Int) = x; foo }
{ def foo(x: Int) = x; (foo _)}
List(1, 2) - 1
List(1, 2) diff List(1)
1 #:: Nil
1 #:: Stream.empty
(1 #:: (???: Stream.empty))
(1 #:: (???: Stream[Int]))
(1 #:: (??? : Stream[Int]))
res4.tail
(1 #:: (??? : Stream[Int]))
(1 #:: (??? : Stream[Int])).flatMap(x => Some(x))
List(1, 2).toStream
res7 match { case hd :: _ => hd }
res7 match { case hd #:: _ => hd }
(1 #:: 2 #:: (??? : Stream[Int])).flatMap(x => Some(x))
res11 match { case hd #:: _ => hd }
res4
res4.head
res4.headOption
exit
Some(1) #:: (??? : Stream[Int])
Some(1) #:: (??? : Stream[Option[Int]])
res1
res1.flatMap(x => x)
None #:: Some(1) #:: (??? : Stream[Option[Int]])
res4.flatMap(x => x)
Nil #:: List(1) #:: (??? : Stream[List[Int]])
res6.flatMap(x => x)
Nil #:: List(1, 2) #:: (??? : Stream[List[Int]])
res8.flatMap(x => x)
Nil #:: Some(List(1, 2)) #:: (??? : Stream[Option[List[Int]]])
None #:: Some(List(1, 2)) #:: (??? : Stream[Option[List[Int]]])
res11.flatMap(x => x)
exit
def foo(x: Int, y: Int) = x + y
val x = foo _
foo.tupled
x.tupled
List(1, 2) zip List(3, 4)
List(1, 2) replace
val x = List(1, 2)
for { y <- x; z = y } yield z
exit
@kase class C(x: Int)
type Foo = List[T] forSome { type T <: Int }
class ann extends scala.annotation.StaticAnnotation
type Foo = List[T] forSome { @nn type T <: Int }
type Foo = List[T] forSome { @ann type T <: Int }
@ann def x = 2
@ann type T = Int
class C
type Qwe = C { def x: Int }
type Qwe = C { @ann def x: Int }
class C { @ann def x: Int }
abstract class C { @ann def x: Int }
for (x <- 1 to 10) { yield i }
for {x <- 1 to 10} yield i
for {x <- 1 to 10} yield x
for {x <- 1 to 10} x
List(2, 3).zipWithIndex
implicit case class Foo(x: Int)
case class Foo(x: => Int)
@kase class C(x: Int)
class C extends Serializable with Serializable
trait T
class C extends T with T
def foo = macro ???
foo
@kase object C
@kase class C(x: Int)
@doubler class C
@doubler object C
@plusOne class C
2
typeOf[Any*]
for { val <- List(1, 2) } { case 1 => 3 }
for(v <- List(1, 2)) { case 1 => 3 }
for(v <- List(1, 2)) { case x => 3 }
exit
val q"$x" = "x"
q"foo"
q"fo["
q"vax x = 1"
q"class class"
System.getenv()
System.getenv("SCALA_HOME")
exit
cq"case x => x"
cq"x => x"
cq"x if x => x"
pq"xs @ (hd :: tl)"
val q"""new $tpe[..$tparams](...$vparamss) { ..$body }""" = q"new Foo {}"
q"class C[..$tparams]" = q"class C"
val q"class C[..$tparams]" = q"class C"
val q"""new $tpe[..$tparams](...$vparamss) { ..$body }""" = q"new Foo {}"
val q"""new $tpe[..$tparams] {}""" = q"new Foo {}"
q"""new C[T] {}"""
reify{ val x = 5; reify(x).splice }
val x = 5; reify{ reify(x).splice }
System.getProperty("user.dir")
import java.net.URL;
import java.net.URLClassLoader
val url = new URL("file:/Users/xeno_by/Projects/6240/build/pack/lib/scala-library.jar")
url.loadClass("scala.Function0")
val cl = new URLClassLoader(Array(url))
cl.loadClass("scala.Function0")
reify(2)
java.io.File.separator
Set(1).exists(_ == 1)
java.io.File.separator
val trees = List(q"call.f", "call.g")
q"..$trees"
val trees = List[Tree](q"call.f", "call.g")
val trees = List[Tree](q"call.f", q"call.g")
q"..$trees"
typeOf[scala.reflect.api.Exprs].declaration(newTypeName("Expr"))
res0.info.declaration("splice")
res0.info.declaration(newTermName("splice"))
res2.annotations
val x = "name"
q"$x.y"
showRaw(res0)
q"$x[y]"
tq "$x.y"
tq"$x.y"
cq"1 => 2"
throw new Exception
exit
new Exception
throw res0
throw new Exception
exit
throw new Exception
exit
trait TC2[T, U]
trait S
val x: ({ type L[X] = TC2[S, X] })#L = ???
type Y = ({ type L[X] = TC2[S, X] })#L
trait TC[X[_]]
type T = TC[({ type L[X] = TC2[S, X] })#L]
reify { type T = TC[({ type L[X] = TC2[S, X] })#L] }
throw new Exception()
throw new Exception
reify { val x = 2; reify(x).splice }
throw new Exception
(typeOf[String].normalize.##, typeOf[java.lang.String].normalize.##)
exit
(typeOf[String].normalize.##, typeOf[java.lang.String].normalize.##)
import scala.reflect.runtime.universe._
(typeOf[String].normalize.##, typeOf[java.lang.String].normalize.##)
class C { lazy val x = x }
class C { lazy val x: Int = x }
new C().x
typeOf[scala.tools.nsc.typechecker.Typers#Typers]
typeOf[scala.tools.nsc.typechecker.Typers#Typer]
res1.members
res1.members.filter(_.name.toString.startsWith("typed")).foreach(println)
exit
trait Foo { def foo }
trait Foo2 @foo { def foo }
System.getProperty("foo")
System.getProperty("foo1")
def foo(x: Int => Int) = x
def bar(x: Int) = x
foo(bar(_))
foo(foo(_ + 2))
foo((_))
foo(_)
foo({_})
case class Foo() { val w = Witness({b:Boolean => !b}) }
exit
import Witness._
case class Foo() { val w = Witness({b:Boolean => !b}) }
import Witness._
case class Foo() { val w = Witness({b:Boolean => !b}) }
class foo[T] extends scala.annotation.StaticAnnotation
@foo[Int] def x = 2
Witness({b:Boolean => !b})
val x = Apply(Select(EmptyTree, nme.CONSTRUCTOR), List(EmptyTree))
val q"${_}.${nme.CONSTRUCTOR}($instance)" = x
class C { var x = 2 }
val qq = new C().asInstanceOf[{ var x: Int }]
qq.x
qq.x = 3
qq.x
q"import scala.language.experimental.macros"
showRaw(res0)
type F = Int => Int
val x: F = { case x => x }
{ val x = 2; { val x = 3; x } }
val x = { case x => x }
def foo(x: Int => Int) = x
foo({ case x => x })
foo{ case x => x }
???
11:29 ~$ parse 'val x: Int => Int = ???'
[[syntax trees at end of parser]]// Scala source: tmp7pDKqZ
package <empty> {
  class wrapper extends scala.AnyRef {
    def <init>() = {
      super.<init>();
      ()
    };
    val x: _root_.scala.Function1[Int, Int] = $qmark$qmark$qmark
  }
type T = Function2[Int, Int, Int]
val f: T = { case (x, y) => ??? }
type U = (String, Int)
val x: U = ???
def x: U = ???
type T = Tuple1[Int]
case class C(x: Int)
C(2)
List(1, 2)
Array(1, 2)
Array(1, 2).toString
C(2)
new C(2)
C.apply(2)
val foo = 2
foo(2)
class C(val x: Int)
new C(2) match { case C(x) => x }
class C(val x: Int)
new C(2) match { case C(x) => x }
def foo[T] = ()
foo[Int]
foo[Int]()
def foo[T]() = ()
foo[Int]()
foo[Int]
foo
foo[Nothing]
type T = AnyRef[String]
2.isInstanceOf
"2".isInstanceOf
null.isInstanceOf
null
null.isInstanceOf[AnyRef]
null.isInstanceOf[Null]
null.isInstanceOf[Nothing]
null.isInstanceOf
"x".isInstanceOf[Nothing]
().isInstanceOf[Unit]
2.isInstanceOf[Unit]
"some".isInstanceOf[Unit]
null.isInstanceOf[Unit]
val x: Unit = 1
"some".asInstanceOf[Unit]
1.asInstanceOf[Unit]
1: Unit
1.asInstanceOf[Int]
1: Int
1: String
 "some": Unit
Some(1)
Some(1).x
class Foo[A]
class Bar extends Foo[Nothing]
val x: Foo[_] = Bar
object Bar extends Foo[Nothing]
class Foo[A]
object Bar extends Foo[Nothing]
val x: Foo[Int] = Bar
val x: Foo[_ <: Int] = Bar
class Foo[+A]
object Bar extends Foo[Nothing]
val x: Foo[_ <: Int] = Bar
val x: Foo[Int] = Bar
class Foo[-A]
object Bar extends Foo[Any]
val x: Foo[Int] = Bar
val f: Int => Int = (x: Nothing) => 1
val f: Int => Int = (x: Int) = ???
val f: Int => Int = (x: Int) => ???
val f: Int => Int = (x: Any) => 0
type A = Int => Int
type B = Any => Int
type C = Int => Nothing
implicitly[A <:< B]
implicitly[B <:< A]
implicitly[C <:< A]
type D = Any => Nothing
implicitly[D <:< A]
res3((x: Any) => ???)
res3(??? : D)
var x : Nothing = _
var x: Nothing = _
var x: Any = _
var x: AnyRef = _
var x: Int = _
var x: Unit = _
class Reference[T] {
  private var x: T = _
  def get: T = x
}
val r = new Reference[Nothing]
r.get
class Reference[T] {
  private var x: T = _
  def get: T = x
}
val r = new Reference[Nothing]
println(r.get)
throw null
"some".isInstanceOf[Object]
implicitly[Object <:< AnyRef]
class C
type D = C
implicitly[C <:< D]
implicitly[D <:< C]
implicitly[Null <:< Object]
implicitly[Object <:< Any]
::(1, 2)
 ::(1, 2)
 ::(1, Nil)
class C(x: Int, y: Int)
2 C 3
2 :: Nil
object ## { def apply(x: Int, y: Int) = x }
object !! { def apply(x: Int, y: Int) = x }
2 !! 3
def foo: List[_] = ???
class C { def foo: List[_] = ??? }
class D extends C { override def foo: List[Int] = ??? }
class E extends D { override def foo: List[_] = ??? }
val A = new { A => def copy(a : A.type) = a }
def o[T] = new { def foo(arg : T) = arg }
def f1[T](x: T) = new { def bar[U](x: U) = x }
@workflow(option) val x = 3
@workflow[Option] val x = 3
@workflow(option) val x = 3
@workflow[Option] val x = 3
val foo = 1
q"$#foo"
typeOf[System]
typeOf[System].typeSymbol.asClass.companionSymbol
typeOf[System].typeSymbol.asClass.companionSymbol.declarations
typeOf[System].typeSymbol.asClass.companionSymbol.asClass.declarations
typeOf[System].typeSymbol.asClass.companionSymbol.info.declarations
typeOf[System].typeSymbol.companionSymbol.info.declarations
q"foo $x"
val x = 1
q"foo ..$x"
import scala.reflect.runtime.universe._
val q"class $name extends ..$parents" = q"class Foo extends Bar with Blah"
import spire.syntax.literals._
b"101"
s"""\n"""
s"\n"
s"\0"
s"""\0"""
s"""\ux"""
s"""\."""
raw"""\."""
raw"""\n"""
raw"""\ux"""
raw"""\""""
raw"x\""
raw"x\"y"
class Foo(x: Int) { def bar = (y: Int) => this.x = y; override def toString = x.toString }
class Foo(private[this] var x: Int) { def bar = (y: Int) => this.x = y; override def toString = x.toString }
new Foo(2)
res0.x = 3
class Foo(private[this] var x: Int) { def bar = (y: Int) => this.x = y; override def toString = x.toString }
val foo = new Foo(2)
class Foo(private[this] var z: Int) { def bar = (y: Int) => this.z = y; override def toString = z.toString }
val foo = new Foo(2)
foo.z = 3
foo.bar(3)
foo
trait Foo
class C
class D extends C
type T = Foo { type T <: C }
val x: T = ??? : Foo { type T <: D }
def x: T = ??? : Foo { type T <: D }
class C
class D extends C
class E extends D
typeOf[E].baseClasses
typeOf[E].parents
typeOf[E].asInstanceOf[scala.reflect.internal.Types#Type].parents
Int Map Int
type T = Int Map Int
type T = Int Map Int]
:power
typeOf[scala.`package`.type]
typeOf[scala.`package`.type].moduleClass
typeOf[scala.`package`.type].typeSymbol.moduleClass
typeOf[scala.`package`.type].termSymbol.moduleClass
res3.flags
def foo = { class X; new X }
def foo = { object X; X }
def foo = { object X { def x = 2 }; X }
def foo = { class X; (x: X) => x }
System.getProperty("os.name")
def foo = { object O { class C }; new O.C }
:power
ErrorType
ErrorType <:< IntTpe
:power
NoSymbol.tpe
IntTpe <:< NoSymbol.tpe
NoSymbol.tpe <:< IntTpe
class C
class D extends C
typeOf[D].baseClasses
class X extends scala.reflect.macros.Macro
abstract class X extends scala.reflect.macros.Macro
typeOf[X].baseClasses
trait Y extends scala.reflect.macros.Macro
abstract class X extends Y
typeOf[X].baseClasses
trait Foo extends Macro { def impl = c.literalUnit }
trait Foo extends scala.reflect.macros.Macro { def impl = c.literalUnit }
def foo = macro Foo.impl
trait Foo extends scala.reflect.macros.Macro { def impl = c.literalUnit }
def foo = macro Foo.impl
class C[T]
class D extends C[_]
class D[T] extends C[?]
class D[T] extends C[T]
import scala.reflect.macros.Macro
trait Foo extends Macro { def impl = c.literalUnit }
def foo = macro Foo.impl
Some(1, 2).lastOption
val option = Some(100500)
option.lastOption
val x: Set[_] = Set(2)
val Seq(x, y) = Set(1, 2)
:power
nme.expandedName(TermName("foo"), MacroContextClass)
:power
EmptyPackage.fullName
EmptyPackage.name
EmptyPackage.fullName('$')
@throws[Exception] def foo: T = ...
@throws[Exception] def foo: T = ???
@throws[Exception] def foo[T]: T = ???
@throws[T] def foo[T]: T = ???
typeOf[List[Int]].typeSymbol.info
typeOf[List[Int]].typeSymbol.asType.toType
trait Bitness[D, B]
trait Bits32
trait Bits64
trait Bits16
implicit val bitnessShort = new Bitness[Short, Bits16]
implicit val bitnessShort = new Bitness[Short, Bits16] {}
implicit val bitnessInt = new Bitness[Short, Bits32] {}
implicit val bitnessLong = new Bitness[Short, Bits64] {}
def double(x: Int) = 2 * x
def ntimes(f: Int => Int, v: Int): Int =
def double(x: Int) = 2 * x
def ntimes(f: Int => Int, n: Int, x: Int): Int =
if (n == 0) x
def ntimes(f: Int => Int, n: Int, x: Int): Int =
if (n == 0) x else f(ntimes(f, n - 1, x))
ntimes(double, 0, 1)
ntimes(double, 1, 1)
ntimes(double, 2, 1)
def foo() = x
{ def unpickle5() = ???; unpickle5 }
{ def unpickle5() = ???; unpickle5 _ }
typeOf[Int] weak_<:< typeOf[Long]
trait Foo { object X }
trait Bar extends Foo { override object X }
q"yield 1"
class C(x: Int)
type Foo = C
new Foo(2)
def foo: Int
def foo(x: Int) = x
foo 2
2 foo
reify(reify(2))
reify(reify(reify(2)))
reify(reify(reify(reify(2))))
typeOf[{ def x: Int; def y: Int }] <:< typeOf[{ def x: Int }]
typeOf[{ class C { def x: Int = 2 } }]
typeOf[{ type C { def x: Int = 2 } }]
typeOf[{ type C <: { def x: Int = 2 } }]
typeOf[{ type C <: { def x: Int } }]
{ object M { class C { def x = 2 } }; M }
def tpeof[T: TypeTag](x: T) = typeOf[T]
{ object M { class C { def x = 2; def y = 3 } }; M }
tpeof(res4) <:< tpeof(res3)
type T = AnyRef{type C <: AnyRef{def x: Int}}
type U = AnyRef{type C <: AnyRef{def x: Int; def y: Int}}
def foo(x: T) = x
foo(null: U)
class foo[T] extends annotation.StaticAnnotation
@foo[T] def bar[T] = ???
{ class C[T] { def x: T = ??? }; new C[Int] }
def foo[A >: B, B](x: A): B = ???
class C
class D extends C
foo[C, D](null: C)
val foo = new { def unapply(x: Int) = Some(x) }
2 match { case foo(x) => x }
trait Foo[T]
class C
class D
implicit object CFoo extends Foo[C]
implicit object DFoo extends Foo[D]
def foo[T: Foo](xs: List[T]) = ...
def foo[T: Foo](xs: List[T]) = ???
foo(List(C, D))
foo(List(new C, new D))
def impl(c: Context) = c.literalUnit
class C { def foo: Long = ??? }
class D { def foo: Int = ??? }
List(new C, new D)
class D { def foo: Long = ??? }
List(new C, new D)
lub(typeOf[C], typeOf[D])
lub(List(typeOf[C], typeOf[D]))
trait Foo
class C extends Foo { def foo: Long = ??? }
class D extends Foo { def foo: Long = ??? }
lub(List(typeOf[C], typeOf[D]))
lub(List(typeOf[Foo { def foo: Int }], typeOf[Foo { def foo: Int }]))
lub(List(typeOf[Foo { def foo: Int }], typeOf[Foo { def foo: Long }]))
class X { def foo = macro impl }
lub(List(typeOf[Foo { def foo: Int }], typeOf[D]))
lub(List(typeOf[Foo { def foo: Long }], typeOf[D]))
lub(List(typeOf[Foo { def foo: Unit }], typeOf[X]))
class X extends Foo { def foo: Unit = macro impl }
lub(List(typeOf[Foo { def foo: Unit }], typeOf[X]))
def impl(c: Context) = c.literalUnit
class X { def foo: Unit = macro impl }
lub(List(typeOf[AnyRef { def foo: Unit }], typeOf[X]))
class Y { def foo: Int = ??? }
lub(List(typeOf[AnyRef { def foo: Unit }], typeOf[Y]))
def impl(c: Context) = c.literalUnit
class X { def foo: Unit = macro impl }
lub(List(typeOf[AnyRef { def foo: Unit }], typeOf[X]))
class C { def foo: Unit = ??? }
class D extends C { override def foo = macro impl }
:power
typeOf[D].typeSymbol.classBound
class E extends C { override def foo: Unit = ??? }
typeOf[E].typeSymbol.classBound
class D extends C { override def foo: Unit = macro impl }
typeOf[D].typeSymbol.classBound
class D extends C { def x = 2 }
typeOf[D].typeSymbol.classBound
glb
glb(List(typeOf[AnyRef { def x: Int }], typeOf[AnyRef { def y: Int }]))
glb(List(typeOf[AnyRef { def x: Int }], typeOf[AnyRef { def x: Int }]))
glb(List(typeOf[AnyRef { def x: Int }], typeOf[AnyRef { def x: Long }]))
X
new X
glb(List(typeOf[AnyRef { def foo: Unit }], typeOf[X]))
class X { def foo: Unit = ??? }
glb(List(typeOf[AnyRef { def foo: Unit }], typeOf[X]))
lub(List(typeOf[AnyRef { def foo: Unit }], typeOf[X]))
def impl(c: Context) = c.literalUnit
:power
class X { def foo: Unit = macro impl }
glb(List(typeOf[X], typeOf[AnyRef { def foo: Unit }]))
typeOf[X] <:< typeOf[AnyRef { def foo: Unit }]
class C private (x: Int) {}; object C { def apply(x: Int) = new C(x) }
new C(2)
C(2)
class C(x: Int) { def this(x: Int, y: Int) = this(x + y) }
class C(x: Int) { def this(x: Int, y: AnyRef = null) = this(x) }
new C(2)
class C private (x: Int) { def this(x: Int, dummy: AnyRef = null) = this(x) }; object C { def apply(x: Int) = new C(x) }
new C(2)
C(2)
class C(x: Int) { def this(x: Int, y: Int) = this(x + y) }
class D extends C(1, 2)
val xs = List(q"x1", q"x2")
q"..$xs"
q"CREATE TABLE t"my_table_name" (
    c"empno" NUMBER(5) PRIMARY KEY,
    c"empno2" NUMBER(5) PRIMARY KEY,
    PRIMARY KEY(pk"empno", pk"empno2")
  )
q"""CREATE TABLE t"my_table_name" (
    c"empno" NUMBER(5) PRIMARY KEY,
    c"empno2" NUMBER(5) PRIMARY KEY,
    PRIMARY KEY(pk"empno", pk"empno2")
  )"""
class X { def foo: Int = ??? }
class Y { def foo: Long = ??? }
glb(List(typeOf[X], typeOf[Y]))
glb(List(typeOf[AnyRef { def foo: Int }], typeOf[AnyRef { def foo: Long }]))
def foo = typeOf[AnyRef { def foo: Int }]
val x1 = foo
val x2 = foo
x1 eq x2
x1 == x2
x1 =:= x2
object X { def xProvider = new { apply(x: Int) = x } }
object X { def xProvider = new { def apply(x: Int) = x } }
X.xProvider(1)
def impl(c: Context) = q"new { def apply(x: Int) = x }"
def foo = macro impl
def impl(c: Context) = { import c.universe._; q"new { def apply(x: Int) = x }" 
def impl(c: Context) = { import c.universe._; q"new { def apply(x: Int) = x }"
def impl(c: Context) = { import c.universe._; q"new { def apply(x: Int) = x }" }
def foo = macro impl
foo(2)
def impl(c: Context) = { import c.universe._; q"new { def apply(x: Int) = x }" }
def foo = macro impl
foo(2)
def impl(c: Context) = { import c.universe._; q"new { def apply(x: Int) = x }" }
def foo = macro impl
foo
res0(2)
def impl(c: Context) = { import c.universe._; q"class C { def apply(x: Int) = x }; new C {}" }
def foo = macro impl
foo
foo(2)
class C { def foo(x: Int) = x; def foo = 1 }
new C().foo
new C().foo(1)
class C { def foo(x: Int) = x; def foo = new { def apply(x: Int) = x } }
new C().foo(1)
val x = q"""foo; bar"""
x.getClass
q"val x = 2"
q"$res0"
List(q"val x = 2")
q"..res2"
q"..$res2"
{ class C { def x: B = ??? }; class B extends C }
{ class C { class X extends B }; class B extends C }
{ class C { class X extends C }; class B extends C }
case class C private(x: Int)
C(2)
new C(2)
typeOf[Int]
import scala.reflect.runtime.universe
universe.typeOf[Int]
val l1 = List(q"foo")
val l2 = List(q"bar")
q"f(..${l1 ++ l2})"
val l3 = q"baz"
q"f(..${l1 ++ l2}, $l3)"
def h2db[I, O <: I](url: String)(i: I): O
= ???
val xs = List(1, 2)
xs.map(_ + 6)
val xs = List(q"x", q"y")
q"..$xs"
q"f(..$xs)"
class Box[X](val x: X) extends AnyVal {
def map[Y](f: X => Y): Box[Y] =
((bx: Box[X]) => new Box(f(bx.x)))(this)
}
def c: Context = ???
typeOf[c.universe.Tree]
def c: scala.reflect.runtime.Context = ???
def c: scala.reflect.runtime.contexts.Context = ???
def c: scala.macros.runtime.Context = ???
def c: scala.macro.runtime.Context = ???
def c: scala.reflect.macros.Context = ???
def c: scala.reflect.macros.contexts.Context = ???
typeOf[c.universe.Tree]
lazy val c: Context = ???
typeOf[c.universe.Tree]
showRaw(res2)
{ lazy val c: Context = ???; showRaw(typeOf[c.universe.Tree]) }
lazy val c: Context = ???
:power
:type c
:type -v c
:type -v c.Expr[Int]
:type -v (??? : c.Expr[Int])
@demomacroannotation val i = 10
import scala.reflect.macros.Context
import scala.language.experimental.macros
import scala.annotation.StaticAnnotation
def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }
class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro impl }
@foo class X
def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro impl }
@foo class X
consoel
console
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
import scala.reflect.macros.Context; import scala.language.experimental.macros; import scala.annotation.StaticAnnotation; object Macros { def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = { println("!!!!"); annottees(0) }; }; class foo extends StaticAnnotation { def macroTransform(annottees: Any*) = macro Macros.impl }
@foo class X
<
2<3
val q"case class C(...$vparamss)" = q"case class C(x: Int = 42)"
trait Fooable[T]
implicit val intIsFooable = new Fooable[Int] { override def toString = "Int" }
implicit def listIsFooable[T: Fooable]: Fooable[List[T]] = new Fooable[List[T]] { override def toString = "list of " + implicitly[Fooable[T]].toString }
implicitly[Fooable[Int]]
implicitly[Fooable[List[Int]]]
implicitly[Fooable[List[String]]]
???
def impl(c: Context)(x: c.Expr[Int]) = { println(x.tree.tpe); ??? }
def foo(x: Int) = macro impl
foo(2)
build.SyntacticClassDef
build.SyntacticClassDef.unapply(q"class C(x: Int)")
trait Cake { trait Liftable[T]; object Liftable { implicit def intLiftable = new Liftable[Int] {}; }; }
val cake = new Cake
val cake = new Cake {}
implicitly[cake.Liftable[Int]]
q"$null"
q"${null}"
q${null: scala.Symbol}"
q${(null: scala.Symbol)}"
q"${null: scala.Symbol}"
import test.pcohen.macros._
@demomacroannotation val i = 10
import test.pcohen.macros._
@demomacroannotation val x = 2
import test.pcohen.macros._
@demomacroannotation val i = 10
import test.pcohen.macros._
@demomacroannotation val i = 10
import test.pcohen.macros._
@demomacroannotation val i = 10
import test.pcohen.macros._
@demomacroannotation val i = 10
import test.pcohen.macros._
@demomacroannotation val i = 10
import test.pcohen.macros._
@demomacroannotation val i = 10
import test.pcohen.macros._
@demomacroannotation val i = 10
import test.pcohen.macros._
@demomacroannotation val i = 10
(): Unit
((): Unit)
{ ((): Unit) }
val q"$foo.$bar(..$args)" = q"foo.bar"
val q"$foo.$bar(..$args)" = q"foo.bar()()"
val q"$foo.$bar(..$args)" = q"foo.bar"
q"$foo.$bar(..$args)"
List(1) +: 2
List(1).+:(2)
val x$0 = 10
val f: Int => Int = { _ + x$0 }
val f: Int => Int = { _ + x$1 }
val x$0 = 10
val x$1 = 10
val f: Int => Int = { _ + x$1 }
f(1)
q"f(..${null})"
trait Fulfillable[A]
trait Need[A] extends Fulfillable[A]
case class NeedBook(id: String) extends Need[Book]
class Book
case class NeedBook(id: String) extends Need[Book]
weakTypeOf[NeedBook] <:< weakTypeOf[Fulfillable[_]]
case class Person(name: String, age: Int)
typeOf[Person].members.filter(m => m.isTerm && m.asTerm.isGetter)
val foo = { trait Qwe { def x = 2 }; new Qwe {} }
import foo
._
x
def lens[T](x: T) = ???
lens class C(x: Int)
lens (class C(x: Int))
lens {class C(x: Int)}
class C { def x = 2 }
type C1 = C
new C1
val db = { trait Db { type C1 = C }; new Db {} }
new db.C
new db.C1
val db = { trait Db { object C }; new Db {} }
db.C
class C { def x = 2 }
val db = { trait Db { type C1 = C }; new Db {} }
new db.C1
(new { def x = 2 }).x
lub(List(typeOf[{ def x: Int }], typeOf[{ def x: Int; def y: Int }]))
def x1: { def x: Int } = ???
def x2: { def x: Int; def y: Int } = ???
if (true) x1 else x2
def x1: { def x: Int } = null
def x2: { def x: Int; def y: Int } = null
if (true) x1 else x2
implicit class Foo(x: Int) {
trait Bla
implicit class Foo(x: Int) {
def + (bla: Bla) = ???
}
2 + new Bla
2 + new Bla {}
3 + "x"
IndexedSeq[Int]()
trait A { self => }
def foo[X](X: Int)(implicit X: TypeTag[X]) = ???
class C[T]
typeOf[C[_ <: java.lang.Number]]
showRaw(res0)
class C[T]
typeOf[C[_ <: java.lang.Number]]
{ typeOf[C[_ <: java.lang.Number]] }
{ class C; typeOf[C[_ <: java.lang.Number]] }
{ class C[T]; typeOf[C[_ <: java.lang.Number]] }
{ class C[T]; weakTypeOf[C[_ <: java.lang.Number]] }
import scala.collection.optimizer._
optimize{(1 to 10).toArray.find(_>0)}
val s:Option[Int] = optimize{(1 to 10).toArray.find(_>0)}
 val s:Option[Int] = optimize{(1 to 10).toArray.find(_>0)}
import scala.collection.optimizer._
 val s:Option[Int] = optimize{(1 to 10).toArray.find(_>0)}
import scala.collection.optimizer._
 val s:Option[Int] = optimize{(1 to 10).toArray.find(_>0)}
import scala.collection.optimizer._; val s: Option[Int] = optimize{(1 to 10).find(_>0)}
val s: Option[Int] = optimize{(1 to 10).find(_>0)}
import scala.collection.optimizer._
val s: Option[Int] = optimize{(1 to 10).find(_>0)}
class C { val x = macro ??? }
class C { def foo(x: Int) = x }
new C().asInstanceOf[{ def foo(x: Any): Int }]
new C().asInstanceOf[{ def foo(x: Any): Int }].foo(2)
class C { def foo(x: C) = x }
new C().asInstanceOf[{ def foo(x: C): Int }].foo(null)
class C { def foo(x: C) = x }
new C().asInstanceOf[{ def foo(x: C): C }].foo(null)
new C().asInstanceOf[{ def foo(x: AnyRef): C }].foo(null)
new C().isInstanceOf[{ def foo(x: AnyRef): C }]
q"while (x) y"
reify(while(true) 1)
val s: Option[Int] = optimize{(1 to 10).toArray.find(_>0)}
class C { def foo }
trait C { def foo }
class C { def foo }
triat C { def foo }
trait C { def foo }
trait C { val foo }
Right
Right(10)
for { x <- Right(10) } yield x
for { x <- Right(10).right } yield x
for { x <- Left("x").right } yield x
for { x <- Left("x").left } yield x
for { x <- Left("x").left } yield x.toString
for { x <- Left().left } yield
case class C(x: Int)
for { x <- Right(C(2)).right } yield x
for { x <- Right(C(2)).right } yield x.getClass
for { x <- Right(C(2)).left } yield x.getClass
for { x <- Left(1).right } yield x.getClass
def impl(c: BlackboxContext) = c.universe.reify(42)
import scala.reflect.macros.BlackboxContext
def impl(c: BlackboxContext) = c.universe.reify(42)
def foo = macro impl
def impl(c: BlackboxContext) = { import c.universe._; q"42" }
def foo = macro impl
class C { type T = Int }
typeOf[C].member(newTypeName("T"))
res0.asType
res1.toType
res1.toType.typeSymbol
res1.info
class x extends scala.annotation.StaticAnnotation
@x class C
type y = x
@y class C
class ann extends scala.annotation.StaticAnnotation
class C { @ann type X }
type C = { @ann type X }
type T = { @deprecated("", "") def x: Int }
class ann extends scala.annotation.StaticAnnotation
class C { @ann type X }
type C = { @ann type X }
class C { @ann def x: Int }
class C { @ann def x = ??? }
class C { @ann def x: Int }
class ann extends scala.annotation.StaticAnnotation
trait C { @ann type X }
trait T { @ann type X }
type T = { @ann type X }
type T = { @ann def x: Int = ??? }
type T = { @ann def x: Int }
class T = { @ann def x: Int = ??? }
class T { @ann def x: Int = ??? }
class C { type T }
def foo(c: C)(x: c.T = null) = ???
class C { type T <: AnyRef }
def foo(c: C)(x: c.T = null) = ???
def foo(c: C)(x: c.T = ???) = ???
None.isInstanceOf[Product]
tb.typeCheck(q"if (true) Some(2) else None", WildcardType).tpe
tb.typeCheck(q"if (true) Some(2) else None", typeOf[Any]).tpe
tb.typeCheck(q"if (true) Some(2) else None", typeOf[Product]).tpe
q"def foo(${TermName("x")})"
trait Foo extends Macro { def foo(x: c.Expr[Int]) = x }
import scala.reflect.macros.Macro
import scala.reflect.macros.blackbox.Macro
trait Foo extends BlackboxMacro { def foo(x: c.Expr[Int]) = x }
def foo(x: Int) = macro Foo.foo
foo(2)
import scala.reflect.runtime.universe._
import scala.reflect.runtime.{currentMirror => cm}
import scala.tools.reflect.ToolBox
val tb = cm.mkToolBox
val tb = cm.mkToolBox()
tb.eval(q"2 + 2")
class ann extends scala.annotation.StaticAnnotation
class C { @ann def foo x = 2 }
class C { @ann def foo = 2 }
type C = { @ann def foo: Int }
type C = { def foo: Int }
showRaw(reify{class C { def x = 2 }})
import scala.tools.reflect.ToolBox
import scala.runtime.reflect.universe._
import scala.reflect.runtime.{currentMirror => cm}
val tb = cm.mkToolBox
val tb = cm.mkToolBox()
tb.eval(q"2 + 2")
val x = 2
tb.eval(reify(x + 2))
tb.eval(reify(x + 2).tree)
tb.typeCheck(reify(x + 2).tree)
tb.typeCheck(reify{class C { def x = 2 }}.tree)
showRaw(res5)
showRaw(res5, printIds = true)
showRaw(res5, printTypes = true)
newTermName("+")
res0.encoded
res0.encoded.decoded
res0.encoded.decoded()
res0.encoded.decodedName
res0.encodedName.decodedName
List().getOrElse(List())
Test.ok
Test.eval
q"""${""}"""
val ru = scala.reflect.runtime.universe
ru.Liftable
type T = ru.Liftable
type T = ru.Liftable[Int]
type T = scala.reflect.runtime.universe.Liftable[Int]
case class C(x: Int)
new C(2)
C(2)
C.apply(2)
C
typeOf[C.type].declarations
class C { type X <: Int }
class C { type X >: Int <: Int }
class C { type X <: Int >: Int }
q"class C"
s""
f""
"brk brk" flatMap (ch  if (ch > 127) f"&#x${ch}%04x;" else "" + ch)
Map(1 -> 2)
Map(1 -> 2).get(3)
val lots = List[Option[List[Int]]](Some(List(1, 2)), None)
lots.flatten
lots.flatten.flatten
implicit val x = 2
implicitly[Int]
macro foo = bar
class C[T, U <: T]
throw new Exception
new Exception().toString
new Exception().printStackTrace
case class Ok(i: Int, s: String)
 val ok = Ok(1, "ok")
showRaw(q"$ok")
case class Ok(i: Int, s: String)
val ok = Ok(1, "ok")
showRaw(q"$ok")
val cm = scala.reflect.runtime.currentMirror
val root = cm.RootPackage
root.id
root.asInstanceOf[scala.reflect.internal.Symbols#Symbol].id
root.moduleClass.asClass.module
:power
RootPackage
RootClass
RootPackage.moduleClass
:power
RootPackage
RootClass
RootPackage.moduleClass
RootPackage.moduleClass.module
RootPackage.moduleClass.sourceModule
RootClass.sourceModule
RootClass.module
:power
RootPackage.moduleClass
RootClass.module == RootPackage
import cm._
RootClass.module == RootPackage
:power
RootClass.sourceModule
trait A { val a: Int }
trait B { val a: String }
object Cake extends A with B
val a: Int => Int = implicit x => x
val a: Int => Int = (implicit x) => x
val fun: (Int, => Double) => String = null
fun.getClass
def typeOf[T: TypeTag](x: T) = typeOf[T]
def typeOf[T: TypeTag](x: T) = ru.typeOf[T]
typeOf(fun)
val fun: (Int => Double) => String = null
typeOf(fun)
val cm = scala.reflect.runtime.currentMirror
val tb = cm.mkToolBox()
tb.parse("2 + 2")
showRaw(res0)
q"2 + 2"
import scala.reflect.runtime.universe._
q"2 + 2"
tb.eval(res0)
tb.typeCheck(res0)
val tree = tb.parse({ class X { def x = 2 }; new X })
val tree = tb.parse("{ class X { def x = 2 }; new X }")
tb.typeCheck(tree)
showRaw(res6, printTypes = true)
List(1, 2).span(_ == 3)
List(1, 2, 3, 4).span(_ == 3)
List(1, 2, 3, 4).partition(_ == 3)
val stats = List[Tree]()
q"{ () => ..$stats }"
q"(() => ..$stats)"
val x = { () => val x = 2; x }
val tparams = Nil
q"def foo[..$tparams] = 2"
val tparams: List[Tree] = Nil
q"def foo[..$tparams] = 2"
showRaw(tq"List[Int]")
def optee(tpe: Type) = tpe.baseType(typeOf[Option[_]].typeSymbol).asInstanceOf[TypeRef].args.head
optee(typeOf[Option[Int]])
optee(typeOf[Some[Int]])
typeOf[Int].baseType(typeOf[Option[_]].typeSymbol)
val x: 3.type = 3
val x: 3.type = 4
var x: 3.type = 4
var x: 3.type = 3
val x = "x"
var y: x.type = x
val x: 3.type = 3
val y: x.type = x
def foo(x: Int) = ???
foo(
)
foo("x")
implicit def x[T](x: Any): Dynamic with T = ???
foo("x")
 def foo(a: Any) = 0;
{ var a = 0; /*splice*/ foo(a = 1) }
var x = 1
val y = (x = 1)
lazy implicit val x = 2
val y: Int => Int = { implicit x => x }
typeOf[Int { type T = String }]
res0.members
res0.members.foreach(println)
class C(x: Int)
typeOf[C].members
NoSymbol.alternatives
NoSymbol.asInstanceOf[scala.reflect.internal.Symbols#Symbol].alternatives
NoSymbol.info
class C(val x: Int)
typeOf[C].members(TermName("c"))
typeOf[C].member(TermName("c"))
typeOf[C].member(TermName("x"))
res9.asTerm.alternatives
class C(x: Int)
typeOf[C].member(TermName("x"))
typeOf[C].member(TermName("x")).info
typeOf[C].erasure.primaryConstrutor
typeOf[C].erasure.primaryConstructor
typeOf[C].erasure.typeSymbol.asInstanceOf[scala.reflect.internal.Symbols#Symbol].primaryConstructor
:power
NoSymbol.paramss
NoType.baseClasses
class C(val x: Int)
classOf[C].getConstructors()
classOf[C].getConstructors().head
val foo: Int => Int = x => x
val foo: implicit Int => Int = x => x
val foo: (implicit Int => Int) = x => x
val foo: ((implicit Int) => Int) = x => x
class ann extends annotation.StaticAnnotation
typeOf[Int => Int @ann]
showRaw(res0)
showRaw(typeOf[(Int => Int) @ann])
typeOf[String].typeSymbol.getter
q"(1 to 10).reduce(_+_)"
typeOf[{type lambda[X] = X}#lambda]
typeOf[({type lambda[X] = X})#lambda]
typeOf[({type lambda[X] = X})#lambda[_]]
:power
newSyntheticTypeParam("T0", 0L)
NoSymbol.newSyntheticTypeParam("T0", 0L)
polyType(res3, res3.toTypeConstructor)
polyType(res3 :: Nil, res3.toTypeConstructor)
appliedType(res5, List(typeOf[Int]))
polyType(res3 :: Nil, appliedType(typeOf[List[_]], List(res3.toTypeConstructor)))
appliedType(res7, List(typeOf[Int]))
reify{ type Id[T] = T }
showRaw(reify{ type Id[T] = T }, printTypes = true)
q"x => x"
q"val y = x => x"
q"(x => x)"
q"???"
q"${???}"
val l = List(q"a", q"b")
q"4l"
q"$l"
new Array[Nothing]()
new Array[Nothing](2)
val x = new Array[Nothing](2)(0)
q"class C(x: Int)"
showCode(res0)
class C { def isThreadsafe = false; def isThreadsafe(x: Int) = true }
new C().isThreadsafe
typeOf[List[_]].member(TermName("head")).asMethod
res0.name
val tpeList = typeOf[List[_]]
appliedType(tpeList, List(typeOf[Int]))
5.asInstanceOf[6.type]
5.asInstanceOf[Int]
val q"def foo(...$ps1)(..$ps2) = ???" = q"def foo(x: Int)(y: Int) = ???"
val q"def foo(..$ps1)(..$ps2) = ???" = q"def foo(x: Int)(y: Int) = ???"
class C { type T = Int }
def foo(c: C)(t: c.T) = t
def foo(c: C = new C)(t: c.T) = t
class C(x: Int)
def foo(c: C = new C)(t: Int) = t
def foo(c: C = new C(2))(t: Int) = t
class C(val x: Int)
def foo(c: C = new C(2))(t: Int) = t
foo()(c.x)
Integer.MAX_VALUE
Integer.MAX_VALUE + Integer.MAX_VALUE
ty
typeOf[Int { def x: Int }]
:power
class C { def c: C = new C }
:power
typeOf[C]
res0.typeSymbol.info
var a, b = 0L
2L & -1L
class Foo(val flags: Long) extends AnyVal
class Bar extends Foo(0L)
~0L
typeOf[List[_]].typeSymbol.asType.toType
typeOf[Function1[_,_]].typeSymbol.asType.toType
Map(1 -> 2).get(null)
Map(1 -> 2).get(null: String)
Map("1" -> 2).get(null: String)
Map("1" -> 2).getOrElse(null: String, 4)
q"foo _"
showRaw(res0)
def foo(x: Int)(y: Int) = x + y
foo(2)
List(1, 2).zipWithIndex
Nil.exists(_ => false)
List(1 -> 2, 2 -> 1).sortBy(_._2)
1 -> 2
(1 -> 2) match { case x -> y => x }
scala.collection.mutable.ListBuffer.fill
scala.collection.mutable.ListBuffer.fill(1)(1)
Map(1 -> 2)
res0.toList
res0.map{ case (k, v) => k -> v }
res0.map{ case (k, v) => k -> v.toString }
res0.map{ case (k, v) => k + v }
typeOf[Map[_]]
typeOf[Map[_, _]].typeSymbol
:power
freshNameCreator
context
typer
typer.context.unit.fresh
res3.newName("test"
)
q"object D"
q"class C"
:power
typed(q"{ class A(x: Int, val y: Double); }")
val q"{ class $name(..$params) { ..$body }; }" = res0
type Foo = (=> Int) => Int
val fn: Foo = x => x
val fn: Foo = x => 1
fn(???)
type Foo = Int* => Int
type Foo = (Int*) => Int
val fn: Foo = xs => xs
def foo[T]: List[T] = ???
(foo: List[Int])
val five = reify(5)
reify(5.toString)
showRaw(res0)
reify(five.splice.toString)
classOf[java.io.File].getClassLoader
ClassLoader.getSystemClassLoader()
ClassLoader.getSystemClassLoader().getParent
ClassLoader.getSystemClassLoader().getParent.getParent
var messages = List[String]()
messages += ""
messages ++= ""
var messages = List[Int]()
messages += 1
messages ++= 1
var messages = List(1)
messages += 2
messages +:= 2
messages
messages :+ 3
messages :+= 3
messages
class C { def foo(c: Any) = c; def foo(c: AnyRef) = c }
List(1, 2) diff List(2, 3)
class C { type T <: Int }
typeOf[C].member(TypeName("T")).info
typeOf[C].member(TypeName("T")).info.asInstanceOf[TypeBounds]/hi
typeOf[C].member(TypeName("T")).info.asInstanceOf[TypeBounds].hi
:power
typeOf[java.io.File].typeSymbol.primaryConstructor
showRaw(typeOf[java.io.File].typeSymbol, printIds = true)
showRaw(typeOf[java.io.File].members.head, printIds = true)
ObjectClass
ObjectClass.primaryConstructor
ObjectClass.isJava
ObjectClass.info.decl(nme.CONSTRUCTOR)
:power
ObjectClass.info.decl(nme.CONSTRUCTOR)
ObjectClass.info.decl(nme.CONSTRUCTOR).asMethod
typeOf[List[Int]]
typeOf[List[Int]].typeArgs
type T = List[Int]
typeOf[T].typeArgs
typeOf[T].dealias.typeArgs
type T = List[Int]
typeOf[T].typeArgs
typeOf[T].dealias.typeArgs
type Id[X] = X
symbolOf[Id[_]].info
typeOf[Id[_]]
typeOf[Id[_]].typeSymbol
showRaw(res1)
res1.underlying
:power
typeOf[Id[_]]
res5.underlying
res5.underlying.typeSymbol
showRaw(res6)
class C { def foo[T](x: T)(y: T) = ??? }
typeOf[C].member(TermName("foo")).asMethod
res0.info
res1.resultType
res1.finalResultType
res1.resultType.resultType
res1.resultType.resultType.resultType
:power
NoSymbol.info
NoSymbol.toType
:power
NoSymbol.tpe
:power
staticPackage("scala")
rootMirror.staticPackage("scala")
res1.companionSymbol
rootMirror.staticPackage("scala").moduleClass
rootMirror.staticPackage("scala").moduleClass.companionSymbol
ScalaPackage.companionSymbol
ScalaPackageClass.companionSymbol
ScalaPackageClass.companionSymbol == ScalaPackage
class C; object C
typeOf[C].companionSymbol
class C; object C
typeOf[C].typeSymbol
res0.companionSymbol
:power
typeOf[C].typeSymbol
res2.companionSymbol
res2.companionSymbol.isModuleClass
res2.companionSymbol.moduleClass
res2.companionSymbol.moduleClass.companionSymbol
:power
class C; object C
val classC = typeOf[C].typeSymbol
val moduleC = classC.companionSymbol
classC.companionSymbol == moduleC
moduleC.companionSymbol == classC
moduleC.moduleClass.companionSymbol == moduleC
class ann extends scala.annotation.StaticAnnotation
@ann def foo = 2
@ann class C
symbolOf[C].annotations
symbolOf[C].annotations.head.atp
symbolOf[C].annotations.head.tpe
class ann[T] extends scala.annotation.StaticAnnotation
@ann[Int] class C
symbolOf[C].annotations.head.tpe
q"new Foo[Int](1, 2)"
res4.children
res4.children.tail
q"@foo"
power
:power
class C(x: Int)
typed(q"new C(2)")
val c = new C(2); typed(q"new C(2)")
typed(q"new java.io.File()")
typed(q"""new java.io.File("")""")
typed(q"new java.io.File(${""})")
res5.symbol
res5.tpe
typed(q"Array[Any](1, 2)")
:power
typed(tq"List")
typed(tq"List", TYPEmode)
typer.typed(tq"List", TYPEmode)
typer.typed(tq"List", scala.reflect.internal.Mode.TYPEmode)
typer.typed(tq"scala.List", scala.reflect.internal.Mode.TYPEmode)
typer.typed(q"1", scala.reflect.internal.Mode.TYPEmode)
typer.typed(q"java.lang.Enum", scala.reflect.internal.Mode.TYPEmode)
class C { def x = 2
}
typeOf[C].declarations.last
typeOf[C].declarations.last.allOverriddenSymbols
NoSymbol.fullName
typeOf[String].members.filter(_.name.decoded == "compareTo") foreach { m => println(m.fullName, m.info) }
typeOf[String].member(newTermName("compareTo")).asTerm.alternatives foreach { m => println(m.fullName, m.info) }
cm.classSymbol(Class.forName("java.lang.ref.ReferenceQueue$1"))
cm.staticPackage("scala")
res3.isModule
res3.isModuleClass
res3.isPackage
res3.isPackageClass
ScalaPackageClass
ScalaPackageClass.isModule
ScalaPackageClass.isModuleClass
ScalaPackageClass.isPackage
ScalaPackageClass.isPackageClass
object C
typeOf[C.type].typeSymbol
res3.isModule
res3.isModuleClass
res13.isModuleClass
res13.isModule
class Impl(c: Context { type PrefixType = Int })
List(2, 1).sorted
q""
q"f(x)"
typeOf[scala.reflect.api.Universe].members filterNot (_.isVal)
:power
typeOf[scala.reflect.api.Universe].members filterNot (_.isVal)
(typeOf[scala.reflect.api.Universe].members filterNot (_.isVal) map (_.defString) filter (_ startsWith "val ")).toList.sorted
val q"$foo($bar)" = q"x.y(2)"
val q"$foo($bar)" = q"new x(2)"
val q"$foo($bar)" = q"new x"
val q"$foo($bar)" = q"new x()"
val q"$foo(..$bar)" = q"new x()"
val q"$foo(..$bar)" = q"new x"
q"_"
List(1, 1) diff List(1)
List(1, 1) diff List(1, 1)
def impl(c: Context)(x: c.Expr[String]) = {
val x1 = c.Expr[String](c.untypecheck(x.tree.duplicate))
println(s"compile-time value is: \${c.eval(x1)}")
x
}
def test(x: String) = macro impl
test("x")
def impl(c: Context)(x: c.Expr[String]) = {
val x1 = c.Expr[String](c.untypecheck(x.tree.duplicate))
println(s"compile-time value is: ${c.eval(x1)}")
x
}
def test(x: String) = macro impl
test("x")
throw ???
val l = (1 to 10).map { i => s"foo$i" -> i }.toList
import scala.collection.mutable._
ListMap(l: _*)
val lm = ListMap[String, Int]()
for (item <- l) lm += item
lm
for (item <- l) println(item)
val lm = ListMap[String, Int]()
for (item <- l) lm(item.key) = item.value
for (item <- l) lm(item._1) = item._2
lm
import scala.collection.mutable._
val lm = ListMap[String, Int]()
lm("foo1") = 1
lm("foo2") = 3
lm("foo3") = 2
lm
val q"..$_; $last" = typecheck(q"val x = 1: ${tq""}; x"); last.tpe
:power
val q"..$_; $last" = typed(q"val x = 1: ${tq""}; x"); last.tpe
val arr = new Array[Nothing](2)
throw arr(0)
val x = arr(0)
class C {
def foo[T](x: T)(y: T) = ???
def bar: Int = ???
}
typeOf[C].member(TermName("bar")).asMethod
res6.info
res6.info.resultType
res6.info.finalResultType

class C extends { type T = Int } with A
class B[T]
class C extends { type T = Int } with B[T]
class B(x: Int)
class C extends { val x = 2 } with B(2)
class B[T]
class C extends { type T = Int } with B[T]
impl2
class C extends { type T = macro impl2 } with AnyRef
exit
class C extends { val x = 2 } with B(x)
exit
type T = macro impl2
typeOf[T]
def foo = macro impl1
reify(foo)
res1.eval
class C(x: Int)(y: Int) extends scala.annotation.StaticAnnotation
class X @C(2)(3) ()
class X @C(2) ()
class ann1(x: Int) extends scala.annotation.StaticAnnotation
class C @ann1(2) ()
class ann2(x: Int)(y: Int) extends scala.annotation.StaticAnnotation
class C @ann2(2)(3) ()
exit
def foo( = macro impl
def foo( = macro impl)
def foo() = (macro impl
)
val macro = 1
def foo() = (macro impl
)
def foo = macro impl1
implicit class IntExt(i: Int) { def impl = 2 }
def foo() = (macro impl)
def foo() = (macro impl()
exit
Ident(newTermName("x")).attachmetns
Ident(newTermName("x")).attachments
exit
class C; object C { implicit val list = List[C](new C) }
exit
new B().toString
exit
reify{ object C }
showRaw(res0.tree)
exit
class C; object C extends C
class C { println(C); }; object C
new C
exit
typeOf[_ => _]
typeOf[_ => _].typeSymbol.typeSignature
exit
class C extends Any
class C extends AnyRef
def foo = { println("foo"); 1 }
foo #:: foo #:: Stream.Empty
def foo: Int = { println("foo"); 1 }
1 :: 2 :: Nil
foo #:: foo #:: Stream.Empty
1 #:: 2 #:: Stream.Empty
1 #:: Stream.Empty
1 #:: Stream.empty
foo #:: foo #:: Stream.Empty
foo #:: foo #:: Stream.empty
def foo1: Int = { println("foo1"); 1 }
def foo2: Int = { println("foo2"); 2 }
foo1 #:: foo2 #:: Stream.empty
Stream.iterate(1)(_)
Stream.iterate(1)(x => x)
List(1, 2) flatMap { case 1 => Some(1) }
List(1, 2) collect { case 1 => Some(1) }
List(1, 2) collect { case 1 => 1 }
foo1 #:: foo2 #:: Stream.empty
def foo1: Int = { println("foo1"); 1 }
def foo2: Int = { println("foo2"); 2 }
foo1 #:: foo2 #:: Stream.empty
res4 match { case hd #:: tl => }
Lisr(1, 2, 3) match { case hd #:: tl => }
List(1, 2, 3) match { case hd #:: tl => }
List(1, 2) collect { case 1 => println("x") }
exit
List(1, 2) match { case List(x, xs: _*) => }
List(1, 2) match { case xs :+ x => println(xs, x) }
List(1, 2) match { case xs ++ ys => xs }
trait Fooable[T]
class C; object C { implicit val x = new Fooable[C]{} }
implicitly[Fooable[C]]
trait Fooable[T]
class C; object C { implicit val x = new Fooable[C]{} }
implicitly[Fooable[C]]
exit
import scala.reflect.runtime.universe.{typeOf, TypeRef}
typeOf[Int] match { case TypeRef(_, sym, _) => println(sym) }
import scala.reflect.runtime.universe.TypeRefTag
typeOf[Int] match { case TypeRef(_, sym, _) => println(sym) }
exit
NoSymbol.associatedFile
staticClass("Int")
getClass("Int")
getDefinedClass("Int")
getClassByName("Int")
definitions.getClassByName("Int")
rootMirror.getClassByName("Int")
rootMirror.getClassByName(newTypeName("Int"))
rootMirror.getClassByName(newTypeName("scala.Int"))
res8.associatedFile
rootMirror.getClassByName(newTypeName("scala.collection.immutable.List"))
res10.associatedFile
res10.associatedFile.getFile
res10.associatedFile.path
case class C(x: Int)
new C().productIterator
new C(2).productIterator
new C(2).asInstanceOf[Product]
new C(2).asInstanceOf[Product].productIterator.toList
for (i <- 0 to 2) println(i)
import scala.collection.mutable.ListMap
ListMap(1 -> 2)
(2 -> 3) +: ListMap(1 -> 2)
(2 -> 3) + ListMap(1 -> 2)
(2 -> 3) ++: ListMap(1 -> 2)
(2 -> 3) +: ListMap(1 -> 2).toList
sys.props("foo")
Some(2) collect { case x == 3 => x }
Some(2) collect { case x if x == 3 => x }
q""
exit
q""
val x = ValDef(NoMods, TermName("x"), Ident(TypeName("Int")), EmptyTree)
q"def foo($x)"
exit
q"def foo($x)"
q"{ $x }"
exit
Block(Literal(Constant(2))
)
exit
object 
)
object X { { val x = 2 } }
object X { { val x = 2 } println(x) }
object X { { val x = 2 }; println(x) }
object X { { val x = 2 } }
X.x
val _1 = 2
_1
s"${_}"
_
List("x") map (s"${_}")
exit
reify{List[String]()}
reify{List[String]("a")}
type X = Int
reify{List[X](2)}
exit
List(1) ++ List(2)
def foo e
class foo extends scala.annotation.StaticAnnotation
class C @foo (x: Int)
class foo extends scala.annotation.StaticAnnotation
def impl(c: Context) = c.universe.Ident(c.universe.TypeName("Int"))
@foo({def fooInAnn = macro Impls.foo; fooInAnn})
  def foo = println("it works")
class foo(val bar: Int) extends annotation.StaticAnnotation
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.TypeName("Int"))
@foo({ type Foo(x: Int) = macro Impls.foo; class D extends Foo(2); val x: Foo(2) = new D; x.x })
  def foo = println("it works")
@foo({ type Foo(x: Int) = macro impl; class D extends Foo(2); val x: Foo(2) = new D; x.x }) def foo = ???
class
C
def impl(c: Context)(x: c.Expr[Int]) = c.universe.Ident(c.universe.TypeName("C"))
@foo({ type Foo(x: Int) = macro impl; class D extends Foo(2); val x: Foo(2) = new D; x.x }) def foo = println("it works")
{ class C; @foo({ type Foo(x: Int) = macro impl; class D extends Foo(2); val x: Foo(2) = new D; x.x }) def foo = println("it works") }
exit
q"class Foo extends ${tq"Bar"}"
q"class Foo extends ..${List(tq"Bar", tq"Baz")}"
val q"class Foo extends ..$parents" = res1
q"package foo"
val v = q"val x: Int"
q"def foo($v)"
val v: ValDef = q"val x: Int"
val v: Tree = q"val x: Int"
q"def foo($v)"
q"def foo(${TermName("x")})"
def impl(c: Contex
def impl(c: Context) = c.abort(c.enclosingPosition, "macro has reported an error")
def test = macro impl
test
val q"foo(...$argss)" = q"foo(2)(3)"
val name = newTermName("foo")
val name = TermName("foo")
val name = TypeName("C")
val q"class $name1" = q"class $name"
val args = List(Literal(Constant(2)))
val q"foo(..$args)" = q"foo(..$args)"
val q"foo(..$args1)" = q"foo(..$args)"
val q"foo(..$args1)" = q"foo($args)"
val argss = List(List(Literal(Constant(2))), List(Literal(Constant(3)))))
val argss = List(List(Literal(Constant(2))), List(Literal(Constant(3))))
val q"foo(..$argss1)" = q"foo(..$argss)"
val q"foo(...$argss1)" = q"foo(...$argss)"
q"foo(...$argss)
q"foo(...$argss)"
val argss = List(List(Literal(Constant(2))), List(Literal(Constant(3)))))
val argss = List(List(Literal(Constant(2))), List(Literal(Constant(3))))
q"foo(...$argss)"
val foo = TermName("foo")
q"$foo(...$argss)"
q"$foo()(...$argss)"
case class Foo[A <: TypeTag]
case class Foo[A: TypeTag]
case class Foo[A: TypeTag](xs: List[A])
"foo.bar".split(".")
"foo.bar".split("b")
"foo.bar".split(".")
"foo.bar".split(Pattern.quote("."))
"foo.bar".split(java.util.regex.Pattern.quote("."))
"foo".split(java.util.regex.Pattern.quote("."))
"".split(java.util.regex.Pattern.quote("."))
typeOf[List].typeSymbol.fullName
typeOf[List[_]].typeSymbol.name
typeOf[List[_]].typeSymbol.fullName
Select(Ident(TermName("foo")), TermName("bar"))
def 
))
def impl(c: Context)(x: c.Expr[String]) = x
def foo = macro impl
def foo(x: String) = macro impl
foo("""z""")
def impl(c: Context)(x: c.Expr[String]) = { println(showRaw(x)); x }
def foo(x: String) = macro impl
foo("""zzz""")
def impl(c: Context)(x: c.Expr[String]) = { println(showRaw(x.tree)); x }
def foo(x: String) = macro impl
foo("""zzz""")
foo(s"zzz")
def impl(c: Context)(x: c.Expr[String]) = { println(showRaw(x.tree)); println(c.eval(x)); x }
def foo(x: String) = macro impl
foo(s"zzz")
val ct = classTag[List[_]]
ct.unapply(List(2))
ct.unapply(Map(1 -> 2))
def impl(c: Conte
def impl(c: Context) = c.universe.Ident(c.universe.TypeName("C"))
type foo = macro impl
def impl(c: Context) = c.universe.Ident(c.universe.TypeName("C"))
type foo = macro impl
type X = foo
type Foo = impl2
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
def foo = 2
foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
type Foo = macro impl2
type X = Foo
q"x"
exit
q"x"
exit
typeTag[String]
showRaw(typeTag[String], printIds = true)
typeOf[ClassManifest].typeSymbol.annotations
typeOf[ClassManifest[_]].typeSymbol.annotations
cm.staticPackage("scala")
cm.staticPackage("scala").typeSignature.member(newTermName("package"))
res3.typeSignature.getMember(newTypeName("cloneable"))
res3.typeSignature.member(newTypeName("cloneable"))
res5.annotations
class C { def x = 2 }
cm.reflect(new C)
val cm = scala.reflect.runtime.currentMirror
cm.reflect(new C)
res1.reflectMethod(typeOf[C].member(newTermName("x")).asMethod)
res1.reflectMethod(scala.reflect.runtime.universe.typeOf[C].member(newTermName("x")).asMethod)
import scala.reflect.runtime.universe._
res1.reflectMethod(typeOf[C].member(newTermName("x")).asMethod)
res4.bind(new C)
res4()
res5()
class C { class D }
val c = new C
c.D
typeOf[c.D]
showRaw(typeOf[c.D])
{ val c = new C; showRaw(typeOf[c.D]) }
{ var c = new C; showRaw(typeOf[c.D]) }
trait TypezSig {
  case class Num(i:Int,f:Float)
  case class Mat(rows:Num,cols:Num)
  type Alphabet = Mat
  type Answer = (Num,Mat)
}
typeOf[TypezSig#Num]
trait TypezSig {
  case class Num(i:Int,f:Float)
  case class Mat(rows:Num,cols:Num)
  type Alphabet = Mat
  type Answer = (Num,Mat)
}
object Typez extends TypezSig {
  import scala.reflect.runtime.universe._
  import scala.reflect._
  def foo[Alphabet,Answer]()(implicit t1:TypeTag[Alphabet],t2:TypeTag[Answer],c1:ClassTag[Alphabet],c2:ClassTag[Answer],m1:Manifest[Alphabet],m2:Manifest[Answer]) {
  println(t1.tpe.toString+" --- "+c1.toString+" --- "+m1.toString)
  println(t2.tpe.toString+" --- "+c2.toString+" --- "+m2.toString)
  }
  foo[Alphabet,Answer]();
}
Typez
exit
val x = classTag[List[Int]]
val y: ClassTag[List[_]] = x
exit
{ def foo(x: Int) = x; def foo(x: Int*) = x }
class C{ def foo(x: Int) = x; def foo(x: Int*) = x }
new C().foo(1)
new C().foo(1, 2)
new C().foo()
typeOf[List[_]].typeSymbol.fullName
trait Foo[T]; object Foo { implicit object FooString extends Foo[String] }
def foo[T: Foo](x: T)
= ???
def foo[T: Foo](x: T) = x
foo(1)
foo("1")
class Qwe { trait Foo[T]; object Foo { implicit object FooString extends Foo[String] } }
class Qwe { trait Foo[T]; object Foo { implicit object FooString extends Foo[String] }; def foo[T: Foo](x: T) = x }
new Qwe().foo(1)
new Qwe().foo("1")
val qwe = new Qwe()
qwe.foo(1)
qwe.foo("1")
exit
{ class C; weakTypeOf[C] }
cm.runtimeClass(res0)
showRaw(res0)
showRaw(res0, printIds = true, printKinds = true)
classOf[List[_]].getName
typeOf[List[_]].typeSymbol.typeSignature
typeOf[List[_]].typeSymbol.typeParams
typeOf[List[_]].typeSymbol.asClass.typeParams
exit
locally { class E; manifest[E] }
exit
  def _seq = _op(";")_
def _op (opSymbol: String)(children: Int*)  = {}
  def _seq = _op(";")_
null eq null
exit
val q"x" = Ident(TermName("x"))
val q"$x" = Ident(TermName("x"))
1 to 5
1 to 5 map (_)
1 to 5 map (x => x)
q"x"
def impl(c: Context) = { import c.universe._; println(showRaw(c.macroApplication, printPositions = true); c.literalUnit
def impl(c: Context) = { import c.universe._; println(showRaw(c.macroApplication, printPositions = true); c.literalUnit }
def impl(c: Context) = { import c.universe._; println(showRaw(c.macroApplication, printPositions = true)); c.literalUnit }
import scala.reflect.macros.Context
def impl(c: Context) = { import c.universe._; println(showRaw(c.macroApplication, printPositions = true)); c.literalUnit }
def foo = macro impl
foo
case class C(x: Int)
typeOf[X].fields
typeOf[X].declarations
typeOf[C].declarations
typeOf[C].declarations.filter(_.isCaseAccessor)
typeOf[C].declarations.collect{ case x: TermSymbol if x.isCaseAccessor => x }
typeOf[C].declarations.collect{ case x: TermSymbol if x.isParamAccessor => x }
typeOf[C].declarations.collect{ case x: TermSymbol if x.isValue && x.isCaseAccessor => x }
typeOf[C].declarations.collect{ case x: TermSymbol if x.isVal && x.isCaseAccessor => x }
exit
cl
class C { def foo[T]: T = ??? }
val sym = typeOf[C].declaration(TermName("foo")).asMethod
sym.typeSignature
def impl[A](c: reflect.makro.Context) = c.reify(())
def impl[A](c: reflect.macros.Context) = c.reify(())
def impl[A](c: reflect.macros.Context) = c.universe.reify(())
def decl[A] = macro impl[A]
decl
def impl[A](c: reflect.macros.Context) = c.universe.reify(())
def decl[A] = macro impl[A]
decl
object impl { def apply = "" }
impl
impl()
object M { def apply[T, U](x: Int) = ??? }
M[Int, Int]
object M { def apply[T, U] = ??? }
M[Int, Int]
def impl(c: Context): Unit = c.enclosingMethod match {
case DefDef(_, name, _, _, _, _) => c.universe.reify(println(c.literal(name.toString).splice))
case _ => c.abort(c.enclosingPosition, "no enclosing method")
}
def impl(c: Context): Unit = {
import c.universe._
c.enclosingMethod match {
case DefDef(_, name, _, _, _, _) => c.universe.reify(println(c.literal(name.toString).splice))
case _ => c.abort(c.enclosingPosition, "no enclosing method")
}
def printEnclosingMethod = macro impl
def impl(c: Context) = {
import c.universe._
c.enclosingMethod match {
case DefDef(_, name, _, _, _, _) => c.universe.reify(println(c.literal(name.toString).splice))
case _ => c.abort(c.enclosingPosition, "no enclosing method")
}
def printEnclosingMethod = macro impl
def foo = printEnclosingMethod
foo
printEnclosingMethod
exit
import scala.reflect.runtime.{universe => ru}
trait X { def foo: String }
ru.typeOf[X]
res0.members
res0.members.sorted
def foo[T](x: T) = x.getClass
foo(List(1, 2, 3))
def foo[T: ru.TypeTag](x: T) = ru.typeOf[T]
foo(List(1, 2, 3))
ru.showRaw(res4)
import scala.reflect.runtime.universe._
import scala.tools.reflect.ToolBox
val tree = Apply(Select(Literal(Constant(40)),
    newTermName("$plus")), List(Literal(Constant(2))))
val cm = ru.runtimeMirror(getClass.getClassLoader)
println(cm.mkToolBox().eval(tree))
def impl(c: Context) = { c.error(c.enclosingPosition, "foo"); c.error(c.enclosingPosition, "bar"); c.literalUnit }
def foo = macro impl
foo
def impl(c: Context) = { c.warning(c.enclosingPosition, "foo"); c.warning(c.enclosingPosition, "bar"); c.literalUnit }
def foo = macro impl
foo
def impl(c: Context) = { c.error(c.enclosingPosition, "foo"); c.warning(c.enclosingPosition, "bar"); c.literalUnit }
def foo = macro impl
foo
if (false) Array("qwe") else Array[Nothing]()
class C(val x: Int) extends AnyVal
class D { val c = new C(2) }
reify(Nil: _*)
exit
List(1) match { case _ :: Nil => }
List(1, 2) match { case _ :: Nil => }
List() match { case _ :: Nil => }
List(1, 2) match { case _ +: Nil => }
List(1, 2) match { case _ ::: Nil => }
List(1, 2) match { case _ :+ Nil => }
List(1, 2) match { case _ :+ _ => }
List(1) match { case _ :+ _ => }
List() match { case _ :+ _ => }
List() match { case _ :: _ => }
List(1) match { case _ :: _ => }
List(1, 2) match { case _ :: _ => }
List(1, 2) match { case _ :+ superCall => }
List(1) match { case _ :+ superCall => }
List() match { case _ :+ superCall => }
class C @ann (x: Int)
class C @ann() (x: Int)
class C { class I }
def foo(c: C) = new c.I()
def foo(c: => C) = new c.I()
class A
(ru: scala.reflect.api.Universe).typeOf[A]
ru.typeOf[A]
(ru: scala.reflect.api.Universe).typeTag[A]
(ru: scala.reflect.api.Universe).weakTypeTag[A]
Some(null)
Option(null)
Option(2)
Option(null)
Some(null)
Option(None)
xit
exit
val list = (1 to 10000).toList
    list.par.map(_ + 42)
exit
0 until 5
exit
-1 % 8
1 to 5
1.5.asInstanceOf[Int]
List.range(0, 10)
1.5.asInstanceOf[Int]
0.9.toInt
0 to 1
0 to 15
-(-1 % 8)
class C { def foo(x: Int)(y: Int) = 2 }
typeOf[C].member(TermName("foo")).typeSignature
res0.paramss
typeOf[C].member(TermName("foo")).asMethodSymbol
typeOf[C].member(TermName("foo")).asMethod
res3.paramss
res3.returnType
res3.paramss.tail.foldLeft(MethodType(res3.paramss.head, res3.returnType), (MethodType(_, _)))
res3.paramss.tail.foldLeft(MethodType(res3.paramss.head, res3.returnType))((MethodType(_, _)))
res3.paramss.tail.foldLeft(MethodType(res3.paramss.head, res3.returnType))((acc, params) => MethodType(params, acc))
class C { def foo(x: Int)(y: Int) = 2 }
class C { def foo(x: Int)(y: Int)(z: Int) = 2 }
typeOf[C].member(TermName("foo")).asMethod
val paramss = res9.paramss
val implReturnType = res9.returnType
paramss.tail.foldLeft(MethodType(paramss.head, implReturnType))((acc, params) => MethodType(params, acc))
paramss.init.foldLeft(MethodType(paramss.last, implReturnType))((acc, params) => MethodType(params, acc))
paramss.init.foldRight(MethodType(paramss.last, implReturnType))((acc, params) => MethodType(params, acc))
paramss.init.foldRight(MethodType(paramss.last, implReturnType))((acc, params) => MethodType(acc, params))
paramss.init.foldRight(MethodType(paramss.head, implReturnType))(MethodType(_, _))
res14.asInstanceOf[scala.reflect.internal.Types#Type]
res15.paramss
res15.finalResultType
res15.typeParams
exit
def StringContext(parts: String*) = ???
s"a"
def impl(c: scala..macros.Context) = ???
def impl(c: scala.reflect.macros.Context) = ???
def foo(x: Int) = 2
def foo(x: _) = 2
def impl(c: scala.reflect.macros.Context)(x: c.Tree) = ???
class C { def m(x: _): _ = macro impl }
def impl(c: Context)(x: c.Expr[Int]) = ???
def foo(x: Int = 2) = macro impl
1 match { case 1 | 2 => }
1 match { case 3 | 2 => }
List(1) match { case List(1 | 2) => }
zip(List(1, 2), List(1, 2, 3))
List(1, 2).zip(List(1, 2, 3))
List(1, 2) exists { case 1 => true }
List(1, 2) collect { case 1 => -1; case 3 => -2 }
List(1, 2, 3).init
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = x
def foo(x: Int)(y: Int) = macro impl
foo(2)(3)
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = x
def foo(x: Int)(y: Int) = macro impl
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = x
def foo(x: Int)(y: Int) = macro impl
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = x
def foo(x: Int)(y: Int) = macro impl
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = x
def foo(x: Int)(y: Int) = macro impl
def impl(c: Context)(x: c.Expr[Int])(y: c.Expr[Int]) = x
def foo(x: Int)(y: Int) = macro impl
def impl(c: Context): c.Tree = ???
def foo: Int = macro impl
def impl(c: Context): c.Tree = ???
def foo: Int = macro impl
def foo(x: => Any) = ???
def foo[M[_]] = ()
foo[List]
foo[List[T] forSome { type T }]
val x: List[T] forSome { type T } = List(1, 2)
x ++ 3
x :+ 3
List(1, 2) splitAt -1
List() :+ List(1, 2)
if true Nil else List(1) ++ List(2)
if (true) Nil else List(1) ++ List(2)
2 min 3
min(2, 3)
import Math.min
min(2, 3)
java.lang.Math
scala.Math
java.lang.Math
import java.lang.Math.min
def foo(x: Int*) = x
foo(2, 3, 4)
"(Found in|and)".r.replaceAllIn("Found in", m => m.group(1))
"(Found in|and)".r.replaceAllIn("Foundn", m => m.group(1))
"(Found in|and)".r.replaceAllIn("Foundn", m => m.group(0))
"(Found in|and)".r.replaceAllIn("Foundn", m => m.group(2))
"(Found in|and)".r.replaceAllIn("Foundn", m => m.group)
"(Found in|and)".r.replaceAllIn("Foundn", m => m.groupCount)
"(Found in|and)".r.replaceAllIn("Foundn", m => m.groupCount.toString)
"(Found in|and)".r.replaceAllIn("and", m => m.groupCount.toString)
"(Found in|and)".r.replaceAllIn("and", m => m.group(0))
"(Found in|and)".r.replaceAllIn("and", m => m.group(1))
"(Found in|and)".r.replaceAllIn("and", m => m.group(3))
class C { def foo(x: Int*) = ??? }
typeOf[C].member(TermName("foo")).typeSignature
showRaw(res0)
class C { def m(x: _): _ = macro impl }
import scala.reflect.runtime.universe._
val m = typeOf[C].member(newTermName("m")).asMethod
m.params(0)(0).typeSignature
m.paramss(0)(0).typeSignature
showRaw(m.paramss(0)(0).typeSignature)
def impl(c: Context)(x: c.Tree): c.Tree = ???
def foo(x: _) = macro impl
foo(2)(3)
foo
def impl(c: Context)(x: c.Tree): c.Tree = ???
def foo(x: _) = macro impl
foo(2)(3)
foo
def impl(c: Context)(x: c.Tree): c.Tree = ???
def foo(x: _) = macro impl
foo(2)(3)
foo(2)
foo
def impl(c: Context)(x: c.Tree): c.Tree = ???
def foo(x: Int) = macro impl
foo
foo(2)(3)
def impl(c: Context)(x: c.Tree): c.Tree = c.literal(2)
def impl(c: Context)(x: c.Tree): c.Tree = c.literal(2).tree
def foo(x: Int) = macro impl
foo(2) + foo(3)
def foo(x: Int): Int = macro impl
foo(2)(3)
def impl(c: Context)(x: c.Tree): c.Tree = c.literal(2).tree
def foo(x: Int) = macro impl
foo(2)(3)
def impl(c: Context)(x: c.Tree): c.Tree = c.literal(2).tree
def foo(x: Int) = macro impl
foo(2)(3)
def impl(c: Context)(x: c.Tree): c.Tree = c.literal(2).tree; def foo(x: Int) = macro impl; foo(2)(3)
val cm = universe.runtimeMirror(getClass.getClassLoader)
import scala.tools.reflect.ToolBox
val tb = cm.mkToolBox()
tb.eval(tb.parse("class C; new D"))
tb.frontEnd.infos
case class Country(id: String, name: String) extends Domain
case class Country(id: String, name: String)
typeOf[Country].declarations
typeOf[Country].declarations.collect{ case sym if sym.isVal => sym.asTerm }
typeOf[Country].declarations.collect{ case sym if sym.Term => sym.asTerm }.filter(_.isVal)
typeOf[Country].declarations.collect{ case sym if sym.isTerm => sym.asTerm }.filter(_.isVal)
typeOf[Country].declarations.toList.collect{ case sym if sym.isTerm => sym.asTerm }.filter(_.isVal)
typeOf[Country].declarations.toList.collect{ case sym if sym.isTerm => sym.asTerm }.filter(_.isParamAccessor)
typeOf[Country].declarations.toList.collect{ case sym if sym.isTerm => sym.asTerm }.filter(sym => sym.isVal && sym.ParamAccessor)
typeOf[Country].declarations.toList.collect{ case sym if sym.isTerm => sym.asTerm }.filter(sym => sym.isVal && sym.isParamAccessor)
def impl(c: Context)(x: c.universe.Ident) = ???
def foo(x: _) = macro impl
def foo = macro impl
exit
def foo = macro impl
impl
impl2
def foo = macro impl1
def foo(x) = x
def impl[A](c: reflect.makro.Context) = c.reify(())
def impl[A](c: Context) = c.reify(())
def impl[A](c: Context) = c.literalUnit
def decl[A] = macro impl[A
]
decl[Any]
decl
exit
def foo = macro impl1
foo
exit
lazy List(x, y) = List(1, 2)
lazy val List(x, y) = List(1, 2)
:power
ScalaPackage
ScalaPackageClass
ScalaPackageClass.isModuleClass
ScalaPackageClass.isModule
ScalaPackage.isModule
ScalaPackage.sourceModule
ScalaPackageClass.sourceModule
class C {
lazy val list = List(1, 2)
lazy val List(x, y) = list
}
class C {
private lazy val list = List(1, 2)
lazy val List(x, y) = list
}
def foo = macro impl1
{ class anon { def x = 2 }; new anon }
{ final class anon { def x = 2 }; new anon }

#!/usr/bin/env python
import sys, os, subprocess, json, shutil, time
from subprocess import check_output, call, check_call, Popen, PIPE

sublime = "--sublime" in sys.argv
sys.argv = filter(lambda arg: not arg.startswith("-"), sys.argv)

if len(sys.argv) < 2:
  print "usage: " + sys.argv[0] + " [--sublime] <action> [<args>]"
  sys.exit(1)

action = sys.argv[1]
args = sys.argv[2:]

env = {}
env["action"] = action
env["args"] = args
env["working_dir"] = os.path.abspath(".")
env["status"] = 0

def notify(msg):
  if (sublime): call(["growlnotify", "-n", "Kepler", "-m", str(msg)])
  else: print msg

def exit(retcode):
  # if sublime:
  #   print("[Exited with code " + str(retcode) + "]")
  print("[Exited with code " + str(retcode) + "]")
  sys.exit(retcode)

try:
  if action == "compile":
    target = args[0] if args else ""
    # TODO: looks like I can't reasonably get away without gaika supporting multiple compilation scenarios
    git_root = Popen(["git", "rev-parse", "--show-toplevel"], stdout=PIPE).communicate()[0][:-1]
    if os.path.abspath(git_root).startswith("/Users/xeno_by/Projects/scala-pickling"):
      root = git_root
      env["result_file_regex"] = "([:.a-z_A-Z0-9\\\\/-]+[.]scala):([0-9]+)"
      env["result_line_regex"] = ""
      env["result_base_dir"] = root
      exit(call(["sbt", "-Dsbt.log.noformat=true", "package"], cwd = root))
    elif args and args[0].endswith(".tex"):
      target = args[0]
      root = os.path.dirname(os.path.abspath(target))
      exit(call(["xelatex", target], cwd = root))
    elif args and args[0].endswith(".bib"):
      bib = args[0]
      (baseline, ext) = os.path.splitext(bib)
      tex = baseline + ".tex"
      root = os.path.dirname(os.path.abspath(bib))
      status = call(["xelatex", tex], cwd = root)
      if status: sys.exit(status)
      status = call(["bibtex", baseline], cwd = root)
      if status: sys.exit(status)
      status = call(["xelatex", tex], cwd = root)
      if status: sys.exit(status)
      status = call(["xelatex", tex], cwd = root)
      exit(status)
    else:
      root = check_output(["scala-root"]).strip()
      if os.path.abspath(".").startswith(root):
        tier = check_output(["scala-tier"]).strip()
        env["result_file_regex"] = "([:.a-z_A-Z0-9\\\\/-]+[.]scala):([0-9]+)"
        env["result_line_regex"] = ""
        env["result_base_dir"] = root
        if tier == "pack": exit(call(["ant"], cwd = root))
        elif tier == "quick": exit(call(["ant", "quick.comp"], cwd = root))
        elif tier == "locker": exit(call(["ant", "locker.unlock", "locker.done"], cwd = root))
        else: print "unknown tier: " + str(tier); exit(1)
      else:
        print("unsupported target at " + os.path.abspath("."))
        exit(1)
  elif action == "clean":
    root = check_output(["scala-root"]).strip()
    def clean_quick(target):
      quick = os.path.join(root, "build/quick")
      complete = os.path.join(quick, target + ".complete")
      classes = os.path.join(quick, "classes/" + target)
      if os.path.exists(complete): os.unlink(complete)
      if os.path.exists(classes): shutil.rmtree(classes)
      notify("Cleaned quick/" + target)
    target = args[0]
    if target == "quick@compiler+reflect":
      clean_quick("compiler")
      clean_quick("reflect")
      clean_quick("repl")
      exit(0)
    elif target.startswith("quick@"):
      clean_quick(target[len("quick@"):])
      exit(0)
    elif target == "all":
      map(lambda target: clean_quick(target), ["library", "reflect", "compiler", "repl"])
      exit(0)
    else:
      notify("unknown clean target: " + target)
      exit(1)
  else:
    notify("unsupported action " + action)
    exit(1)
except:
  tpe, value, tb = sys.exc_info()
  if tpe != SystemExit:
    # print tpe
    notify(value)
    # traceback.print_tb(tb)
    env["status"] = 1
    sys.exit(1)
  else:
    env["status"] = value.code
    sys.exit(value.code)
finally:
  dotgaika = os.path.expandvars("$HOME/.gaika")
  with open(dotgaika, "w") as f: json.dump(env, f)

